
\section{Dirac Notation Core Language}

The basic part of Dirac notations is an extension of linear algebra, which can possibly be determined by a term rewriting system. Following this constraint, we make the decision procedure simpler and more explainable. Therefore, we first consider a simple core language of Dirac notations.


\subsection{Language Syntax}

Because we study Dirac notation modular the basis and complex numbers, we first define the interface for the system of basis and complex numbers. \yx{This corresponds to the module type in \texttt{Coq}.}

\begin{definition} [atomic basis signature]
  The \textbf{atomic basis signature} $\Sigma_\mathcal{A}$ is a  typed finite language.
\end{definition}

Because we consider the tensor product data structure, larger Hilbert spaces can be decomposed into the atomic ones, such as the qubit Hilbert space. The atomic basis here characterize the basis of the atomic Hilbert spaces.
We limit the basis signature to finite languages to avoid problems of infinite dimensions.

\begin{definition} [complex number signature]
  The \textbf{complex number signature} $\Sigma_\mathcal{C}$ contains at least constant symbols $0, 1$, a unary symbol $*$ and binary symbols $+, \times$.
\end{definition}

Following the idea of the avatar lemma, the two signatures $\Sigma_\mathcal{A}$ and $\Sigma_\mathcal{C}$ characterize the language for atomic basis and complex numbers. 
The symbols for complex numbers are zero, one, conjugate, addition and multiplication respectively. Compared the avatar language in the Lineal paper\cite{Arrighi2017}, it adds the conjugate symbol since we need to deal with conjugate and inner product.
These symbols are only the least requirements as interfaces, and the real language to instantiate can contain more details. For example, the basis can contain symbols $0$ and $1$ for qubit spaces, and the complex numbers can still have exponential functions $e^x$ or square roots $\sqrt{x}$.


One difficulty of formalizing Dirac notations and designing the rewriting rules is the overloading of operators. This feature makes Dirac notations flexible and easy to use, but also introduced ambiguity into the syntax. For example, the symbol $\ket{i} \otimes \bra{j}$ is interpreted as the outer product, while $\ket{i} \otimes \ket{j}$ is interpreted as the tensor product of kets, although they share the same symbol. 
In the core langauge, we disambiguate by explicitly introduce different symbols for each interpretations of the ``same'' syntax, and encode the types of Dirac notations by special typing symbols in the signature.
% In this way, we can to rely on existing theories and tools to prove relevant properties.

\begin{definition}[core language of Dirac Notation]
  The \textbf{core language of Dirac Notation}, denoted as $\textsf{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, is a many-sorted language with dependent types, defined as follows.
  \begin{align*}
    & \textbf{Types} && \textrm{(basis types)} && \sigma ::= A\ |\ \sigma \times \sigma, \\
    & && \textrm{(Dirac types)} && T ::= \Sc\ |\ \K(\sigma)\ |\ \B(\sigma)\ |\ \Op(\sigma, \sigma), \\
    \\
    & \textbf{Terms} && \textrm{(complex number)} && \alpha \in \Sigma_\mathcal{C}, \\
    & && \textrm{(basis)} && t ::= x\ |\ a\ |\ (t, t)\ |\ \fst t\ |\ \snd t, \\
    & && \textrm{(scalar)} && S ::= x\ |\ C(\alpha)\ |\ \delta_{t, t}\ |\ S + S\ |\ S \times S\ |\ S^*\ |\ B \cdot K, \\
    & && \textrm{(ket)} && K ::= x\ |\ \mathbf{0}_\mathcal{K}(\sigma)\ |\ \ket{t}\ |\ B^\dagger\ |\ S.K\ |\ K + K\ |\ O \cdot K\ |\ K \otimes K, \\
    & && \textrm{(bra)} && B ::= x\ |\ \mathbf{0}_\mathcal{B}(\sigma)\ |\ \bra{t}\ |\ K^\dagger\ |\ S.B\ |\ B + B\ |\ B \cdot O\ |\ B \otimes B, \\
    & && \textrm{(operator)} && O ::= x\ |\ \mathbf{0}_\mathcal{O}(\sigma, \sigma)\ |\ \mathbf{1}_\mathcal{O}(\sigma)\ |\ K \otimes B\ |\ O^\dagger\ |\ S.O\ |\ O + O\ |\ O \cdot O\ |\ O \otimes O.
  \end{align*}
   Here we use $x$ to represent variables, $A$ to represent atomic basis types, $a$ to represent atomic basis in $\Sigma_\mathcal{A}$, lower case letters like $s, t$ to represent basis from $\mathcal{E}$, and Greek letters like $\alpha$ to represent complex number terms from $\Sigma_\mathcal{C}$. We use letters $S$, $K$, $B$, $O$ and their variants to represent terms from the scalar, ket, bra and operator sorts repsectively.
\end{definition}

The types have two levels: the basis type, corresponding to the type of Hilbert space, can be constructed by atomic basis type $A$ or a product type. The next level are types for Dirac notations: $\mathcal{S}$ for complex scalars, $\mathcal{K}(\sigma)$ for kets, $\mathcal{B}(\sigma)$ for bra, and $\mathcal{O}(\sigma, \tau)$ for operators. By such formalization, we can also find that the informal Dirac notation can be casual and ambiguous sometimes. For example, the $\ket{\cdot}$ symbol is explained differently in $\braket{u|v}$ and $\sum_{i}\ket{i}$, where the former means $v$ is a ket and the latter means $\ket{i}$ is a basis vector of $i$.

For the terms, although we use the same characters in different sorts ($B \cdot K$ and $O \cdot K$, for example), they are actually different symbols and can be easily distinguished from the context. This is also reflected in the \texttt{CiME2} script. Here $\mathbf{0}$ and $\mathbf{1}_\mathcal{O}$ are the zero elements and the identity operator in corresponding spaces, indicated by the type notation. $X^\dagger$ means adjoint operation, $S.X$ means scalar multiplication, $A \cdot B$ is the operator application or inner product, and $A \otimes B$ is outer product or tensor product.

We can consider possible candidates for instantiating $\Sigma_\mathcal{C}$, which touches the decidability problem of reals. We know that real closed fields are decidable\cite{Tarski1998}. Here the avatar signature $\{0, 1, *, +, \times\}$ incoporates a new conjugate symbol, but we can also try to add symbols pervasively used in quantum, such as exponential functions, trigonometric functions and square/square root.
The choice of the atomic basis language $\Sigma_\mathcal{A}$ has large freedom and can be suited to different scenarios. Besides introducing constant symbols (e.g., $0$ and $1$ basis), richer language with operations on basis terms are also possible. 

One interesting question is why we only consider adjoint $X^\dagger$ out of conjugate $X^*$ and transpose $X^\top$ in the core language. One fact is that any two of them can construct the third one. Also, transpose can be constructed after we introduce the big operator sum in the following sections. 
Another consideration comes from a confluence problem. Since transpose is involutive (i.e., $(B^\top)^\top = B$), we cannot encode the axiom $ (B \cdot K)^\top = K^\top \cdot B^\top$ in the naive term rewriting system. We discovered that the difficulty raises with coexistence of adjoint, conjugate and transpose: any two of them will lead to this problem. Therefore, we put adjoint in the core language since it is more commonly used.

Another question is why we have two languages of complex scalars.
We make the modularity explicit by separating the complex number sort $\mathcal{C}$ from the scalar sort $\mathcal{S}$ in Dirac notations. It is necessary because the scalar language is defined by mutual induction with ket, bra and basis, which does not appear in standard language of complex. This also indicates the joint position in the term rewriting system: the rules for complex numbers can vary in different cases of $\sum_\mathcal{C}$, and our work on Dirac notations is to design the general rewriting rules involving inner products and Kronecker-Delta expressions. Separating the two languages allows us to apply the avatar lemma in theoretical analysis. From the implementation level, it means we can directly utilize different solvers that focus on complex numbers, and extend the language of complex numbers easily by modifying $\sum_\mathcal{C}$.
The same discussion applies for the language of basis. The atomic basis describes every individual subsystem in the physical level. The pairing and projections are for basis in Hilbert space with tensor products, which lie in the logic level.

Finally, it is necessary to explain why we does not disambiguate depending on the typing information, and why we does not use type decorations.
Certainly, in the aforementioned approach we can preserve the different interpretations of the same Dirac syntax, and the signature will be simpler and closer to how people are accustomed to.
But the consideration mainly falls into 
% the feasibility of confluence proof and 
the rewriting efficiency. 
The use of type decorations will introduce the extra burden of matching the decorations. Moreover, it is not clear how to ``flatten'' the typing decorations and mix them with AC symbols in the expressions.
If we want to disambiguate by typing information, but without using decorations, then the type of expressions will need to be deduced dynamically, which is even more inefficient.
And after all, the syntax here works as the internal language at the backend, and we have a user language with simpler signature, which is compiled into the internal language with the typing information.





\subsection{Context and Typing}
In order to check whether one expression can be correctly interpreted, we designed the rules to decide the well-typed expressions. For this purpose, we need the assumptions on the typing of variables appearing in the expression. This is provided by the \textit{typing assumption} and \textit{context} defined below.

\begin{definition}[context]
  A \textbf{typing assumption} is written as $x : X$, meaning that variable $x$ is of type $X$. A \textbf{context} $\Gamma$ is an ordered list of typing assumptions. We write $x : X \in \Gamma$ if the typing assumption is contained in context $\Gamma$, and $x \in \Gamma$ if there exists a typing assumption of $x$ contained in $\Gamma$. A context is well-formed if the variables appear uniquely in the context. Below we only consider the well-formed contexts.
\end{definition}

We con decide whether an expression $e$ is well-typed in the context $\Gamma$, which is the \textbf{typing judgement} written as $\Gamma \vdash e : X$, indicating that $e$ is an expression of type $X$ in context $\Gamma$.
We say the term $e$ is a \textbf{well-typed} term in context $\Gamma$ if $\Gamma \vdash e : X$ is a typing judgement for some $X$. The typing judgement is decided by the following rules.

\textsc{(Context)}
\begin{gather*}
  \frac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}
\end{gather*}

\textsc{(Basis)}
\begin{gather*}
  \frac{a \text{ is an atomic basis of } A}{\Gamma \vdash a : A}
  \qquad
  \frac{\Gamma \vdash s : \tau \qquad \Gamma \vdash t : \sigma}{\Gamma \vdash (s, t) :  \tau \times \sigma }
  \qquad
  \frac{\Gamma \vdash s : \sigma \times \tau }{\Gamma \vdash \fst s : \sigma}
  \qquad
  \frac{\Gamma \vdash s : \sigma \times \tau }{\Gamma \vdash \snd s : \tau}
\end{gather*}

\textsc{(Complex Scalar)}
\begin{gather*}
  \frac{}{\Gamma \vdash C(\alpha) : \Sc}
  \qquad
  \frac{\Gamma \vdash s : \sigma \qquad \Gamma \vdash t : \sigma}{\Gamma \vdash \delta_{s, t} : \Sc} \\
  \\
  \frac{\Gamma \vdash S_1 : \Sc \qquad \Gamma \vdash S_2 : \Sc }{\Gamma \vdash S_1 + S_2 : \Sc }
  \qquad
  \frac{\Gamma \vdash S_1 : \Sc \qquad \Gamma \vdash S_2 : \Sc}{\Gamma \vdash S_1 \times S_2 : \Sc}
  \qquad
  \frac{\Gamma \vdash S : \Sc}{\Gamma \vdash S^* : \Sc}
  \qquad
  \frac{\Gamma \vdash B: \B(\tau) \qquad \Gamma \vdash K : \K(\tau) }{\Gamma \vdash B \cdot K : \Sc }
\end{gather*}

\textsc{(Ket)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{K}}(\tau) : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \ket{t} : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash K : \K(\tau)}{\Gamma \vdash K^\dagger : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash K : \K(\tau)}{\Gamma \vdash a . K : \K(\tau)} \\
  \\
  \frac{\Gamma \vdash K_1 : \K(\tau) \qquad \Gamma \vdash K_2 : \K(\tau) }{\Gamma \vdash K_1 + K_2 : \K(\tau) }
  \qquad
  \frac{\Gamma \vdash O : \Op(\tau, \rho) \qquad \Gamma \vdash K : \K(\rho) }{\Gamma \vdash O \cdot K : \K(\tau) }
  \qquad
  \frac{\Gamma \vdash K_1 : \K(\tau) \qquad \Gamma \vdash K_2 : \K(\rho) }{\Gamma \vdash K_1 \otimes K_2 : \K(\tau \times \rho)}
\end{gather*}

\textsc{(Bra)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{B}}(\tau) : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \bra{t} : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash B : \B(\tau)}{\Gamma \vdash B^\dagger : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash B : \B(\tau)}{\Gamma \vdash a . B : \B(\tau)} \\
  \\
  \frac{\Gamma \vdash B_1 : \B(\tau) \qquad \Gamma \vdash B_2 : \B(\tau) }{\Gamma \vdash B_1 + B_2 : \B(\tau) }
  \qquad
  \frac{\Gamma \vdash B : \B(\tau) \qquad \Gamma \vdash O : \Op(\tau, \rho) }{\Gamma \vdash B \cdot O : \B(\rho) } 
  \qquad
  \frac{\Gamma \vdash B_1 : \B(\tau) \qquad \Gamma \vdash B_2 : \B(\rho) }{\Gamma \vdash B_1 \otimes B_2 : \B(\tau \times \rho)}
\end{gather*}

\textsc{(Operator)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{O}}(\tau, \rho) : \Op(\tau, \rho)}
  \qquad
  \frac{}{\Gamma \vdash \mathbf{1}_{\mathcal{O}}(\tau) : \Op(\tau, \tau)}
  \qquad
  \frac{\Gamma \vdash K : \K(\tau) \qquad \Gamma \vdash B : \B(\rho) }{\Gamma \vdash K \otimes B : \Op(\tau, \rho)}
  \qquad
  \frac{\Gamma \vdash O : \Op(\tau, \rho)}{\Gamma \vdash O^\dagger : \Op(\rho, \tau)} \\
  \\
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash O : \Op(\tau, \rho)}{\Gamma \vdash a . O : \Op(\tau, \rho)}
  \qquad
  \frac{\Gamma \vdash O_1 : \Op(\tau, \rho) \qquad \Gamma \vdash O_2 : \Op(\tau, \rho) }{\Gamma \vdash O_1 + O_2 : O(\tau, \rho) } \\
  \\
  \frac{\Gamma \vdash O_1 : \Op(\tau, \rho) \qquad \Gamma \vdash O_2 : \Op(\rho, \sigma) }{\Gamma \vdash O_1 \cdot O_2 : \Op(\tau, \sigma) }
  \qquad
  \frac{\Gamma \vdash O_1 : \Op(\tau_1, \rho_1) \qquad \Gamma \vdash O_2 : \Op(\tau_2, \rho_2) }{\Gamma \vdash O_1 \otimes O_2 : \Op(\tau_1 \times \tau_2, \rho_1 \times \rho_2)}
\end{gather*}

The typing rules come from the requirements in their interpretation in linear algebra. For example, the typing rule for inner product $B\cdot K$ claims that $B$ can $K$ should be bra and ket on the same type space, and the rules for additions require that only terms of the identical type can be summed up.



\subsection{Denotational Semantics}

Denotational semantics explain the formal language as a process of calculation, where each expression $e$ is finally mapped to a mathematical object written as $\sem{e}$.
A valuation of variables is also necessary for specifying the interpretation. The valuation $v$ maps all variables $x$ to their interpretation $v(x)$. The semantics of $e$ under valuation $v$ is written as $\sem{e}^v$, and we omit $v$ when it is obvious or assumed.

In our typed language, the denotational semantics should reflect the typing relation: types are interpreted as the domain sets, and the typing judgement should be interpreted as set-theoretical membership. This is the consistency requirement we will stick to in the below.

\begin{definition}[typing consistency]
  For any context $\Gamma$, expression $e$ and type $T$, if $\Gamma \vdash e : T$, then $\sem{e} \in \sem{T}$.
\end{definition}



In the following, we give the denotational semantics of core language $\textsf{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$. With the assumed context $\Gamma$ and valuation $v$, we only consider the well-typed expressions.
Also, we assume the semantical interpretation of module signatures $\Sigma_\mathcal{A}$ and $\Sigma_\mathcal{C}$, written as $\sem{e}_\mathcal{A}$ and $\sem{e}_\mathcal{C}$ respectively.


\begin{definition}[semantics of types]
  The semantics of basis types and Dirac types are defined as domain sets as follows:
  \begin{align*}
    & \text{(Basis Types)} && \begin{aligned}
      & \sem{A} \equiv \sem{A}_\mathcal{A},
      \qquad
      && \sem{\sigma_1 \times \sigma_2} \equiv \sem{\sigma_1} \times \sem{\sigma_2},
    \end{aligned} \\
    & \text{(Dirac Types)} && \begin{aligned}
      \sem{\Sc} \equiv \mathbb{C},
      \qquad
      \sem{\K(\sigma)} \equiv \mathcal{H}_{\sem{\sigma}}, 
      \qquad 
      \sem{\B(\sigma)} \equiv \mathcal{H}^*_{\sem{\sigma}},
      \qquad
      \sem{\Op(\sigma, \tau)} \equiv \textsf{Hom}(\mathcal{H}_\sem{\sigma}, \mathcal{H}_\sem{\tau}).
    \end{aligned}
  \end{align*}
\end{definition}

The atomic basis type $A$ is interpreted by $\Sigma_\mathcal{A}$, and the domain for the product type is the Cartesian product of component type semantics. The semantics for Dirac types are the complex field, Hilbert spaces, dual spaces, and homomorphisms on Hilbert spaces. Note that the type of spaces is dependent on the interpretation of their type notations.

\begin{definition}[semantics of basis]
  The domain of basis of type $\sigma$ is $\mathcal{D}_A = \sem{A}_\mathcal{A}$, $\mathcal{D}_{\sigma_1 \times \sigma_2} = \sem{\sigma_1} \times \sem{\sigma_2}$.
  The semantics of symbols in basis sort $\mathcal{E}$ are defined as follows:
  \begin{align*}
    & \text{(Atomic Basis)} && \sem{a} \equiv \sem{a}_\mathcal{A}, \\
    & \text{(Pairing)} &&
    \sem{(t_1, t_2)} \equiv (\sem{t_1}, \sem{t_2}), \\
    & \text{(First Projection)} &&
    \sem{\fst t} \equiv x_1 \qquad (\text{where } \sem{t} = (x_1, x_2)), \\
    & \text{(Second Projection)} &&
    \sem{\snd t} \equiv x_2 \qquad (\text{where } \sem{t} = (x_1, x_2))
  \end{align*}
\end{definition}

Because we only consider well-typed expressions, the functions are always well-defined.


% The semantics for Dirac notations are based on linear algebra, but some explanation on typing is necessary here. In mathematics we commonly distinguish linear spaces with different sizes, which corresponds to a more meticulous type system with basis set information. But our internal language only use sorts to represent vectors or operators, and the space itself is untyped. It is equivalent to say that we consider only one universal linear space. On the one hand, it can be understood as the direct sum of all different, typed linear spaces. On the other hand, it is the linear space with basis set $\mathcal{D}_\mathcal{E}$. From the isomorphism $\mathcal{H}_{A\cup B} \cong \mathcal{H}_A \oplus \mathcal{H}_B$, $\mathcal{H}_{A \times B} \cong \mathcal{H}_A \otimes \mathcal{H}_B$, we have
% $$
% \mathcal{H}_{\mathcal{D}_\mathcal{E}} = \mathcal{H}_{\mu X.(A\cup (X \times X))} \cong \mu V. \mathcal{H}_A \oplus (V \otimes V).
% $$


\begin{definition}[semantics of scalar]
  The domain of scalars $\mathcal{D}_\mathcal{S} = \mathbb{C}$ is the complex field.
  The semantics of the symbols are defined as follows:
  \begin{align*}
    & \text{(Complex Number)} &&
    \sem{C(\alpha)} \equiv \sem{\alpha}_\mathcal{C}, \\
    & \text{(Kronecker Delta)} &&
    \sem{\delta_{s, t}} \equiv \left\{
      \begin{array}{ll}
        1, & \text{where } \sem{s} = \sem{t}, \\
        0, & \text{where } \sem{s} \neq \sem{t}, 
      \end{array}
    \right. \\
    & \text{(Addition)} &&
    \sem{S_1 + S_2} \equiv \sem{S_1} + \sem{S_2}, \\
    & \text{(Multiplication)} &&
    \sem{S_1 \times S_2} \equiv \sem{S_1} \times \sem{S_2}, \\
    & \text{(Conjugate)} &&
    \sem{S^*} \equiv \sem{S}^*, \\
    & \text{(Inner Product)} &&
    \sem{B \cdot K} \equiv \langle \sem{B}^*, \sem{K} \rangle.
  \end{align*}
\end{definition}

Note that we use the symbol $C(\alpha)$ to introduce complex numbers as scalars.
Here notation $\langle \boldsymbol{u} , \boldsymbol{v} \rangle$ represent the inner proudct in Hilber spaces.
One interesting decision is the explanation for Dirac notation inner product $B \cdot K$. Another possibility is to let $\sem{B \cdot K} \equiv \langle \sem{B}, \sem{K} \rangle$, which may be closer to the inner product in linear algebra. The two explanations only differ in the convention sense. Our choice sets Dirac notation inner product linear on the bra $B$, which makes the rewriting rules of bra and ket more symmetric.


\begin{definition}[semantics of ket/bra]
  The domain for the semantics of ket and bra are $\mathcal{D}_{\mathcal{K}(\sigma)} = \mathcal{H}_{\sem{\sigma}}$ and $\mathcal{D}_{\mathcal{B}(\sigma)} = \mathcal{H}_{\sem{\sigma}}^*$ respectively.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Vector)} &&
    \sem{\mathbf{0}_\mathcal{K}(\sigma)} \equiv \mathbf{0} && \sem{\mathbf{0}_\mathcal{B}(\sigma)} \equiv \mathbf{0}^*, \\
    & \text{(Basis Vector)} &&
    \sem{\ket{t}} \equiv \mathbf{e}_t && \sem{\bra{t}} \equiv \mathbf{e}^t, \\
    & \text{(Adjoint)} &&
    \sem{B^\dagger} \equiv \sem{B}^* && \sem{K^\dagger} \equiv \sem{K}^*, \\
    & \text{(Scalar Multiplication)} &&
    \sem{S.K} \equiv \sem{S} \sem{K} && \sem{S.B} \equiv \sem{S} \sem{B}, \\
    & \text{(Addition)} &&
    \sem{K_1 + K_2} \equiv \sem{K_1} + \sem{K_2} && \sem{B_1 + B_2} \equiv \sem{B_1} + \sem{B_2}, \\
    & \text{(Linear Operator)} &&
    \sem{O \cdot K} \equiv \sem{O} \cdot \sem{K} && \sem{B \cdot O} \equiv (\sem{O}^\dagger \cdot \sem{B}^*)^*, \\
    & \text{(Tensor Product)} &&
    \sem{K_1 \otimes K_2} \equiv \sem{K_1} \otimes \sem{K_2} && \sem{B_1 \otimes B_2} \equiv \sem{B_1} \otimes \sem{B_2}.
  \end{align*}
\end{definition}



\begin{definition}[semantics of operator]
  The domain for the semantics of operators is the homomorphism $\mathcal{D}_{\mathcal{O}(\sigma, \tau)} = \textsf{Hom}(\mathcal{H}_\sem{\sigma}, \mathcal{H}_\sem{\tau})$.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Operator)} &&
    \sem{\mathbf{0}_\mathcal{O}(\sigma, \tau)} \equiv \mathbf{0}_{\textrm{op}}, \\
    & \text{(Identity Operator)} &&
    \sem{\mathbf{1}_\mathcal{O}(\sigma)} \equiv \mathbf{I}, \\
    & \text{(Outer Product)} &&
    \sem{K \otimes B} \equiv \sem{B} \otimes \sem{K} = \lambda \mathbf{v}. \langle \sem{B}^*, \mathbf{v}\rangle \sem{K}, \\
    & \text{(Adjoint)} &&
    \sem{O^\dagger} \equiv \sem{O}^\dagger, \\
    & \text{(Scalar Operator)} &&
    \sem{S.O} \equiv \sem{S} \sem{O}, \\
    & \text{(Addition)} &&
    \sem{O_1 + O_2} \equiv \sem{O_1}+\sem{O_2}, \\
    & \text{(Operator Multiplication)} &&
    \sem{O_1 \cdot O_2} \equiv \sem{O_1} \cdot \sem{O_2}, \\
    & \text{(Tensor Product)} &&
    \sem{O_1 \otimes O_2} \equiv \sem{O_1} \otimes \sem{O_2},
  \end{align*}
\end{definition}

\subsubsection*{Example}
