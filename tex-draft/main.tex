%%
%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,journal,bibtex,acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[manuscript, review, timestamp]{acmart}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{color}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{hhline}
\usepackage{bm}
\usepackage{braket}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\CIRCLE}%
\newcommand{\xmark}{\Circle}%
\newcommand{\hmark}{\LEFTcircle}%
\renewcommand{\matrix}[1]{\begin{bmatrix}#1\end{bmatrix}}
\usepackage{wasysym}
\usepackage{extarrows}
\usepackage{tikz}
\usetikzlibrary{positioning, shapes.geometric, graphs}
\usepackage{wrapfig}
\usepackage{dsfont}



%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\newcommand{\yx}[1]{\textit{\color{blue}[YX] : #1}}


\newcommand*{\Sc}{\mathcal{S}}
\newcommand*{\K}{\mathcal{K}}
\newcommand*{\B}{\mathcal{B}}
\newcommand*{\Op}{\mathcal{O}}

\newcommand*{\type}{\texttt{type}}

\newcommand*{\unit}{\texttt{unit}}
\newcommand*{\utt}{\texttt{tt}}
\newcommand*{\fst}{\texttt{fst }}
\newcommand*{\snd}{\texttt{snd }}
\newcommand*{\reduce}{\ \triangleright\ }
\newcommand*{\reducefrom}{\ \triangleleft\ }

\newcommand*{\zeroK}[1]{\mathbf{0}_{\mathcal{K}(#1)}}
\newcommand*{\zeroB}[1]{\mathbf{0}_{\mathcal{B}(#1)}}
\newcommand*{\zeroO}[1]{\mathbf{0}_{\mathcal{O}(#1)}}

\newcommand*{\sem}[1]{\llbracket #1 \rrbracket}

\newcommand*{\done}{\textcolor{blue}{\textbf{ [DONE] }}}
\newcommand*{\doing}{\textcolor{red}{\textbf{ [DOING] }}}
\newcommand*{\pending}{\textcolor{gray}{\textbf{ [PENDING] }}}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Decision Procedure for Dirac Notations}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle


Technical TODO list :
\begin{itemize}
    \item \done Modify the internal untyped TRS and introduce type information. Try to encode type inferrence as rewriting rules.
        \begin{itemize}
            \item $0, 1$ symbol: type decoration
            \item variables: specified by a context, encoded as rewriting rules $\sigma(x) \reduce ...$
            \item composed terms: specified by typing rules, encoded by $TypeEval(...) \reduce ...$
        \end{itemize}
        This should also resolve the problem of specifiying the ``type'' for the universal set.
    \item \pending update the tool implementation
    %\item Consider the typed formal system for Dirac notation $\mathcal{E}_{T}$ and its conversion to the untyped internal language .
    \item \done confluence (amend the original CiME2 code).
    \item \pending termination: the APRoVE tools failed to generate the proof automatically. Hard to find appropriate interpretation. 
    \item \done fix the semantics
    \item \done Check: can transpose be constructed? (ANS: yes, so we remove the syntax from the extended Dirac notation.)
    \item \pending soundness (typing rule + rewriting rule)
    \item \pending completeness. 1. typed dirac (semantics equal); 2. axiom of typed dirac, i.e., equational axioms, prove the equational theory is relatively complete w.r.t. semantics equality??? ; 3. rewriting system is complete w.r.t. equational axioms (pointing out the importance and difficulty of TRS w.r.t. the equational theories)
    \item \pending Coq formalization of soundness (extended with big op) and completeness (core language)
    \item \pending explain the techniques applied in the implementation of extended langauge
        \begin{itemize}
            \item (SUM-SWAP) equation
            \item alpha-equivalence of sum index: using AC-unification
            \item entry-expansion techniques to improve automation
        \end{itemize}
    \item \pending a user language that will be compiled to the internal one (benefit: avoid different symbols for disambugating )
    \item \pending add labelled Dirac notation
    \item \pending examples show the efficiency, add a long example
    \item \pending examples from other fields of quantum computing: circuit equivalence checking and program simulation
\end{itemize}

\clearpage
\tableofcontents

\clearpage

\section{Introduction}
Storyline:
\begin{enumerate}
    \item Formal method is an important topic in quantum computing with lots of applications.
    \item Automation is a central topic in logic and formal methods. It reduces human efforts, enables reasoning in large scales, and is critical to the performance and usability of tools.
    \item The current results in formalizing quantum computing are divided into two types: automated tools targeting at special cases (QBricks, QEC, EasyPQC), and expressive foundational formalizations (CoqQ). The automation level is still low for general formalization.
    \item Our work explores the general automation of quantum formal methods.
    \item Dirac notation is a good starting point for generality.
    \item For automation, term rewriting system is a promising method. It is explainable with theoretical guarantees.
\end{enumerate}


(By GPT4:)

Formal methods constitute a crucial aspect of quantum computing, offering a robust framework for verifying and validating quantum algorithms and systems. These methods have found applications in diverse areas, from cryptography to error correction, highlighting their essential role in advancing the field. Within formal methods, automation emerges as a pivotal topic. Automated tools significantly reduce human effort, enable reasoning at larger scales, and enhance the performance of verification tools, thereby facilitating more efficient and accurate formalization processes.

Current advancements in formalizing quantum computing can be broadly categorized into two groups: specialized automated tools and foundational formalizations. Examples of automated tools targeting specific scenarios include QBricks, QEC, and EasyPQC, which are designed for particular use cases but lack general applicability. On the other hand, expressive foundational formalizations such as CoqQ offer a more comprehensive framework but exhibit limited automation capabilities.

Despite these developments, the level of automation in general formalizations remains insufficient. Addressing this gap, our research focuses on advancing the automation of quantum formal methods, thereby extending their applicability and utility. We identify Dirac notation as an ideal starting point due to its generality and widespread use in quantum mechanics.

To achieve automation, we propose employing a term rewriting system, which shows promise in systematically handling complex transformations and ensuring correctness. Our work aims to develop a robust framework for the automated formalization of quantum computing, leveraging the strengths of Dirac notation and term rewriting systems to achieve higher levels of automation and efficiency in this critical field.


Related works.

Big Operator.\cite{Bertot2008}

Lineal.\cite{Arrighi2017}

CoqQ.\cite{Zhou2022}

Decidability of Linear algebra.\cite{Solovay2012}

CiME.\cite{Contejean2011}

Term Rewriting. \cite{Baader1998}

Termination techniques. \cite{Arts2000} \cite{Giesl2002} \cite{Giesl2006}

Quantum. \cite{Nielsen2010}

Wolfram. \cite{WolframLanguage}

\vspace{2em}

Our contribution:
\begin{itemize}
  \item \textbf{The first theory for the decision procedure of Dirac notations.} 
  We rephrased the formal language of Dirac notation and developed its decision procedure. The language is separated into the core language of basic symbols and the extension with big operator sum. We proved the soundness and relative completeness (?) of the decision procedure, which is formally verified in \texttt{Coq}. Moreover, the core language is a pure term rewriting system with local confluence proved.
  \item \textbf{An efficient and powerful tool implementation.}
  We provide the implementation of the language and decision procedure in Mathematica. We encoded a broad scope of practical examples, and all the encoded problems can be automatically checked efficiently.
\end{itemize}



\section{Motivating Example}

When the state of a many-body quantum system cannot be represented by the direct product its component states, we say it is in an entangled state. Entangled quantum states are important resources for quantum computing and quantum information, as they demonstrate the nonlocal correlation among the subsystems. 
Here is such a well-known property among others: for a maximally entangled two-body system $\ket{\Phi}$, if we apply operation $M$ on one subsystem, the result state is the same as applying $M^\top$ on the other entangled subsystem. 
A subsequent corollary is, if we apply operations $M_1$ and $M_2$ respectively on two subsystems of a maximally entangled state, the overlap of the result state on the origin will be the same as the trace of operation $M_1^\top M_2$ on only one subsystem. In the following, we take the corollary as an example, rephrase it in the formal language called \textit{Dirac notation},
% It serves as a good motivating example showing the key techniques and difficulties, and 
and show how our theory and tool helps deciding the statement.

\begin{example}
  Let $\ket{\Phi} = \sum_{i \in V}\ket{i, i}$ be the maximally entangled state on Hilbert space $\mathcal{H}_V\otimes\mathcal{H}_V$. Then for all operators $M_1, M_2 \in \mathrm{Hom}(\mathcal{H}_V, \mathcal{H}_V)$,
  $$
  \bra{\Phi} (I \otimes M_2) (M_1 \otimes I) \ket{\Phi} = \mathrm{tr}(M_2^\top M_1).
  $$
\end{example}

Dirac notation is widely used to describe quantum states and operations. It uses the braket notation to express linear algebra concisely, while the latter is the foundational language for quantum.
In Dirac notation, (pure) states are denoted as \textit{kets}, representing vectors in the Hilbert spaces. The state $\ket{\Phi}$ is such an example. And because the entangled state consists of two subsystems $\mathcal{H}_V$, the overall state space is the tensor product $\mathcal{H}_V \otimes \mathcal{H}_V$ of subsystem spaces.
Therefore, we have $\ket{\Psi} = \sum_{i\in V} \ket{i} \otimes \ket{i}$. Here $i$ is summed over all orthogonal basis in $V$, corresponding to the \textit{maximal} entanglement. Because of the natural isomorphism of tensor product spaces, the state $\ket{\Phi}$ can also be written as $\sum_{i \in V} \ket{i, i}$. 
Further on, operations on states are linear operators in the corresponding spaces. Here $M_1 \otimes I$ means the operation $M_1$ is applied on the first subsystem, with an identical operation $I$ applied on the second one. The notation $I \otimes M_2$ is interpreted similarly. The successive multiplication $(I\otimes M_1)(M_2 \otimes I)\ket{\Phi}$ means the sequential application of two operations on the entangled state.
Finally, we take the inner product of two states $\ket{u}$ and $\ket{v}$. To express the inner product operation in an associative way, the \textit{dual space} $\mathcal{H}_V^*$ is introduced, whose elements are linear functionals, denoted as \textit{bras} like $\bra{v}$. The left hand side of the equation computes the inner product of the post-operation state with the original maximally entangled one. The right hand side is the trace of associated operation $M_2^\top M_1$.

Here is a step-wise proof of the equivalence by human.
\begin{align}
    & \ \bra{\Phi} (I \otimes M_2) (M_1 \otimes I) \ket{\Phi} \notag \\
    \text{\{ expand $\ket{\Phi}$, absorbing identity operators \}} & = \left(\sum_{i\in V} \bra{i} \otimes \bra{i}\right) M_1 \otimes M_2 \left(\sum_{i \in V} \ket{i} \otimes \ket{i}\right) \\
    \text{\{ push terms into the big operator \}} & = \sum_{i\in V} \sum_{j \in V} \left( \bra{i} \otimes \bra{i} \cdot  M_1 \otimes M_2 \cdot \ket{j} \otimes \ket{j} \right) \\
    \text{\{ rearrange operations on two subsystems \}} & = \sum_{i\in V} \sum_{j \in V} \bra{i} M_1 \ket{j} \times \bra{i} M_2 \ket{j}
\end{align}

\begin{align}
  & \ \mathrm{tr}(M_2^\top M_1) \notag \\
  \text{\{ expand trace definition \}} & = \sum_{k \in V} \bra{k} M_2^\top M_1 \ket{k} \\
  \text{\{ insert the identity operator \}} & = \sum_{k \in V} \bra{k} M_2^\top (\sum_{l \in V} \ket{l}\bra{l}) M_1 \ket{k} \\
  \text{\{ push terms into the big operator \}} & = \sum_{k \in V} \sum_{l \in V} \bra{k} M_2^\top \ket{l}\bra{l} M_1 \ket{k} \\
  \text{\{ simplify the transpose operator \}} & = \sum_{k \in V} \sum_{l \in V} \bra{l} M_2 \ket{k} \times \bra{l} M_1 \ket{k}
\end{align}

The human proof proceeds by rewriting both sides of the equation according to the laws of linear algebra. 
However, manual proofs take much human effort, and can be error-prone in large-scale examples. 
Therefore, a natural goal is to design the formal verification, or even the decision procedure, based on Dirac notations.

The example illustrates the possibility and challenge for automated deduction of Dirac notations.
On the one hand, some of the rewritings can be concluded as axioms, and the rewritings appear to be simplifying the terms. For example, $(I \otimes M_2)(M_1 \otimes I) = M_1 \otimes M_2$ in Eq.(1), and $\bra{k}M_2^\top\ket{l} = \bra{l}M_2\ket{k}$ in Eq.(7). On the other hand, some techniques require careful scheduling (e.g., rearranging $\bra{i}\otimes\bra{i}\cdot M_1 \otimes M_2 \cdot \ket{j} \otimes \ket{j}$ in Eq.(3)), and some seems to be heuristics (e.g., inserting the identity operator $\sum_{l \in V}\ket{l}\bra{l}$ in Eq.(5)).

Our work resolves the decision problem of Dirac notations by designing a \textit{term rewriting system} (referred as TRS in the following). The general idea is to view Dirac notation as a universal algebra, summerize the equational axioms and specify the direction of rewriting. The proof by such a TRS can be explained and checked, and we can prove theoretical properties for the system, such as termination, confluence and even completeness.

\subsection{Quantum, Linear Algebra and Dirac Notation in a Nutshell}
\begin{itemize}
  \item Axioms of Linear Algebra

  \item Tensor Product Extension

  \item Dirac Notation interpretation, ambiguity and associativity
\end{itemize}

\subsection{Term Rewriting}

\begin{itemize}
  \item Universal Algebra

  \item TRS and equational theory
  
  \item Important properties: confluence and termination
  
  \item Variant: AC rewriting
  
  \item Modularity
\end{itemize}

When the whole formal system becomes large ane complicated, we can slice it into different layers. From such a point of view, different aspects of the system, i.e. language syntax, semantical interpretation, rewriting rules and proofs, are built in the bottom-up style. For example, in our work there will be two foundational systems for complex numbers and atomic basis, the core and extended Dirac notations are then constructed subsequently. Such a layered system provides flexibility and generality w.r.t. the basic modules. Also, properties can be developed by composing the corresponding proofs from the submodules. In our work, the local confluence of the core Dirac notation is proved by such modularity utilizing the avatar lemma, which is discussed in Sec.\ref{sec: conf-modular}.


\section{Dirac Notation Core Language}

One difficulty of formalizing Dirac notations and designing the rewriting rules is the overloading of operators. This feature makes Dirac notations flexible and easy to use, but also introduced ambiguity into the syntax. In the core langauge, we want to prove some desired properties of the term rewriting system, such as congruence and soundness, and we have to rely on existing theories and tools. Therefore we choose the untyped universal algebra with AC symbols.






\subsection{Language Syntax}

\begin{definition} [atomic basis signature]
  The \textbf{atomic basis signature} $\Sigma_\mathcal{A}$ is a  typed finite language.
\end{definition}

Because we consider the tensor product structure, larger Hilbert spaces can be composed by the atomic ones, like the qubit Hilbert space. The atomic basis here characterize the basis of the atomic Hilbert spaces.
We limit the basis signature to finite languages to avoid problems of infinite dimensions.

\begin{definition} [complex number signature]
  The \textbf{complex number signature} $\Sigma_\mathcal{C}$ contains at least constant symbols $0, 1$, a unary symbol $*$ and binary symbols $+, \times$.
\end{definition}

Following the idea of the avatar lemma, the two signatures $\Sigma_\mathcal{A}$ and $\Sigma_\mathcal{C}$ characterize the language for atomic basis and complex numbers. 
The symbols for complex numbers are zero, one, conjugate, addition and multiplication respectively. Compared the avatar language in the Lineal paper\cite{Arrighi2017}, it adds the conjugate symbol since we need to deal with conjugate and inner product.
These symbols are only the least requirements as interfaces, and the real language to instantiate can contain more details. For example, the basis can contain symbols $0$ and $1$ for qubit spaces, and the complex numbers can still have exponential functions $e^x$ or square roots $\sqrt{x}$.


\begin{definition}[core language of Dirac Notation]
  The \textbf{core language of Dirac Notation}, denoted as $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, is a many-sorted language with dependent types, defined as follows.
  \begin{align*}
    & \textbf{Types} && \textrm{(basis types)} && \sigma ::= A\ |\ \sigma \times \sigma, \\
    & && \textrm{(Dirac types)} && T ::= \Sc\ |\ \K(\sigma)\ |\ \B(\sigma)\ |\ \Op(\sigma, \sigma), \\
    \\
    & \textbf{Terms} && \textrm{(complex number)} && \alpha \in \Sigma_\mathcal{C}, \\
    & && \textrm{(basis)} && t ::= x\ |\ a\ |\ (t, t)\ |\ \fst t\ |\ \snd t, \\
    & && \textrm{(scalar)} && S ::= x\ |\ C(\alpha)\ |\ \delta_{t, t}\ |\ S + S\ |\ S \times S\ |\ S^*\ |\ B \cdot K, \\
    & && \textrm{(ket)} && K ::= x\ |\ \mathbf{0}_\mathcal{K}(\sigma)\ |\ \ket{t}\ |\ B^\dagger\ |\ S.K\ |\ K + K\ |\ O \cdot K\ |\ K \otimes K, \\
    & && \textrm{(bra)} && B ::= x\ |\ \mathbf{0}_\mathcal{B}(\sigma)\ |\ \bra{t}\ |\ K^\dagger\ |\ S.B\ |\ B + B\ |\ B \cdot O\ |\ B \otimes B, \\
    & && \textrm{(operator)} && O ::= x\ |\ \mathbf{0}_\mathcal{O}(\sigma, \sigma)\ |\ \mathbf{1}_\mathcal{O}(\sigma)\ |\ K \otimes B\ |\ O^\dagger\ |\ S.O\ |\ O + O\ |\ O \cdot O\ |\ O \otimes O.
  \end{align*}
  Here we use $x$ to represent variables, $a$ to represent atomic basis in $\Sigma_\mathcal{A}$, lower case letters like $s, t$ to represent basis from $\mathcal{E}$, and Greek letters like $\alpha$ to represent complex number terms from $\Sigma_\mathcal{C}$. We use letters $S$, $K$, $B$, $O$ and their variants to represent terms from the scalar, ket, bra and operator sorts repsectively.
\end{definition}

\subsection{Context and Typing}

\begin{definition}[context]
  A \textbf{typing assumption} is written as $x : X$, meaning that variable $x$ is of type $X$. A \textbf{context} $\Gamma$ is an ordered list of typing assumptions. We write $x : X \in \Gamma$ if the typing assumption is contained in context $\Gamma$, and $x \in \Gamma$ if there exists a typing assumption of $x$ contained in $\Gamma$.
\end{definition}


We define simultaneously two judgement. One is $\mathcal{WF}(\Gamma)$, meaning that a context is \textbf{well-formed}. And the second one is a \textbf{typing judgement} written as $\Gamma \vdash e : X$, indicating that $e$ is an expression of type $X$ in context $\Gamma$.
We say the term $e$ is a \textbf{well-typed} term in context $\Gamma$ if $\Gamma \vdash e : X$ is a typing judgement for some $X$.

Well-formed contexts can be constructed starting with an empty context, and continuously appending unique variables with proved typing judgements.

\textsc{(Context)}
\begin{gather*}
  \frac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}
\end{gather*}

\textsc{(Basis)}
\begin{gather*}
  \frac{a \text{ is an atomic basis of } A}{\Gamma \vdash a : A}
  \qquad
  \frac{\Gamma \vdash s : \tau \qquad \Gamma \vdash t : \sigma}{\Gamma \vdash (s, t) :  \tau \times \sigma }
  \qquad
  \frac{\Gamma \vdash s : \sigma \times \tau }{\Gamma \vdash \fst s : \sigma}
  \qquad
  \frac{\Gamma \vdash s : \sigma \times \tau }{\Gamma \vdash \snd s : \tau}
\end{gather*}

\textsc{(Complex Scalar)}
\begin{gather*}
  \frac{}{\Gamma \vdash C(\alpha) : \Sc}
  \qquad
  \frac{\Gamma \vdash s : \sigma \qquad \Gamma \vdash t : \sigma}{\Gamma \vdash \delta_{s, t} : \Sc} \\
  \\
  \frac{\Gamma \vdash S_1 : \Sc \qquad \Gamma \vdash S_2 : \Sc }{\Gamma \vdash S_1 + S_2 : \Sc }
  \qquad
  \frac{\Gamma \vdash S_1 : \Sc \qquad \Gamma \vdash S_2 : \Sc}{\Gamma \vdash S_1 \times S_2 : \Sc}
  \qquad
  \frac{\Gamma \vdash S : \Sc}{\Gamma \vdash S^* : \Sc}
  \qquad
  \frac{\Gamma \vdash B: \B(\tau) \qquad \Gamma \vdash K : \K(\tau) }{\Gamma \vdash B \cdot K : \Sc }
\end{gather*}

\textsc{(Ket)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{K}}(\tau) : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \ket{t} : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash K : \K(\tau)}{\Gamma \vdash K^\dagger : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash K : \K(\tau)}{\Gamma \vdash a . K : \K(\tau)} \\
  \\
  \frac{\Gamma \vdash K_1 : \K(\tau) \qquad \Gamma \vdash K_2 : \K(\tau) }{\Gamma \vdash K_1 + K_2 : \K(\tau) }
  \qquad
  \frac{\Gamma \vdash O : \Op(\tau, \rho) \qquad \Gamma \vdash K : \K(\rho) }{\Gamma \vdash O \cdot K : \K(\tau) }
  \qquad
  \frac{\Gamma \vdash K_1 : \K(\tau) \qquad \Gamma \vdash K_2 : \K(\rho) }{\Gamma \vdash K_1 \otimes K_2 : \K(\tau \times \rho)}
\end{gather*}

\textsc{(Bra)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{B}}(\tau) : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \bra{t} : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash B : \B(\tau)}{\Gamma \vdash B^\dagger : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash B : \B(\tau)}{\Gamma \vdash a . B : \B(\tau)} \\
  \\
  \frac{\Gamma \vdash B_1 : \B(\tau) \qquad \Gamma \vdash B_2 : \B(\tau) }{\Gamma \vdash B_1 + B_2 : \B(\tau) }
  \qquad
  \frac{\Gamma \vdash B : \B(\tau) \qquad \Gamma \vdash O : \Op(\tau, \rho) }{\Gamma \vdash B \cdot O : \B(\rho) } 
  \qquad
  \frac{\Gamma \vdash B_1 : \B(\tau) \qquad \Gamma \vdash B_2 : \B(\rho) }{\Gamma \vdash B_1 \otimes B_2 : \B(\tau \times \rho)}
\end{gather*}

\textsc{(Operator)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{O}}(\tau, \rho) : \Op(\tau, \rho)}
  \qquad
  \frac{}{\Gamma \vdash \mathbf{1}_{\mathcal{O}}(\tau) : \Op(\tau, \tau)}
  \qquad
  \frac{\Gamma \vdash K : \K(\tau) \qquad \Gamma \vdash B : \B(\rho) }{\Gamma \vdash K \otimes B : \Op(\tau, \rho)}
  \qquad
  \frac{\Gamma \vdash O : \Op(\tau, \rho)}{\Gamma \vdash O^\dagger : \Op(\rho, \tau)} \\
  \\
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash O : \Op(\tau, \rho)}{\Gamma \vdash a . O : \Op(\tau, \rho)}
  \qquad
  \frac{\Gamma \vdash O_1 : \Op(\tau, \rho) \qquad \Gamma \vdash O_2 : \Op(\tau, \rho) }{\Gamma \vdash O_1 + O_2 : O(\tau, \rho) } \\
  \\
  \frac{\Gamma \vdash O_1 : \Op(\tau, \rho) \qquad \Gamma \vdash O_2 : \Op(\rho, \sigma) }{\Gamma \vdash O_1 \cdot O_2 : \Op(\tau, \sigma) }
  \qquad
  \frac{\Gamma \vdash O_1 : \Op(\tau_1, \rho_1) \qquad \Gamma \vdash O_2 : \Op(\tau_2, \rho_2) }{\Gamma \vdash O_1 \otimes O_2 : \Op(\tau_1 \times \tau_2, \rho_1 \times \rho_2)}
\end{gather*}


We make the modularity explicit by separating the complex number sort $\mathcal{C}$ from the scalar sort $\mathcal{S}$ in Dirac notations. It is necessary because the scalar language is defined by mutual induction with ket, bra and basis, which does not appear in standard language of complex. This also indicates the joint position in the term rewriting system: the rules for complex numbers can vary in different cases of $\sum_\mathcal{C}$, and our work on Dirac notations is to design the general rewriting rules involving inner products and Kronecker-Delta expressions. Separating the two languages allows us to apply the avatar lemma in theoretical analysis. From the implementation level, it means we can directly utilize different solvers that focus on complex numbers, and extend the language of complex numbers easily by modifying $\sum_\mathcal{C}$.

The same discussion applies for the language of basis. The atomic basis describes every individual subsystem in the physical level. The pairing and projections are for basis in Hilbert space with tensor products, which lie in the logic level.

We can consider possible candidates for instantiating $\Sigma_\mathcal{C}$, which touches the decidability problem of reals. Beyond the weakest one, the avatar $\{0, 1, *, +, \times\}$ itself \yx{any theorems on this one?}, we can also try to add symbols pervasively used in quantum, such as exponential functions, trigonometric functions and square/square root.

The choice of the atomic basis language $\Sigma_\mathcal{A}$ has large freedom and can be suited to different scenarios. Besides introducing constant symbols (e.g., $0$ and $1$ basis), richer language with operations on basis terms are also possible. 


Although we use the same characters in different sorts ($B \cdot K$ and $O \cdot K$, for example), they are actually different symbols and can be easily distinguished from the context. This is also reflected in the \texttt{CiME2} script. 

The language is intended to be used in the multi-sorted manner, but in the proof of confluence property, we check the unsorted version. The unsorted version simply removes all sort constraints, and its confluence is equivalent to that of the multi-sorted version, which is the persistancy proved in \cite{Aoto1997}.



\subsection{Denotational Semantics}

Denotational semantics explain the formal language as a process of calculation, where each expression $e$ is finally mapped to a mathematical object written as $\sem{e}$.
Because our language have a hierechy of types, the denotational semantics should reflect the typing relation: types are interpreted as the domain sets, and the typing judgement should be interpreted as set-theoretical membership. This is the consistency requirement we will stick to in the below.

A valuation is also necessary for specifying the interpretation. The valuation $v$ maps all variables $x$ to their interpretation $v(x)$. The semantics of $e$ under valuation $v$ is written as $\sem{e}^v$, and we omit $v$ when it is obvious or assumed.

In the following, we give the denotational semantics of core language $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$. We assume a well-formed context $\Gamma$ and a valid valuation $v$, and only consider the well-typed expressions.

\begin{definition}
  The set of all domains for the semantical interpretation of types in $\Sigma_{\mathcal{A}}$ is written as $\mathcal{A}$.
\end{definition}

Basis types and Dirac types as terms have their types in kinds. The semantics of types are defined as domains, and should be contained in the semantics of kinds. Therefore, kinds are interpreted as sets of domains. \texttt{Atom} is interpreted as the set $\mathcal{A}$ of all different domains from the atomic basis language, and the kind $P_1 * P_2$ contains all different Cartesian products from $P_1$ and $P_2$. The semantics of \texttt{Ket}, \texttt{Bra} and \texttt{Operator} are defined as the set of all Hilbert spaces, Dual spaces and Homomorphisms, respectively.


\begin{definition}[semantics of types]
  The semantics of basis types are defined as domain sets as follows:
  \begin{align*}
    & \text{(Basis Types)} && \begin{aligned}
      & \sem{A} \equiv \sem{A}_\mathcal{A},
      \qquad
      && \sem{\sigma_1 \times \sigma_2} \equiv \sem{\sigma_1} \times \sem{\sigma_2},
    \end{aligned} \\
    & \text{(Dirac Types)} && \begin{aligned}
      \sem{\Sc} \equiv \mathbb{C},
      \qquad
      \sem{\K(\sigma)} \equiv \mathcal{H}_{\sem{\sigma}}, 
      \qquad 
      \sem{\B(\sigma)} \equiv \mathcal{H}^*_{\sem{\sigma}},
      \qquad
      \sem{\Op(\sigma, \tau)} \equiv \textsf{Hom}(\sem{\sigma}, \sem{\tau}).
    \end{aligned}
  \end{align*}
\end{definition}

\begin{definition}[semantics of basis]
  For atomic basis $\Sigma_\mathcal{A}$ with domain $A$, the domain of basis $\mathcal{E}$ is the binary tree algebra over $A$, which is defined as 
  $
  \mathcal{D}_\mathcal{E} = \mu X.(A \cup (X \times X)),
  $
  the smallest set that contains $A$ and is closed under Cartesian product.

  The semantics of symbols in $\mathcal{E}$ are defined as follows:
  \begin{align*}
    & \text{(Atomic Basis)} && \sem{a} \equiv \sem{a}_\mathcal{A}, \\
    & \text{(Pairing)} &&
    \sem{(t_1, t_2)} \equiv (\sem{t_1}, \sem{t_2}), \\
    & \text{(First Projection)} &&
    \sem{\fst t} \equiv x_1 \qquad (\text{where } \sem{t} = (x_1, x_2)), \\
    & \text{(Second Projection)} &&
    \sem{\snd t} \equiv x_2 \qquad (\text{where } \sem{t} = (x_1, x_2))
  \end{align*}
\end{definition}


% The semantics for Dirac notations are based on linear algebra, but some explanation on typing is necessary here. In mathematics we commonly distinguish linear spaces with different sizes, which corresponds to a more meticulous type system with basis set information. But our internal language only use sorts to represent vectors or operators, and the space itself is untyped. It is equivalent to say that we consider only one universal linear space. On the one hand, it can be understood as the direct sum of all different, typed linear spaces. On the other hand, it is the linear space with basis set $\mathcal{D}_\mathcal{E}$. From the isomorphism $\mathcal{H}_{A\cup B} \cong \mathcal{H}_A \oplus \mathcal{H}_B$, $\mathcal{H}_{A \times B} \cong \mathcal{H}_A \otimes \mathcal{H}_B$, we have
% $$
% \mathcal{H}_{\mathcal{D}_\mathcal{E}} = \mathcal{H}_{\mu X.(A\cup (X \times X))} \cong \mu V. \mathcal{H}_A \oplus (V \otimes V).
% $$


\begin{definition}[semantics of scalar]
  The domain of scalars $\mathcal{D}_\mathcal{S} = \mathbb{C}$ is the complex field.
  The semantics of the symbols are defined as follows:
  \begin{align*}
    & \text{(Complex Number)} &&
    \sem{C(\alpha)} \equiv \sem{\alpha}_\mathcal{C}, \\
    & \text{(Kronecker Delta)} &&
    \sem{\delta_{s, t}} \equiv \left\{
      \begin{array}{ll}
        1, & \text{where } \sem{s} = \sem{t}, \\
        0, & \text{where } \sem{s} \neq \sem{t}, 
      \end{array}
    \right. \\
    & \text{(Addition)} &&
    \sem{S_1 + S_2} \equiv \sem{S_1} + \sem{S_2}, \\
    & \text{(Multiplication)} &&
    \sem{S_1 \times S_2} \equiv \sem{S_1} \times \sem{S_2}, \\
    & \text{(Conjugate)} &&
    \sem{S^*} \equiv \sem{S}^*, \\
    & \text{(Inner Product)} &&
    \sem{B \cdot K} \equiv \langle \sem{B}^*, \sem{K} \rangle.
  \end{align*}
\end{definition}

Note that we use the symbol $C(\alpha)$ to introduce complex numbers as scalars.
One interesting decision is the explanation for Dirac notation inner product $B \cdot K$. An other possibility is to let $\sem{B \cdot K} \equiv \langle \sem{B}, \sem{K} \rangle$, which may be closer to the inner product in linear algebra. The two explanations only differ in the convention sense. Our choice sets Dirac notation inner product linear on the bra $B$, which makes the rewriting rules of bra and ket more symmetric. Also, it enables easier equivalence checking for transpose in the extended language.


\begin{definition}[semantics of ket/bra]
  The domain for the semantics of ket and bra are $\mathcal{H}_{\mathcal{D}_\mathcal{E}}$ and $\mathcal{H}_{\mathcal{D}_\mathcal{E}}^*$ respectively.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Vector)} &&
    \sem{\mathbf{0}_\mathcal{K}(\sigma)} \equiv \mathbf{0} && \sem{\mathbf{0}_\mathcal{B}(\sigma)} \equiv \mathbf{0}^*, \\
    & \text{(Basis Vector)} &&
    \sem{\ket{t}} \equiv \mathbf{e}_t && \sem{\bra{t}} \equiv \mathbf{e}^t, \\
    & \text{(Adjoint)} &&
    \sem{B^\dagger} \equiv \sem{B}^* && \sem{K^\dagger} \equiv \sem{K}^*, \\
    & \text{(Scalar Multiplication)} &&
    \sem{S.K} \equiv \sem{S} \sem{K} && \sem{S.B} \equiv \sem{S} \sem{B}, \\
    & \text{(Addition)} &&
    \sem{K_1 + K_2} \equiv \sem{K_1} + \sem{K_2} && \sem{B_1 + B_2} \equiv \sem{B_1} + \sem{B_2}, \\
    & \text{(Linear Operator)} &&
    \sem{O \cdot K} \equiv \sem{O} \cdot \sem{K} && \sem{B \cdot O} \equiv (\sem{O}^\dagger \cdot \sem{B}^*)^*, \\
    & \text{(Tensor Product)} &&
    \sem{K_1 \otimes K_2} \equiv \sem{K_1} \otimes \sem{K_2} && \sem{B_1 \otimes B_2} \equiv \sem{B_1} \otimes \sem{B_2}.
  \end{align*}
\end{definition}



\begin{definition}[semantics of operator]
  The domain for the semantics of operators is the homomorphism $\mathcal{D}_\mathcal{O} = \textrm{Hom}(\mathcal{H}_{\mathcal{D}_\mathcal{E}}, \mathcal{H}_{\mathcal{D}_\mathcal{E}})$.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Operator)} &&
    \sem{\mathbf{0}_\mathcal{O}(\sigma, \tau)} \equiv \mathbf{0}_{\textrm{op}}, \\
    & \text{(Identity Operator)} &&
    \sem{\mathbf{1}_\mathcal{O}(\sigma)} \equiv \mathbf{I}, \\
    & \text{(Outer Product)} &&
    \sem{K \otimes B} \equiv \lambda \mathbf{v}. \langle \sem{B}^*, \mathbf{v}\rangle \sem{K}, \\
    & \text{(Adjoint)} &&
    \sem{O^\dagger} \equiv \sem{O}^\dagger, \\
    & \text{(Scalar Operator)} &&
    \sem{S.O} \equiv \sem{S} \sem{O}, \\
    & \text{(Addition)} &&
    \sem{O_1 + O_2} \equiv \sem{O_1}+\sem{O_2}, \\
    & \text{(Operator Multiplication)} &&
    \sem{O_1 \cdot O_2} \equiv \sem{O_1} \cdot \sem{O_2}, \\
    & \text{(Tensor Product)} &&
    \sem{O_1 \otimes O_2} \equiv \sem{O_1} \otimes \sem{O_2},
  \end{align*}
\end{definition}

\subsubsection*{Example}



\subsection{Axiomatic Semantics}

To further study the properties of this language, we try to axiomatize the equivalence in the denotational semantics as a proof system with equations, which results in the axiomatic semantics $AX$. The formal proof system should be sound in the sense that the axioms as equations hold in the denotational semantics. Meanwhile, the equivalence defined by axioms should be as comprehensive as possible compared to that in the denotational semantics, enabling it to cover most of the equivalence relations in which we are interested.

Although the formal system implies the equivalence of Dirac notations we desire, it does not point out how to correctly apply the axioms. Therefore, we still need to design an algorithm to decide the equivalence. A classical approach is to assign directions to the application of equations, resulting in the term rewriting system in the next section.

The axiomatic semantics then serve as the criterion for the proof of soundness and completeness of the rewriting algorithm. But before that, let's fix the bridge first.
The symbol $\vdash_{AX}$ is omitted for the axioms.

\begin{definition}[axiomatic semantics of complex numbers]
  \begin{gather*}
    0 + \alpha = \alpha
    \qquad
    \alpha + \beta = \beta + \alpha
    \qquad
    (\alpha + \beta) + \gamma = \alpha + (\beta + \gamma) \\
    0 \times \alpha = 0
    \qquad
    1 \times \alpha = \alpha
    \qquad
    \alpha \times \beta = \beta \times \alpha \\
    (\alpha \times \beta) \times \gamma = \alpha \times (\beta \times \gamma) \qquad
    \alpha \times (\beta + \gamma) = \alpha \times \beta + \alpha \times \gamma \\
    (\alpha + \beta)^* = \alpha^* + \beta^*
    \qquad
    (\alpha \times \beta)^* = \alpha^* \times \beta^*
    \qquad
    (\alpha^*)^* = \alpha
  \end{gather*}
\end{definition}
Compared to the ``scalar rewrite system'' in the Lineal paper\cite{Arrighi2017}, here we have three more axioms for the conjugate symbol.


\begin{definition}[BASIS]
  \begin{gather*}
      \fst (s, t) = s
      \qquad
      \snd (s, t) = t
  \end{gather*}
\end{definition}

Although in the denotational semantics we have to consider the case where projections are applied on atomic basis, we can omit the two rules 
$
\fst a = a,
\snd a = a
$
in the axiomatic semantics, as the extra definition in the denotational semantics are only necessary for technical reasons.



Many axioms have the similar form for scalars, bra, ket and operators. In the following we express them in a unified style and use the letter $D$ to represent some Dirac notation term of the appropriate sort.

\begin{definition}[UNI-LINEAR]
  \begin{gather*}
    D + \mathbf{0} = D
    \qquad
    D_1 + D_2 = D_2 + D_1
    \qquad
    (D_1 + D_2) + D_3 = D_1 + (D_2 + D_3) \\
    C(0).D = \mathbf{0}
    \qquad
    C(1).D = D
    \qquad
    S.\mathbf{0} = \mathbf{0} \\
    S_1.(S_2.D) = (S_1 \times S_2).D
    \qquad
    S.(D_1 + D_2) = S.D_1 + S.D_2
  \end{gather*}
\end{definition}

\begin{definition}[UNI-ADJOINT]
  \begin{gather*}
    \textbf{0}^\dagger = \textbf{0}
    \qquad
    \mathbf{1}_\mathcal{O}^\dagger = \mathbf{1}_\mathcal{O}
    \qquad
    \ket{t}^\dagger = \bra{t}
    \qquad
    (D^\dagger)^\dagger = D \\
    (S.D)^\dagger = S^*.(D^\dagger)
    \qquad
    (D_1 + D_2)^\dagger = D_1^\dagger + D_2^\dagger \\
    (D_1 \cdot D_2)^\dagger = D_2^\dagger \cdot D_1^\dagger \\
    (K_1 \otimes K_2)^\dagger = K_1^\dagger \otimes K_2^\dagger
    \qquad
    (B_1 \otimes B_2)^\dagger = B_1^\dagger \otimes B_2^\dagger
    \qquad
    (O_1 \otimes O_2)^\dagger = O_1^\dagger \otimes O_2^\dagger \\
    (K \otimes B)^\dagger = B^\dagger \otimes K^\dagger
  \end{gather*}
\end{definition}


\begin{definition}[UNI-DOT]
  \begin{gather*}
      \textbf{0} \cdot D = \textbf{0}
      \qquad
      \textbf{1}_\mathcal{O} \cdot D = D \\
      D_1 \cdot (S.D_2) = S.(D_1 \cdot D_2)
      \qquad
      D_0 \cdot (D_1 + D_2) = D_0 \cdot D_1 + D_0 \cdot D_2 \\
      D_0 \cdot (D_1 \cdot D_2) = (D_0 \cdot D_1) \cdot D_2 \\
      (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) = (B_1 \cdot K_1) \times (B_2 \cdot K_2) \\
      (O_1 \otimes O_2) \cdot (K_1 \otimes K_2) = (O_1 \cdot O_1) \times (B_2 \cdot K_2) \\
      (B_1 \otimes B_2) \cdot (O_1 \otimes O_2) = (B_1 \cdot K_1) \times (O_2 \cdot O_2) \\
      (O_1 \otimes O_2) \cdot (O_1' \otimes O_2') = (O_1 \cdot O_1') \times (O_2 \cdot O_2') \\
      (K_1 \otimes B_1) \cdot (K_2 \otimes B_2) = (B_1 \cdot K_2) . (K_1 \otimes B_2)
  \end{gather*}
\end{definition}


\begin{definition}[UNI-TENSOR]
  \begin{gather*}
      \mathbf{0} \otimes D = \mathbf{0}
      \qquad
      D \otimes \mathbf{0} = \mathbf{0}
      \qquad
      \mathbf{1}_\mathcal{O} \otimes \mathbf{1}_\mathcal{O} = \mathbf{1}_\mathcal{O} \\
      \ket{s} \otimes \ket{t} =\ket{(s, t)} \\
      D_1 \otimes (S.D_2) = S.(D_1 \otimes D_2)
      \qquad
      D_0 \otimes (D_1 + D_2) = D_0 \otimes D_1 + D_0 \otimes D_2 \\
      (K_1 \otimes B) \cdot K_2 = (B \cdot K_2).K_1
      \qquad
      B_1 \cdot (K \otimes B_2) = (B_1 \cdot K).B_2 \\
      (K \otimes B) \cdot O = K \otimes (B \cdot O)
      \qquad
      O \cdot (K \otimes B) = (O \cdot K) \otimes B \\
      (K_1 \otimes B_1) \otimes (K_2 \otimes B_2) = (K_1 \otimes K_2) \otimes (B_1 \otimes B_2) \\
  \end{gather*}
\end{definition}

Note the axiom $\ket{s} \otimes \ket{t} =\ket{(s, t)}$ here. The combination of two subsystems can either be expressed as tensor product in linear algebra (on the left), or by data structure of pairing (on the right). This points to the isomorphism $\mathcal{H}_{A \times B} \cong \mathcal{H}_A \otimes \mathcal{H}_B$.

Because the symbols and semantics of scalars are different, we list the axioms of scalars as follows.

\begin{definition}[SCR-BASIC]
  \begin{gather*}
    C(0) + S = S
    \qquad
    S_1 + S_2 = S_2 + S_1
    \qquad
    (S_1 + S_2) + S_3 = S_1 + (S_2 + S_3) \\
    C(0) \times S = C(0)
    \qquad
    C(1) \times S = S
    \qquad
    S_1 \times S_2 = S_2 \times S_1 \\
    (S_1 \times S_2) \times S_3 = S_1 \times (S_2 \times S_3)
    \qquad
    S_1 \times (S_2 + S_3) = S_1 \times S_2 + S_1 \times S_3 \\
    C(\alpha) + C(\beta) = C(\alpha + \beta)
    \qquad
    C(\alpha) \times C(\beta) = C(\alpha \times \beta)
    \qquad
    C(\alpha)^* = C(\alpha^*) \\
    \delta_{s, t}^* = \delta_{s, t}
    \qquad
    (S_1 + S_2)^* = S_1^* + S_2^*
    \qquad
    (S_1 \times S_2)^* = S_1^* \times S_2^*
    \qquad
    (S^*)^* = S
    \qquad
    (B \cdot K)^* = K^\dagger \cdot B^\dagger
  \end{gather*}  
\end{definition}

\begin{definition}[SCR-DELTA]
  \label{def: SCR-DELTA}
  \begin{gather*}
    \delta_{s, s} = C(1) \\
    s, t \text{ are different constants} \vdash_{AX} \delta_{s, t} = C(0)  \tag{*} \\
    (\bigwedge_i s_i = t_i) \leftrightarrow (\bigwedge_i s_i' = t_i') \vdash_{AX} \prod_i \delta_{s_i, t_i} = \prod_i \delta_{s_i', t_i'} \tag{**}
  \end{gather*}
\end{definition}

An example for the (**) axiom is $\delta_{i, j} \times \delta_{j, k} = \delta_{i, k} \times \delta_{j, k}$. This means the reasoning of Delta operators also involve some propositional logic.

\begin{definition}[SCR-DOT]
  \begin{gather*}
    \mathbf{0} \cdot K = C(0) \\
    B \cdot (S.K) = S \times (B \cdot K) \\
    B \cdot (K_1 + K_2) = B_0 \cdot K_1 + B_0 \cdot K_2 \\
    \bra{s} \cdot \ket{t} = \delta_{s, t} \\
    (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) = (B_1 \cdot K_1) \times (B_2 \cdot K_2)
  \end{gather*}
\end{definition}

The symmetric rules can be deduced. For example,
\begin{align*}
(B_1 + B_2) \cdot K & = (((B_1 + B_2) \cdot K)^*)^* \\
& = (K^\dagger \cdot (B_1 + B_2)^\dagger)^* \\
& = (K^\dagger \cdot (B_1^\dagger + B_2^\dagger))^* \\
& = (K^\dagger \cdot B_1^\dagger + K^\dagger \cdot B_2^\dagger)^* \\
& = (K^\dagger \cdot B_1^\dagger)^* + (K^\dagger \cdot B_2^\dagger)^* \\
& = (B_1^\dagger)^\dagger \cdot (K^\dagger)^\dagger + (B_2^\dagger)^\dagger \cdot (K^\dagger)^\dagger \\
& = B_1 \cdot K + B_2 \cdot K.
\end{align*}

The axiomatic semantics are concluded above. To mitigate the formalization workload, its consistency compared to the denotational semantics is not directly proved here. Instead, we first prove the completeness of the term rewriting system w.r.t. the axioms, then prove the soundness of all the rewriting rules in \texttt{CoqQ} directly, which in the end implies that the axiomatic semantics is not stronger than the denotational one.


\section{Core Language Decision Procedure}
\label{sec: typed_dirac_rules}

The decision procedure of the core language is purely an AC term rewriting system.

\subsection{AC Term Rewriting Algorithm}
It is reasonable to assume that we have the rewriting term system to decide the complex number in $\Sigma_\mathcal{C}$ and atomic basis in $\Sigma_\mathcal{A}$, which are described in the following.

\begin{definition}[TRS $R_{\Sigma_\mathcal{A}}$]
  For the atomic basis language $\Sigma_\mathcal{A}$, the TRS $R_{\Sigma_\mathcal{A}}$ is any terminating and confluent TRS.
\end{definition}


\begin{definition}[TRS $R_{\Sigma_\mathcal{C}}$]
  For the complex number language $\Sigma_\mathcal{C}$, the TRS $R_{\Sigma_\mathcal{C}}$ is an TRS such that:
  \begin{itemize}
    \item $R_{\Sigma_\mathcal{C}}$ is terminating and ground confluent,
    \item for all closed terms $\alpha$, $\beta$ and $\gamma$, the pair of terms
    \begin{itemize}
        \item $0 + \alpha$ and $\alpha$,
        \item $0 \times \alpha$ and $0$,
        \item $1 \times \alpha$ and $\alpha$,
        \item $\alpha \times (\beta + \gamma)$ and $(\alpha \times \beta) + (\alpha \times \gamma)$,
        \item $(\alpha + \beta) + \gamma$ and $\alpha + (\beta + \gamma)$,
        \item $\alpha + \beta$ and $\beta + \alpha$,
        \item $(\alpha \times \beta) \times \gamma$ and $\alpha \times (\beta \times \gamma)$,
        \item $\alpha \times \beta$ and $\beta \times \alpha$,
        \item $(\alpha + \beta)^*$ and $\alpha^* + \beta^*$,
        \item $(\alpha \times \beta)^*$ and $\alpha^* \times \beta^*$,
        \item $(\alpha^*)^*$ and $\alpha$
    \end{itemize}
    have the same normal forms,
    \item $0$ and $1$ are normal terms.
  \end{itemize}  
\end{definition}

This definition follows the ``scalar rewrite system'' in Linear\cite{Arrighi2017}.


To decide the equivalence of two Dirac notation terms, we will use a variant of standard term rewritings called \textbf{AC-Rewriting} to deal with the associative and commutative symbols such as $+$ and $\times$. But here is one excpetion: the dot symbols in the core language is associative only, just like linear operations, but one important tool called \texttt{CiME2} we will use later does not support associative only symbols. In this consideration, we have to handle the associativity using rules hard-coded by hand.

\begin{definition} [TRS $R_\mathfrak{DN}$]
  The AC-rewrite system for the core language, written as $R_\mathfrak{DN}$, consists of all the rules in Sec.\ref{sec: typed_dirac_rules}.
  The AC-symbols are $+$ (for all sorts) and $\times$. The commutative symbol is $\delta_{s, t}$.
\end{definition}

\subsubsection*{\textsf{TYPE-CALC}}
\begin{gather*}
  \pi_1(\sigma \times \tau) \reduce \sigma 
  \qquad
  \pi_2(\sigma \times \tau) \reduce \tau 
  \\
  \K(\pi_K(T)) \reduce T
  \qquad 
  \pi_K(\K(\sigma)) \reduce \sigma
  \qquad
  \B(\pi_B(T)) \reduce T
  \qquad 
  \pi_B(\B(\sigma)) \reduce \sigma
  \\
  \Op(\pi_K(T), \pi_B(T)) \reduce T
  \qquad
  \pi_K(\Op(\sigma, \tau)) \reduce \sigma
  \qquad
  \pi_B(\Op(\sigma, \tau)) \reduce \tau
\end{gather*}

\subsubsection*{\textsf{TYPE-BASIS}}
\begin{gather*}
  \type((s, t)) \reduce \type(s) \times \type(t)
  \qquad
  \type(\fst s) \reduce \pi_1 (\type(s))
  \qquad
  \type(\snd s) \reduce \pi_2 (\type(s))
\end{gather*}

\subsubsection*{\textsf{TYPE-KET}}
\begin{gather*}
  \type(C(a)) \reduce \Sc
  \qquad
  \type(\delta_{s, t}) \reduce \Sc
  \qquad
  \type(S_1 + S_2) \reduce \Sc
  \\
  \type(S_1 \times S_2) \reduce \Sc
  \qquad
  \type(S^*) \reduce \Sc
  \qquad
  \type(B \cdot K) \reduce \Sc \\
  \\
  \type(\mathbf{0}_\mathcal{K}(\sigma)) \reduce \K(\sigma)
  \qquad
  \type(\ket{s}) \reduce \K(\type(s))
  \qquad
  \type(B^\dagger) \reduce \K(\pi_B(\type(B))) 
  \\
  \type(S . K) \reduce \type(K)
  \qquad
  \type(K_1 + K_2) \reduce \type(K_1)
  \qquad
  \type(O \cdot K) \reduce \K(\pi_K(\type(O)))
  \\
  \type(K_1 \otimes K_2) \reduce \K(\pi_K(\type(K_1)) \times \pi_K(\type(K_2)))
\end{gather*}

\subsubsection*{\textsf{TYPE-BRA}}
\begin{gather*}
  \type(\mathbf{0}_\mathcal{B}(\sigma)) \reduce \mathcal{B}(T)
  \qquad
  \type(\bra{s}) \reduce \mathcal{B}(\type(s))
  \qquad
  \type(K^\dagger) \reduce \mathcal{B}(\pi_K(\type(K)))
  \\
  \type(S . B) \reduce \type(B)
  \qquad
  \type(B_1 + B_2) \reduce type(B_1)
  \qquad
  \type(B \cdot O) \reduce \mathcal{B}(\pi_B(\type(O)))
  \\
  \type(B_1 \otimes B_2) \reduce \mathcal{B}(\pi_B(\type(B)) \times \pi_B(\type(B)))
\end{gather*}

\subsubsection*{\textsf{TYPE-OP}}
\begin{gather*}
  \type(\mathbf{0}_\mathcal{O}(\sigma, \tau)) \reduce \mathcal{O}(\sigma, \tau)
  \qquad
  \type(\mathbf{1}_\mathcal{O}(\sigma)) \reduce \mathcal{O}(\sigma, \sigma)
  \\
  \type(K \otimes B) \reduce \mathcal{O}(\pi_K(\type(K)), \pi_B(\type(B)))
  \qquad
  \type(O^\dagger) \reduce \mathcal{O}(\pi_B(\type(O)), \pi_K(\type(O)))
  \\
  \type(S . O) \reduce \type(O)
  \qquad
  \type(O_1 + O_2) \reduce \type(O_1)
  \qquad
  \type(O_1 \cdot O_2) \reduce \mathcal{O}(\pi_K(\type(O_1)), \pi_B(\type(O_2)))
  \\
  \type(O_1 \otimes O_2) \reduce \mathcal{O}(\pi_K(\type(O_1)) \times \pi_K(\type(O_2)), \pi_B(\type(O_1)) \times \pi_B(\type(O_2)))
\end{gather*}


\subsubsection*{\textsf{BASIS}}
\begin{gather*}
    \fst (s, t) \reduce s
    \qquad
    \snd (s, t) \reduce t
    \qquad
    (\fst s, \snd s) \reduce s
\end{gather*}

\subsubsection*{\textsf{DELTA}}
\begin{gather*}
  \delta{s, s} \reduce C(1)
  \qquad
  \delta_{u, (s, t)} \reduce \delta_{\fst u, s} \times \delta_{\snd u, t} 
  \qquad
  \delta_{\fst u, \fst v}\times\delta_{\snd u, \snd v} \reduce \delta_{u, v}
\end{gather*}

\textbf{Remark:} These last two rules are for completion.


\subsubsection*{\textsf{SCR-COP}}
\begin{gather*}
   C(0) + S \reduce S
  \qquad
   C(\alpha) + C(\beta) \reduce C(\alpha + \beta)
  \qquad
   S + S \reduce C(1 + 1) \times S \\
   C(\alpha) \times S + S \reduce C(\alpha + 1) \times S
  \qquad
   C(\alpha) \times S + C(\beta) \times S \reduce C(\alpha + \beta) \times S
  \\
  \\
   C(0) \times S \reduce C(0)
  \qquad
   C(1) \times S \reduce S
  \qquad
   C(\alpha) \times C(\beta) \reduce C(\alpha \times \beta)
  \qquad
   S_1 \times (S_2 + S_3) \reduce S_1 \times S_2 + S_1 \times S_3
  \\
  \\
   C(\alpha)^* \reduce C(\alpha^*)
  \qquad
   \delta_{s, t}^* \reduce \delta_{s, t} \\
   (S_1 + S_2)^* \reduce S_1^* + S_2^*
  \qquad
   (S_1 \times S_2)^* \reduce S_1^* \times S_2^*
  \qquad
   (S^*)^* \reduce S
  \qquad
   (B \cdot K)^* \reduce K^\dagger \cdot B^\dagger
\end{gather*}



\subsubsection*{\textsf{SCR-DOT}}
\begin{gather*}
  \mathbf{0}_\mathcal{B}(\sigma) \cdot K \reduce C(0)
  \qquad
  B \cdot \mathbf{0}_\mathcal{K}(\sigma) \reduce C(0)
  \qquad
  (S.B) \cdot K \reduce S \times (B \cdot K)
  \qquad
  B \cdot (S.K) \reduce S \times (B \cdot K) \\
  (B_1 + B_2) \cdot K \reduce B_1 \cdot K + B_2 \cdot K
  \qquad
  B \cdot (K_1 + K_2) \reduce B \cdot K_1 + B \cdot K_2
  \qquad
  \bra{s} \cdot \ket{t} \reduce \delta_{s, t} \\
\end{gather*}

\begin{gather*}
  (B_1 \otimes B_2) \cdot \ket{t} \reduce (B_1 \cdot \ket{\fst t}) \times (B_2 \cdot \ket{\snd t}) \\
  \bra{t} \cdot (K_1 \otimes K_2) \reduce (\bra{\fst t} \cdot K_1) \times (\bra{\snd t} \cdot K_2) \\
  (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) \reduce (B_1 \cdot K_1) \times (B_2 \cdot K_2)
\end{gather*}

\textbf{Remark:} The difficulty here comes from Hilbert space structure. The intuition is that, we decompose the multiplication (inner product) when at least one side is explicitly in tensor product form.

\subsubsection*{\textsf{SCR-SORT}}
\begin{gather*}
  (B \cdot O) \cdot K \reduce B \cdot (O \cdot K) \\
  \bra{s} \cdot ((O_1 \otimes O_2) \cdot K) \reduce ((\bra{\fst s} \cdot O_1) \otimes (\bra{\snd t} \cdot O_2)) \cdot K \\
  (B_1 \otimes B_2) \cdot ((O_1 \otimes O_2) \cdot K) \reduce ((B_1 \cdot O_1) \otimes (B_2 \cdot O_2)) \cdot K \\
\end{gather*}


\textbf{Remark:} Because we cannot use associative only symbols, we have to manually encode the decision logic. The first rule sorts the multiplication to the right, which breaks the symmetry of ket and bra. The remaining two rules are for completion.

\subsubsection*{\textsf{KET-ADJ}}
\begin{gather*}
  \textbf{0}_\mathcal{B}(\sigma)^\dagger \reduce \textbf{0}_\mathcal{K}(\sigma)
  \qquad
  \bra{t}^\dagger \reduce \ket{t}
  \qquad
  (K^\dagger)^\dagger \reduce K
  \qquad
  (S.B)^\dagger \reduce S^*.(B^\dagger) \\
  (B_1 + B_2)^\dagger \reduce B_1^\dagger + B_2^\dagger
  \qquad
  (B \cdot O)^\dagger \reduce O^\dagger \cdot B^\dagger
  \qquad
  (B_1 \otimes B_2)^\dagger \reduce B_1^\dagger \otimes B_2^\dagger
\end{gather*}

\subsubsection*{\textsf{KET-SCR}}
\begin{gather*}
  C(0).K \reduce \textbf{0}_{\mathcal{K}}(\pi_K(\type(K)))
  \qquad
  C(1).K \reduce K
  \qquad
  S.\textbf{0}_\mathcal{K}(\sigma) \reduce \textbf{0}_\mathcal{K}(\sigma)
  \\
  S_1.(S_2.K) \reduce (S_1 \times S_2).K
  \qquad
  S.(K_1 + K_2) \reduce S.K_1 + S.K_2
\end{gather*}

\subsubsection*{\textsf{KET-ADD}}
\begin{gather*}
  K + \textbf{0}_\mathcal{K}(\sigma) \reduce K
  \qquad
  K + K \reduce C(1 + 1).K
  \qquad
  S.K + K \reduce (S + C(1)).K
  \qquad
  S_1.K + S_2.K \reduce (S_1 + S_2).K
\end{gather*}

\subsubsection*{\textsf{KET-MLT}}
\begin{gather*}
  \textbf{0}_\mathcal{O}(\sigma, \tau) \cdot K \reduce \textbf{0}_\mathcal{K}(\sigma)
  \qquad
  O \cdot \mathbf{0}_{\mathcal{K}}(\sigma) \reduce \mathbf{0}_{\mathcal{K}}(\pi_K(\type(O)))
  \qquad
  \textbf{1}_\mathcal{O}(\sigma) \cdot K \reduce K \\
  (S.O) \cdot K \reduce S.(O \cdot K)
  \qquad
  O \cdot (S.K) \reduce S.(O \cdot K) \\
  (O_1 + O_2) \cdot K \reduce O_1 \cdot K + O_2 \cdot K
  \qquad
  O \cdot (K_1 + K_2) \reduce O \cdot K_1 + O \cdot K_2 \\
  \textcolor{red}{ (K_1 \otimes B) \cdot K_2 \reduce (B \cdot K_2).K_1}
  \qquad
  \textcolor{red}{ (O_1 \cdot O_2) \cdot K \reduce O_1 \cdot (O_2 \cdot K)} \\
  \textcolor{red}{ (O_1 \otimes O_2) \cdot ((O_1' \otimes O_2') \cdot K) \reduce ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2')) \cdot K} \\
  (O_1 \otimes O_2) \cdot \ket{t} \reduce (O_1 \cdot \ket{\fst t}) \otimes (O_2 \cdot \ket{\snd t}) \\
  (O_1 \otimes O_2) \cdot (K_1 \otimes K_2) \reduce (O_1 \cdot K_1) \otimes (O_2 \cdot K_2)
\end{gather*}

\textbf{Remark:} Again, the difficulty comes from space structure. The intuition for reductions is also the same: decompose the multiplication when at least one side is explicitly in tensor product form.


\subsubsection*{\textsf{KET-TSR}}
\begin{gather*}
  \mathbf{0}_\mathcal{K}(\sigma) \otimes K \reduce \mathbf{0}_\mathcal{K}(\sigma \times \pi_K(\type(K)))
  \qquad
  K \otimes \mathbf{0}_\mathcal{K}(\sigma) \reduce \mathbf{0}_\mathcal{K}(\pi_K(\type(K)) \times \sigma)
  \qquad
  \ket{s} \otimes \ket{t}\reduce\ket{(s, t)} \\
  (S.K_1) \otimes K_2 \reduce S.(K_1 \otimes K_2)
  \qquad
  K_1 \otimes (S.K_2) \reduce S.(K_1 \otimes K_2) \\
  (K_1 + K_2) \otimes K_3 \reduce K_1 \otimes K_3 + K_2 \otimes K_3
  \qquad
  K_1 \otimes (K_2 + K_3) \reduce K_1 \otimes K_2 + K_1 \otimes K_3
\end{gather*}

\textbf{Remark: } The rules for bra are symmetric to the rules for ket. Only the correspondence of rules in red are different:

\begin{gather*}
  B_1 \cdot (K \otimes B_2) \reduce (B_1 \cdot K).B_2 \\
  B \cdot (O_1 \cdot O_2) \reduce (B \cdot O_1) \cdot O_2 \\
  (B \cdot (O_1 \otimes O_2)) \cdot (O_1' \otimes O_2') \reduce B \cdot ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2'))
\end{gather*}

\subsubsection*{\textsf{OPT-OUTER}}
\begin{gather*}
  \mathbf{0}_\mathcal{K}(\sigma) \otimes B \reduce \mathbf{0}_\mathcal{O}(\sigma, \pi_B(\type(B)))
  \qquad
  K \otimes \mathbf{0}_\mathcal{B}(\sigma) \reduce \mathbf{0}_\mathcal{O}(\pi_K(\type(K)), \sigma) \\
  (S.K) \otimes B \reduce S.(K \otimes B)
  \qquad
  K \otimes (S.B) \reduce S.(K \otimes B) \\
  (K_1 + K_2) \otimes B \reduce K_1 \otimes B + K_2 \otimes B
  \qquad
  K \otimes (B_1 + B_2) \reduce K \otimes B_1 + K \otimes B_2
\end{gather*}


\subsubsection*{\textsf{OPT-ADJ}}
\begin{gather*}
  \textbf{0}_\mathcal{O}(\sigma, \tau)^\dagger \reduce \textbf{0}_\mathcal{O}(\tau, \sigma)
  \qquad
  \textbf{1}_\mathcal{O}(\sigma)^\dagger \reduce \textbf{1}_\mathcal{O}(\sigma)
  \qquad
  (K \otimes B)^\dagger \reduce B^\dagger \otimes K^\dagger
  \qquad
  (O^\dagger)^\dagger \reduce O \\
  (S.O)^\dagger \reduce S^*.(O^\dagger)
  \qquad
  (O_1 + O_2)^\dagger \reduce O_1^\dagger + O_2^\dagger
  \qquad
  (O_1 \cdot O_2)^\dagger \reduce O_2^\dagger \cdot O_1^\dagger
  \qquad
  (O_1 \otimes O_2)^\dagger \reduce O_1^\dagger \otimes O_2^\dagger
\end{gather*}

\subsubsection*{\textsf{OPT-SCR}}
\begin{gather*}
  C(0).O \reduce \mathbf{0}_\mathcal{O}(\pi_K(\type(O)), \pi_B(\type(O)))
  \qquad
  C(1).O \reduce O
  \qquad
  S.\textbf{0}_\mathcal{O}(\sigma, \tau) \reduce \textbf{0}_\mathcal{O}(\sigma, \tau) \\
  S_1.(S_2.O) \reduce (S_1 \times S_2).O
  \qquad
  S.(O_1 + O_2) \reduce S.O_1 + S.O_2
\end{gather*}

\subsubsection*{\textsf{OPT-ADD}}
\begin{gather*}
  O + \mathbf{0}_\mathcal{O}(\sigma, \tau) \reduce O
  \qquad
  O + O \reduce C(1 + 1).O
  \quad
  S.O + O \reduce (S + C(1)).O
  \quad
  S_1.O + S_2.O \reduce (S_1 + S_2).O
\end{gather*}

\subsubsection*{\textsf{OPT-MLT}}
\begin{gather*}
  \mathbf{0}_\mathcal{O}(\sigma, \tau) \cdot O \reduce \mathbf{0}_\mathcal{O}(\sigma, \pi_B(\type(O)))
  \qquad
  O \cdot \mathbf{0}_\mathcal{O}(\sigma, \tau) \reduce \mathbf{0}_\mathcal{O}(\pi_K(\type(O)), \tau) \\
  \mathbf{1}_\mathcal{O}(\sigma) \cdot O \reduce O
  \qquad
  O \cdot \mathbf{1}_\mathcal{O}(\sigma) \reduce O \\
  (K \otimes B) \cdot O \reduce K \otimes (B \cdot O)
  \qquad
  O \cdot (K \otimes B) \reduce (O \cdot K) \otimes B\\
  (S.O_1) \cdot O_2 \reduce S.(O_1 \cdot O_2)
  \qquad
  O_1 \cdot (S.O_2) \reduce S.(O_1 \cdot O_2) \\
  (O_1 + O_2) \cdot O_3 \reduce O_1 \cdot O_3 + O_2 \cdot O_3
  \qquad
  O_1 \cdot (O_2 + O_3) \reduce O_1 \cdot O_2 + O_1 \cdot O_3 \\
  (O_1 \cdot O_2) \cdot O_3 \reduce O_1 \cdot (O_2 \cdot O_3) \\
  (O_1 \otimes O_2) \cdot (O_1' \otimes O_2') \reduce (O_1 \cdot O_1') \otimes (O_2 \cdot O_2') \\
  (O_1 \otimes O_2) \cdot ((O_1' \otimes O_2') \cdot O_3) \reduce ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2')) \cdot O_3
\end{gather*}


\subsubsection*{\textsf{OPT-TSR}}
\begin{gather*}
  \mathbf{0}_\mathcal{O}(\sigma, \tau) \otimes O \reduce \mathbf{0}_\mathcal{O}(\sigma \times \pi_K(\type(O)), \tau \times \pi_B(\type(O)))
  \\
  O \otimes \mathbf{0}_\mathcal{O}(\sigma, \tau) \reduce \mathbf{0}_\mathcal{O}(\pi_K(\type(O)) \times \sigma, \pi_B(\type(O)) \times \tau) \\
  \mathbf{1}_\mathcal{O}(\sigma) \otimes \mathbf{1}_\mathcal{O}(\tau) \reduce \mathbf{1}_\mathcal{O}(\sigma \times \tau) \\
  (K_1 \otimes B_1) \otimes (K_2 \otimes B_2) \reduce (K_1 \otimes K_2) \otimes (B_1 \otimes B_2) \\
  (S.O_1) \otimes O_2 \reduce S.(O_1 \otimes O_2)
  \qquad
  O_1 \otimes (S.O_2) \reduce S.(O_1 \otimes O_2) \\
  (O_1 + O_2) \otimes O_3 \reduce O_1 \otimes O_3 + O_2 \otimes O_3
  \qquad
  O_1 \otimes (O_2 + O_3) \reduce O_1 \otimes O_2 + O_1 \otimes O_3
\end{gather*}


\subsection{Confluence of $R_\mathfrak{DN}$}

We use \texttt{CiME2} to check the local confluence of the TRS of Dirac notation automatically.

We now present a smallest instantiation $R_{\Sigma_\mathcal{C}}$ of a complext scalar rewrite system. 

\begin{definition}[The rewrite system $R_{\Sigma_\mathcal{C}0}$]
  The system $R_{\Sigma_\mathcal{C}0}$ is defined by the following rules:
  \begin{gather*}
    0 + \alpha \reduce \alpha
    \qquad
    0 \times \alpha \reduce 0
    \qquad
    1 \times \alpha \reduce \alpha \\
    \alpha \times (\beta + \gamma) \reduce \alpha \times \beta + \alpha \times \gamma \\
    0^* \reduce 0
    \qquad
    1^* \reduce 1 \\
    (\alpha + \beta)^* \reduce \alpha^* + \beta^*
    \qquad
    (\alpha \times \beta)^* \reduce \alpha^* \times \beta^*
    \qquad
    (\alpha^*)^* \reduce \alpha
  \end{gather*}
  where $+$ and $\times$ are AC-symbols.
\end{definition}

We can compare the avatar $R_{\Sigma_\mathcal{C}0}$ above with the general complex number rewrite system $R_{\Sigma_\mathcal{C}}$ and prove the subsumption relation.

\begin{proposition}
  $R_{\Sigma_\mathcal{C}}$ subsumes $R_{\Sigma_\mathcal{C}0}$.
\end{proposition}

\begin{proof}
  Obvious.
\end{proof}


If a TRS $R$ contains AC-symbols, checking the critical pairs of $R$ is not enough to ensure the local confluence of $R$. This is because the LHS of rules can match the term unlocally. For example:
$$
(K_0 + K_1) + K_0 \reduce C(1 + 1).K_0 + K_1
$$
by the rule $ K + K \reduce C(1 + 1).K$. Therefore, to prove the confluence of a AC-rewrite system, we need to consider an extended system, as indicated by the following definition.

\begin{definition}[The extension rules]
  Let $X$ be a AC-rewrite system with AC symbols $f_1, \cdots, f_n$. We define the AC-rewrite system $X_{ext}$ as containing the same AC symbols as $X$, the same rules as $X$, plus the rule $f_i(t, x) \to f_i(u, x)$ for each rule $t \to u$ of $X$ where the head symbol of $t$ is $f_i$.
\end{definition}

This extension rules are automatically added for all rules encoded in \texttt{CiME2}.

\begin{proposition}
  The system $R_\mathfrak{DN} \cup R_{\Sigma_\mathcal{C}0}$ is locally confluent on well-typed terms.
\end{proposition}
\begin{proof}
  We check that all the critical pairs are joinable. This is completed in two steps: firstly, encode the TRS within \texttt{CiME2} and find the unjoinable critical pairs. There are 55 typing related unjoinable critical pairs out of ~2000 critical pairs. Then we manually checked that with the well-typed constraint, the remaining 55 critical paris are also joinable. 
  
  As an example, there is an unjoinable critical pair
  $$
    \type(K_1) \reducefrom \type(K_1 + K_2) \reduce \type(K_2)
  $$
  from the rule $\type(K_1 + K_2) \reduce \type(K_1)$ on itself. But considering the well-typed constraint on $K_1 + K_2$, we should have $\type(K_1) = \type(K_2)$. Therefore the critical pair is actually joinable.
\end{proof}


\begin{lemma}[local confluence of $R_\mathfrak{DN}$]
  For any complex number rewrite system $R_{\Sigma_\mathcal{A}}$ and atomic basis rewrite system $R_{\Sigma_\mathcal{C}}$, the system $R_\mathfrak{DN} \cup R_{\Sigma_\mathcal{A}} \cup R_{\Sigma_\mathcal{C}}$ is locally confluent.
\end{lemma}
\begin{proof}
  Both $R_{\Sigma_\mathcal{A}}$ and $R_{\Sigma_\mathcal{C}}$ are terminating and confluent by definition. 
  The system $R_{\Sigma_\mathcal{C}}$ subsumes $R_{\Sigma_\mathcal{C}0}$, and $R_{\Sigma_\mathcal{A}}$ subsumes an empty rewriting system. 
  The system $R_\mathfrak{DN} \cup R_{\Sigma_\mathcal{C}0}$ is locally confluent. 
  The system $R_{\Sigma_\mathcal{C}}$ commutes with $R_\mathfrak{DN}^*$, because the terms in $\Sigma_\mathcal{C}$ appears in the left hand sides of rules in $R_\mathfrak{DN}$ only as variables and constants $0, 1$, therefore all the rules in $R_{\Sigma_\mathcal{C}}$ commutes with $R_\mathfrak{DN}^*$. 
  Then the avatar lemma finishes the proof.
\end{proof}


% \subsection{Checking by \texttt{CiME}}

% We encoded the typed Dirac notation in a simple TRS and checked the confluence of the whole system. Here is a summary of the rules.


% \begin{center}
%   \begin{tabular}{c|c}
%   \hline
%   Type & Rule Number \\
%   \hline
%   type checking & 27 \\
%   overloading polymorphic symbols & 22 \\
%   complex scalar avatar & 9 \\
%   Dirac notation & 141 \\
%   AC-symbol extension rules & 25 \\
%   \hline
%   Total & 224 \\
%   \hline
%   \end{tabular}
% \end{center}

% And all the 3133 critical pairs are joinable.

% \subsubsection*{About Reduandancy}
% I also checked through a \texttt{Python} script that removing any of the reduction rule will lead to non-confluence or change of the equational theory. For example, I found that removing 
% $$
%  (\fst e, \snd e)\reduce e
% $$
% or
% $$
%  (K_1 \otimes B_1) \otimes (K_2 \otimes B_2) \reduce (K_1 \otimes K_2) \otimes (B_1 \otimes B_2)
% $$
% respectively will still lead to a confluence TRS, but the equivalence induced by the TRS will be be changed.


\subsection{Termination of $R_\mathfrak{DN}$}

Attempted to prove termination by modularity of simple terminating property. Not successful: cannot cut the whole system into several simply terminating one. Notice the rule $\delta_{s, (u, v)} \reduce \delta_{\fst s, u} \times \delta_{\snd s, v}$.

Cannot find the interpretation to positive integers.



\subsection{Confluence by Modularity}
\label{sec: conf-modular}

Our theories on Dirac notations can be divided into different parts, each containing its own language and computational methods. For example, the parts concerning complex numbers and basis vectors of vector spaces are relatively independent and complete; while the language and algorithm of Dirac notations are based on these components. Subsequent theoretical developments can build on this entire result, such as our extended Dirac language which incorporates a big operator sum and indices for quantum registers.

These components are relatively independent and complete, allowing us to refer to them as different modules. Traditionally, the entire formal system has been studied as a whole. This approach is straightforward and direct, avoiding the need to consider how the parts interact, but at the expense of flexibility. Taking Dirac notation as an example, when we expand the language of complex numbers or design a more comprehensive rewriting system, the properties of the entire formal system need to be reconsidered. 
To make theoretical results more general, we can explore a modular narrative and proof methodology. For rewriting systems, we can utilize the Avatar Lemma \cite{Arrighi2005}\cite{Arrighi2017}, which is introduced below.

% First we introduce some concepts about modularity and the avatar lemma.


\begin{definition}[Subsumption]
  A terminating and confluent relation $S$ subsumes a relation $S_0$ if whenever $t \to_{S_0} u$, $t$ and $u$ have the same $S$-normal form.
\end{definition}

\begin{definition}[Commuting relations]
  Two relations $X$ and $Y$ are said to be commuting if whenever $t \to_X u$ and $t \to_Y v$, there exists a term $w$ such that $u \to_Y w$ and $v \to_X w$.
\end{definition}

\begin{lemma}[The avatar lemma] \cite{Arrighi2005} Let $X$, $S$ and $S_0$ be three relations defined on a set such that:
  \begin{itemize}
    \item $S$ is terminating and confluent;
    \item $S$ subsumes $S_0$;
    \item $S_0 \cup X$ is locally confluent;
    \item $X$ commutes with $S^*$.
  \end{itemize}
  Then, the relation $S \cup X$ is locally confluent.
\end{lemma}

The smaller relation $S_0$ here is called the avatar, since it captures the critical part of the larger relation $S$ that will appear in the rest part $X$. The avatar lemma formalizes our intuition about the modularity of confluence: if we start with the locally confluent system $S_0 \cup X$ and extend the system from $S_0$ to $S$, which will not interfere with the other part $X$ and is still confluent, then the whole system $S\cup X$ will remain locally confluent. In our development of Dirac notations, we will use such avatars to represent the weakest requirement on complex numbers and basis.



\subsection{Soundness and Completeness of $R_\mathfrak{DN}$}

To evaluate the reliability and capability of $R_\mathfrak{DN}$, we consider their soundness and correctness, which are defined and proved below.

\begin{definition}[soundness and completeness]
  A formal system $F$ is sound to decide $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$ if for all $X, Y \in \mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, $F \vdash X = Y$ implies $\sem{X} = \sem{Y}$. If for another formal proof system $G$, for all $X, Y \in \mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, $G \vdash X = Y$ implies $F \vdash X = Y$, we say the system $F$ is complete for $G$.
\end{definition}

\begin{lemma}[soundness of $R_\mathfrak{DN}$]
  The system $R_\mathfrak{DN}$ is sound.
\end{lemma}
\begin{proof}
  The proof is a formalization in \texttt{CoqQ}. Based on the constructions of linear space, we encoded the language syntax and denotational semantics, and proved that for all rules $e_1 \reduce e_2$ in $R_\mathfrak{DN}$, the proposition $\sem{e_1} = \sem{e_2}$ holds.
\end{proof}

Then We consider completeness. The two deduction rules (*) and (**) in \ref{def: SCR-DELTA} cannot be encoded and proved in the term rewrite system $R_\mathfrak{DN}$. Other axioms are checked by normalizing both sides of the equations.

\begin{lemma}[relative completeness of $R_\mathfrak{DN}$]
  For any complete rewrite system $R_{\Sigma_\mathcal{A}}$ and $R_{\Sigma_\mathcal{C}}$, the system $R_\mathfrak{DN}\cup R_{\Sigma_\mathcal{A}} \cup R_{\Sigma_\mathcal{C}}$ is complete for the axiomatic semantics $AX$ excluding (*), (**).
\end{lemma}
\begin{proof}
  Encoded and calculated in the implementation of $R_\mathfrak{DN}$.
\end{proof}

The above results generally means that the TRS $R_\mathfrak{DN}$ is sound for the denotational semantics, and is not weaker than the axiomatic semantics. Combining these two, we can easily prove the consistency of the two sematnics as a byproduct.

\begin{corollary}[consistency of denotational and axiomatic semantics]
  The axiomatic semantics is consistent with the denotational one. In other words, for all $X, Y \in \mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, if $AX \vdash X = Y$, then $\sem{X} = \sem{Y}$.
\end{corollary}
\begin{proof}
  By induction on the proof by $AX$. The cases of axioms in $AX$ are proved by the relative completeness and soundness of $R_\mathfrak{DN}$. The deduction rules (*) and (**) in \ref{def: SCR-DELTA} can be checked by hand.
  \yx{A small problem here. Difference in s, t symbols does not imply that their semantical explanations are different. I should modify the premises of (*) and (**).}
\end{proof}

\subsection{Completeness of $R_\mathfrak{DN}$ (New Proof)}

\begin{definition}[completeness]
  We say the TRS $R$ of language $L$ is complete w.r.t. the semantics, if for all terms $e_1, e_2$ of $L$ and all variable valuations $\sigma$, $\sem{e_1}_\sigma = \sem{e_2}_\sigma$ implies $R \vdash e_1 \downarrow = e_2 \downarrow$.
\end{definition}

\begin{theorem}[relative completeness of $R_\mathfrak{DN}$]
  Assume the TRS $R_{\Sigma_\mathcal{A}}$ is complete for $\Sigma_\mathcal{A}$ and $R_{\Sigma_\mathcal{C}}$ is complete for $\Sigma_\mathcal{C}$, then TRS $R_\mathfrak{DN}\cup R_{\Sigma_\mathcal{A}} \cup R_{\Sigma_\mathcal{C}}$ is complete for $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$.
\end{theorem}
\begin{proof}
  Assume we have $u, v$ in $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$ and $\sem{u}_\sigma = \sem{v}_\sigma$ for all valuations $\sigma$. 
  We prove by structural induction on the terms $u$ and $v$ in different sorts.
  
  \textbf{$\mathcal{C}$(complex number).} By completeness of $\Sigma_\mathcal{C}$.

  \textbf{$\mathcal{E}$(basis).} 
   
  \begin{enumerate}
    \item $(u \equiv x_1)$. 
    \begin{itemize}
      \item $(v \equiv x_2)$. Since $\sigma(u) = \sigma(v)$ for all $\sigma$, $u$ and $v$ must be the same variable. This also applies to the cases when $u$ and $v$ are both variables in other sorts.
      \item $(v \equiv a)$. $\forall \sigma. \sigma(u) = \sem{v}_\sigma$ not satisfied.
      \item $(v \equiv \fst s)$. 
    \end{itemize}
    To satisfy $\forall \sigma. \sigma(u) = \sem{v}_\sigma$, $v$ must also be the variable $x$. Otherwise, we can find valuations distinguishing them by making $\sigma(u) \in A$ and $\sem{v}_\sigma \in \mathcal{D}_{\mathcal{E}} - A$, or $\sigma(u) \in \mathcal{D}_{\mathcal{E}} - A$ and $\sem{v}_\sigma \in A$.
    \item $(u \equiv a_1)$. Since the semantics of $(t, t)$, $\fst t$ and $\snd t$ are out of $A$, we must have $v \equiv a_2$. By completeness of $R_{\Sigma_\mathcal{A}}$, $u$ and $v$ have the same normal form.
    \item $(u \equiv (t_1, t_2))$. 
      \begin{itemize}
        \item $(v \equiv (s_1, s_2))$. $\sem{(t_1, t_2)} = (\sem{t_1}, \sem{t_2}) = (\sem{s_1}, \sem{s_2}) = \sem{(s_1, s_2)}$, therefore we have $\sem{t_1} = \sem{s_1} \wedge \sem{t_2} = \sem{s_2}$. Then finished by induction hypothesis.
        \item $(v \equiv \fst s)$. If $\sem{s}_\sigma = (a_1, a_2)$, then $s \equiv (r_1, r_2)$ for some $r_1, r_2$. By reduction rule in \textsc{BASIS} we have 
      \end{itemize}
  \end{enumerate}


\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Extended Language: Big-op Sum}

\subsection{Syntax, Typing and Semantics}
\begin{definition}[DNE]
    The \textbf{language of Dirac Notation Extended}, denoted as $\mathfrak{DNE}(\Sigma_\mathcal{B}, \Sigma_\mathcal{S})$, consists of the same sorts as the core language and the following new symbols:
    \begin{align*}
        & \text{(set type)} && T ::= \texttt{Set}(\sigma) \\
        & \text{(set)} && M ::= x\ |\ \mathbf{U}(\sigma)\ |\ M \times M \\
        & \text{(extended Dirac notation)} && S ::= \sum_{i \in M} S
        \qquad K ::= \sum_{i \in M} K
        \qquad B ::= \sum_{i \in M} B
        \qquad O ::= \sum_{i \in M} O
    \end{align*}
    The index $i$ for summation is a bind variable, and $M$ is the variable for the multiset of summation. The common equivalence involving bind variables are adopted here: $\alpha$-conversion and substitutions.
\end{definition}

% typing

The typing rules of DNE consist of those for DN and the following rules.

\textsc{(Set)}
\begin{gather*}
  \frac{}{\Gamma \vdash \mathbf{U}(\sigma) : \texttt{Set}(\sigma)}
  \qquad
  \frac{\Gamma \vdash M_1 : \texttt{Set}(\sigma) \qquad \Gamma \vdash M_2 : \texttt{Set}(\tau)}{\Gamma \vdash M_1 \times M_2 : \texttt{Set}(\sigma \times \tau)}
\end{gather*}

\textsc{(Big-op)}
\begin{gather*}
  \frac{\Gamma \vdash M : \texttt{Set}(\sigma) \qquad \Gamma::(i : \sigma) \vdash S : \Sc}{\Gamma \vdash \sum_{i \in M} S : \Sc}
  \qquad
  \frac{\Gamma \vdash M : \texttt{Set}(\sigma) \qquad \Gamma::(i : \sigma) \vdash K : \K(\tau)}{\Gamma \vdash \sum_{i \in M} K : \K(\tau)} \\
  \\
  \frac{\Gamma \vdash M : \texttt{Set}(\sigma) \qquad \Gamma::(i : \sigma) \vdash B : \B(\tau)}{\Gamma \vdash \sum_{i \in M} B : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash M : \texttt{Set}(\sigma) \qquad \Gamma::(i : \sigma) \vdash O : \Op(\tau, \rho)}{\Gamma \vdash \sum_{i \in M} O : \Op(\tau, \rho)}
\end{gather*}

\begin{definition}[semantics of extended Dirac notation]
  The semantics of the extended Dirac notations are defined as follows:
  \begin{align*}
    & \text{(Set Types)} && \begin{aligned}
      \sem{\texttt{Set}(\sigma)} \equiv 2^{\sem{\sigma}},
    \end{aligned} \\
    & \text{(Set)} && \begin{aligned}
      \sem{\mathbf{U}(\sigma)} \equiv \sem{\sigma},
      \qquad
      \sem{M_1 \times M_2} \equiv \sem{M_1} \times \sem{M_2},
    \end{aligned} \\
    \\
    & \text{(Big-op)} && \begin{aligned}
      & \sem{\sum_{i \in M} S}^v \equiv \sum_{m \in \sem{M}} \sem{S}^{v;\ i\mapsto m},
      \qquad
      \sem{\sum_{i \in M} K}^v \equiv \sum_{m \in \sem{M}} \sem{K}^{v;\ i\mapsto m},
      \\
      & \sem{\sum_{i \in M} B}^v \equiv \sum_{m \in \sem{M}} \sem{B}^{v;\ i\mapsto m},
      \qquad
      \sem{\sum_{i \in M} O}^v \equiv \sum_{m \in \sem{M}} \sem{O}^{v;\ i\mapsto m}.
    \end{aligned}
  \end{align*}
\end{definition}

Note that $v;\ i \mapsto m$ means the valuation that updates $v$ with variable $i$ mapping to $m$.

\section{Extended Language Decision Procedure}

% \subsubsection*{\textsf{BETA-REDUCTION}}
% \begin{gather*}
%   (\lambda x.A)\ t \reduce A[x:=t]
% \end{gather*}
% \textbf{Reamrk:} We need abstraction and application to represent Dirac notations dependent on some variable. For example, $\sum_{i \in M} v_i$.

\subsection{Rewriting Rules}

\subsubsection*{\textsf{SET-SIMP}}
\begin{gather*}
  \mathbf{U}(\sigma) \times \mathbf{U}(\tau) \reduce \mathbf{U}(\sigma \times \tau)
\end{gather*}

\subsubsection*{\textsf{SUM-ELIM}}
\begin{gather*}
  \sum_{i \in M} C(0) \reduce C(0)
  \qquad
  \sum_{i \in M} \mathbf{0}_\mathcal{K}(\sigma) \reduce \mathbf{0}_\mathcal{K}(\sigma)
  \qquad
  \sum_{i \in M} \mathbf{0}_\mathcal{B}(\sigma) \reduce \mathbf{0}_\mathcal{B}(\sigma)
  \qquad
  \sum_{i \in M} \mathbf{0}_\mathcal{O}(\sigma, \tau) \reduce \mathbf{0}_\mathcal{O}(\sigma, \tau)\\
  \mathbf{1}_\mathcal{O}(\sigma) \reduce \sum_{i \in \mathbf{U}(\sigma)} \ket{i}\otimes\bra{i}
\end{gather*}

One common condition is attached to all the following rules: variable $i$ does not have free appearance in term $s$

Here $S.A$ is interpreted as three cases: $S.K$, $S.B$ and $S.O$.
\begin{gather*}
  \sum_{i \in \mathbf{U}(\sigma)} \delta_{i, s} \reduce C(1)
  \qquad
  \sum_{i \in \mathbf{U}(\sigma)} (\delta_{i, s} \times S) \reduce S[i:=s] \\
  \sum_{i \in \mathbf{U}(\sigma)} (\delta_{i, s}.A) \reduce A[i:=s]
  \qquad
  \sum_{i \in \mathbf{U}(\sigma)} ((\delta_{i, s} \times S).A) \reduce S[i:=s].A[i:=s]
\end{gather*}
\begin{gather*}
  \sum_{i \in M} \sum_{j \in M} \delta_{i, j} \reduce \sum_{j \in M} C(1)
  \qquad
  \sum_{i \in M} \sum_{j \in M} (\delta_{i, j} \times S) \reduce \sum_{j \in M} S[i:=j] \\
  \sum_{i \in M} \sum_{j \in M} (\delta_{i, j}.A) \reduce \sum_{j \in M} A[i:=j]
  \qquad
  \sum_{i \in M} \sum_{j \in M} ((\delta_{i, j} \times S).A) \reduce \sum_{j \in M} S[i:=j].A[i:=j]
\end{gather*}
\textbf{Remark:} To avoid problems, we assume that bind variables cannot be substituted into sum expressions. For example:
$$
\sum_{i \in M} \delta_{i, s}[s:=i^2] \equiv \sum_{j \in M} \delta_{j, i^2}.
$$
In other words, the variables will never implicitly depend on bind variables.

\subsubsection*{\textsf{SUM-PUSH}}

Here the $A^\dagger$, $A^\top$, $S.A$ and addition are interpreted in three sorts: ket, bra and operator.
The bind variable $i$ does not appear in $X$.
Here $A \cdot B$ is interpreted as four cases: $B \cdot K$, $O \cdot K$, $B \cdot O$ and $O_1 \cdot O_2$. $A \otimes B$ is interpreted as four cases: $K_1 \otimes K_2$, $B_1 \otimes B_2$, $K \otimes B$ and $O_1 \otimes O_2$.

\begin{gather*}
  (\sum_{i \in M} S) \times X \reduce \sum_{i \in M} (S \times X)
  \qquad
  (\sum_{i \in M} S)^* \reduce \sum_{i \in M} S^* \\
  (\sum_{i \in M} A)^\dagger \reduce \sum_{i \in M} A^\dagger
  \qquad
  (\sum_{i \in M} A)^\top \reduce \sum_{i \in M} A^\top \\
  X.(\sum_{i \in M} A) \reduce \sum_{i \in M} (X.A)
  \qquad
  (\sum_{i \in M} S). X \reduce \sum_{i \in M} (S.X) \\
  (\sum_{i \in M} A) \cdot X \reduce \sum_{i \in M} (A \cdot X) 
  \qquad
  X \cdot (\sum_{i \in M} B) \reduce \sum_{i \in M} (X \cdot B) \\
  (\sum_{i \in M} A) \otimes X \reduce \sum_{i \in M} (A \otimes X) 
  \qquad
  X \otimes (\sum_{i \in M} B) \reduce \sum_{i \in M} (X \otimes B)
\end{gather*}

\subsubsection*{About \textsf{SUM-DIST}: push in or pull out?}
We can flip the direction of the rules in \textsf{SUM-DIST} to pull elements out of the summation. I believe the difference lies in the \textbf{information of bind variable dependencices}.

When pushing inside, the information of bind variable independence is lost. This makes elimination rule less complete. Maybe we want to do in the opposite way: pull everything out as much as possible. Those rules involve checking whether the subterm to be pulled out is independent on the bind variable. But this strategy makes matching elimination rule simpler.

\yx{Discuss: to pull out or push in ...}

% \subsubsection*{\textsf{SUM-ADD}}
% Here the addition $A + B$ is interpreted in four sorts: scalar, ket, bra and operator.
% \begin{align*}
%   & (\sum_{i \in M} A) + (\sum_{j \in N} B) \reduce \sum_{k \in M \cup N} (A[i:=k] + B[j:=k])
% \end{align*}
\subsubsection*{SUM-ADD}
\begin{gather*}
  (\sum_{i \in M} X) + (\sum_{j \in M} Y) = \sum_{k \in M} (X[i:=k] + Y[j:=k])
\end{gather*}

\subsubsection*{SUM-INDEX}
\yx{Need to adjust the following rules according to typing information.}
\begin{gather*}
  \frac{\fst i \text{ not free in } A \vee \snd i \text{ not free in } A}{\sum_{i\in\mathbf{U}(\sigma \times \tau)}A \reduce \sum_{j\in\mathbf{U}(\sigma)}\sum_{k\in\mathbf{U}(\tau)}A[\fst i:=j, \snd i:=k, i:=(j,k)]}
  \\
  \\
  \frac{\fst i \text{ not free in } A \vee \snd i \text{ not free in } A}{\sum_{i\in M_1 \times M_2}A \reduce \sum_{j\in M_1}\sum_{k\in M_2}A[\fst i:=j, \snd i:=k, i:=(j,k)]}
  \\
  \\
  \frac{(j, k) \text{ not free in } A \wedge i, j \text{ appear in } A \text{ only as } (i, j)}{\sum_{j\in M_1}\sum_{k\in M_2}A \reduce \sum_{i\in M_1\times M_2}A[(j,k):=i]}
\end{gather*}

\subsection{Entry Expansion}

The following equalities hold for ket, bra and operators respectively. 
\begin{gather*}
  \sum_i (\bra{i} \cdot K).\ket{i} = K
  \qquad
  \sum_i (B \cdot \ket{i}).\bra{i} = B
  \qquad
  \sum_i \sum_j (\bra{i} A \ket{j}).\ket{i}\bra{j} = A
\end{gather*}

During the equivalence checking, the algorithm will expand the atomic variables of ket, bra and operator.

\subsection{Considering $\alpha$-conversion}

Our goal is to design the algorithm that checks whether two terms are equivalent. Ideally this can be achieved by rewriting to normal forms, but for complicated scenarios, the normal form may not exist. This is the case with transpose and big operator. We have these axioms: 
\begin{align*}
& \text{(SUM-SWAP)} && \sum_{i \in M} \sum_{j \in N} A = \sum_{j \in N} \sum_{i \in M} A 
\end{align*}

Our algorithm for deciding equivalence takes these equations into consideration....

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Discussion}

Transpose is also an important operation pervasively used in quantum information, but the core language here does not incoporate this symbol due to some confluence problems. Since transpose is involutive (i.e., $(B^\top)^\top = B$), we cannot encode the axiom $ (B \cdot K)^\top = K^\top \cdot B^\top$ in the naive term rewriting system. We discovered that the difficulty raises with coexistence of adjoint and transpose. We can alternatively have the transpose symbol only, but not both. In light of this, transpose is moved to the extended language, where equivalence are decided with more powerful techniques like ordered rewriting.


\section{Implementation and Case Study}

In order to test the capability of our design, we implemented the language and algorithm in \textit{Mathematica}, and experimented with a broad range of examples from different fields and topics in quantum computing. The result suggests that our language is capable to express many important statements, and can correctly decide all encoded problems efficiently.

\subsection{Mathematica Implementation}
Our tool implementation is provided as a program package written in the \textit{Wolfram Language} (i.e., Mathematica). 
% In general, the design of Mathematica can be considered as an extended version of \texttt{LISP}. 
Mathematica is a flexible functional programming language and implementation, where programs and states are encoded akin to LISP expressions, and calculations are powered by pattern matching and rewriting. Besides, it is an outstanding computer algebra system that can automatically solve a large scope of mathematical problems.

There are several reasons why we favor Mathematica over other languages like \texttt{Python} or \texttt{OCaml}.
One reason is, that universal algebra fits well in the LISP style calculation, and rewritings can be implemented directly by the built-in matching and substitution.
Another reason is the built-in algebra system for complex numbers. This relates to the decidability of reals: although we know that the real closed field is decidable, it does not include several symbols that often appear in quantum computing: $e^x$, $\mathrm{cos}(t)$, $\mathrm{sin}(t)$ and so on. The algebra system in Mathematica is a practical solution to it.
Thirdly, the flexibility of Mathematica enables convenient interactive deductions. For example, we can introduce customized constructions, e.g. partial trace and swap, and extend the expressiveness of the language at the runtime. Such flexibility also allows us to control the rewriting process, assist in the deduction by manually making involved rewritings when necessary.

We demonstrate the usage of our tool by the next example from \texttt{CoqQ}.

\begin{example}
  \label{ex: MMA}
Check the equivalence
  \[
    \mathrm{tr}_1(so2choi(\mathcal{E}) \cdot (X^\top \otimes I)) = \mathcal{E}(X),
  \]
where $\mathcal{E}$ is a quantum channel, $\mathrm{tr}_1(A)$ is the partial trace over the first subsystem of $A$, and $so2choi$ transform the super operator to its Choi representation.
\end{example}

Quantum channels are completely positive super operators, and we can encode it in the Kraus operator sum representation, meaning that $\mathcal{E}(X) = \sum_{i \in \mathbf{U}} E_i X E_i^\dagger$. Then we construct the two ``high-level'' functions using big operators:

  \begin{gather*}
    \mathrm{tr}_1(A) \equiv \sum_{i\in\mathbf{U}}\sum_{j\in\mathbf{U}} (\sum_{k\in\mathbf{U}} \bra{k, i} A \ket{k, j}) \ket{i}\bra{j},
    \qquad
    so2choi(E) \equiv \sum_{i\in\mathbf{U}}\sum_{j\in\mathbf{U}} \ket{i}\bra{j} \otimes (\sum_{k\in\mathbf{U}} E_k \ket{i}\bra{j} E_k^\dagger).
  \end{gather*}

  Finally the equivalence is checked automatically by the tool. See Fig.\ref{fig: MMA ex} for the code implementation.

\begin{figure*}
  \includegraphics*[width=0.8\textwidth]{MMAexample.png}
  \caption{The code encoding Example.\ref{ex: MMA} \yx{I can consider add pretty notation outputs to the code.}}
  \label{fig: MMA ex}
\end{figure*}

Actually, the equality also holds if $\mathcal{E}$ is a general super operator. But this cannot be checked for the time being, since our language does not yet directly support super operators.

\subsection{\texttt{CoqQ} Cases}

All 90 examples verified in 10 seconds.

\subsection{Circuit Cases}

\subsection{Quantum Program Cases}

\section{Conclusion and Future Work}

In this paper, we have presented an approach to automating formal deductions in a more general setting using Dirac notations. Our methodology leverages term rewriting systems to provide a robust, explainable framework with theoretical guarantees, which is critical for the performance and usability of formal tools in quantum computing.

We have demonstrated the implementation of our core language in Mathematica, verified various case studies, and shown the practical applicability of our approach. Our results affirm the soundness and completeness of the rewriting rules and their capability to handle complex calculations effectively.


Future Work:
\begin{itemize}
  \item \textbf{Rewriting Rules Optimization:} 
  Rearranging the rewriting rules in the core language to improve efficiency and scalability.
  \item \textbf{Language Extension:} 
  Incorporating more sorts (e.g., super operators), finer typing (e.g., unitary, Hermitian, positive operators), and more predicates (e.g., order judgement).
  \item \textbf{AI Intergration:} As future extensions make the formal system more and more sophisticated, we should introduce artificial intelligence and machine learning techniques to facilitate automated deduction, aiming to overcome the limitation in generating capability of traditional term rewriting systems.
\end{itemize}





%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\bibliographystyle{plain}
\bibliography{ref}

\clearpage
\appendix


\section{Core Language Syntax, Typing and Semantics (Full Version)}

\begin{definition} [atomic basis signature]
  The \textbf{atomic basis signature} $\Sigma_\mathcal{A}$ is a  typed finite language.
\end{definition}

Because we consider the tensor product structure, larger Hilbert spaces can be composed by the atomic ones, like the qubit Hilbert space. The atomic basis here characterize the basis of the atomic Hilbert spaces.
We limit the basis signature to finite languages to avoid problems of infinite dimensions.

\begin{definition} [complex number signature]
  The \textbf{complex number signature} $\Sigma_\mathcal{C}$ contains at least constant symbols $0, 1$, a unary symbol $*$ and binary symbols $+, \times$.
\end{definition}

Following the idea of the avatar lemma, the two signatures $\Sigma_\mathcal{A}$ and $\Sigma_\mathcal{C}$ characterize the language for atomic basis and complex numbers. 
The symbols for complex numbers are zero, one, conjugate, addition and multiplication respectively. Compared the avatar language in the Lineal paper\cite{Arrighi2017}, it adds the conjugate symbol since we need to deal with conjugate and inner product.
These symbols are only the least requirements as interfaces, and the real language to instantiate can contain more details. For example, the basis can contain symbols $0$ and $1$ for qubit spaces, and the complex numbers can still have exponential functions $e^x$ or square roots $\sqrt{x}$.


\begin{definition}[core language of Dirac Notation]
  The \textbf{core language of Dirac Notation}, denoted as $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, is a many-sorted language with dependent types, defined as follows.
  \begin{align*}
    & \textbf{Kinds} && \textrm{(basis kind)} && P ::= \texttt{Atom}\ |\ P * P, \\
    & && \textrm{(Dirac kind)} && D ::= \texttt{Scalar}\ |\ \texttt{Ket}\ |\ \texttt{Bra}\ |\ \texttt{Operator}, \\
    \\
    & \textbf{Types} && \textrm{(basis types)} && \sigma ::= x\ |\ A\ |\ \sigma \times \sigma\ |\ \pi_1(\sigma)\ |\ \pi_2(\sigma)\ |\ \pi_K(T)\ |\ \pi_B(T)\ |\ \type(t), \\
    & && \textrm{(Dirac types)} && T ::= x\ |\ \Sc\ |\ \K(\sigma)\ |\ \B(\sigma)\ |\ \Op(\sigma, \sigma)\ |\ \type(S)\ |\ \type(K)\ |\ \type(B)\ |\ \type(O), \\
    \\
    & \textbf{Terms} && \textrm{(complex number)} && \alpha \in \Sigma_\mathcal{C}, \\
    & && \textrm{(basis)} && t ::= x\ |\ a\ |\ (t, t)\ |\ \fst t\ |\ \snd t, \\
    & && \textrm{(scalar)} && S ::= x\ |\ C(\alpha)\ |\ \delta_{t, t}\ |\ S + S\ |\ S \times S\ |\ S^*\ |\ B \cdot K, \\
    & && \textrm{(ket)} && K ::= x\ |\ \mathbf{0}_\mathcal{K}(\sigma)\ |\ \ket{t}\ |\ B^\dagger\ |\ S.K\ |\ K + K\ |\ O \cdot K\ |\ K \otimes K, \\
    & && \textrm{(bra)} && B ::= x\ |\ \mathbf{0}_\mathcal{B}(\sigma)\ |\ \bra{t}\ |\ K^\dagger\ |\ S.B\ |\ B + B\ |\ B \cdot O\ |\ B \otimes B, \\
    & && \textrm{(operator)} && O ::= x\ |\ \mathbf{0}_\mathcal{O}(\sigma, \sigma)\ |\ \mathbf{1}_\mathcal{O}(\sigma)\ |\ K \otimes B\ |\ O^\dagger\ |\ S.O\ |\ O + O\ |\ O \cdot O\ |\ O \otimes O.
  \end{align*}
  Here we use $x$ to represent variables, $a$ to represent atomic basis in $\Sigma_\mathcal{A}$, lower case letters like $s, t$ to represent basis from $\mathcal{E}$, and Greek letters like $\alpha$ to represent complex number terms from $\Sigma_\mathcal{C}$. We use letters $S$, $K$, $B$, $O$ and their variants to represent terms from the scalar, ket, bra and operator sorts repsectively.
\end{definition}

\subsection{Context and Typing}

\begin{definition}[context]
  A \textbf{typing assumption} is written as $x : X$, meaning that variable $x$ is of type $X$. A \textbf{context} $\Gamma$ is an ordered list of typing assumptions. We write $x : X \in \Gamma$ if the typing assumption is contained in context $\Gamma$, and $x \in \Gamma$ if there exists a typing assumption of $x$ contained in $\Gamma$.
\end{definition}


We define simultaneously two judgement. One is $\mathcal{WF}(\Gamma)$, meaning that a context is \textbf{well-formed}. And the second one is a \textbf{typing judgement} written as $\Gamma \vdash e : X$, indicating that $e$ is an expression of type $X$ in context $\Gamma$.
We say the term $e$ is a \textbf{well-typed} term in context $\Gamma$ if $\Gamma \vdash e : X$ is a typing judgement for some $X$.

Well-formed contexts can be constructed starting with an empty context, and continuously appending unique variables with proved typing judgements.

\textsc{(Well-formed Context)}
\begin{gather*}
  \frac{}{\mathcal{WF}([])}
  \qquad
  \frac{\Gamma \vdash T : X \qquad x \notin \Gamma}{\mathcal{WF}(\Gamma :: (x : T))}
\end{gather*}

The typing judgements can be proved by the typing rules in the below.

\textsc{(Context)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma) \qquad x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}
\end{gather*}

\textsc{(Basis Type)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash A : \texttt{Atom} }
  \qquad
  \frac{\Gamma \vdash \sigma_1 : P_1 \qquad \Gamma \vdash \sigma_2 : P_2}{\Gamma \vdash \sigma_1 \times \sigma_2 : P_1 * P_2}
  \qquad
  \frac{\Gamma \vdash \sigma : P_1 * P_2}{\Gamma \vdash \pi_1(\sigma) : P_1}
  \qquad
  \frac{\Gamma \vdash \sigma : P_1 * P_2}{\Gamma \vdash \pi_2(\sigma) : P_2} \\
  \\
  \frac{\Gamma \vdash T : \K(\sigma)}{\Gamma \vdash \pi_K(T) : P}
  \qquad
  \frac{\Gamma \vdash T : \B(\sigma)}{\Gamma \vdash \pi_B(T) : P} \qquad
  \frac{\Gamma \vdash T : \Op(\sigma_1, \sigma_2)}{\Gamma \vdash \pi_K(T) : P_1}
  \qquad
  \frac{\Gamma \vdash T : \Op(\sigma_1, \sigma_2)}{\Gamma \vdash \pi_B(T) : P_2}
  \qquad
  \frac{\Gamma \vdash t : \sigma}{\Gamma \vdash \type(t) : P}
\end{gather*}

\textsc{(Dirac Type)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash \Sc : \texttt{Scalar}}
  \qquad
  \frac{\Gamma \vdash \sigma : P}{\Gamma \vdash \K(\sigma) : \texttt{Ket}}
  \qquad
  \frac{\Gamma \vdash \sigma : P}{\Gamma \vdash \B(\sigma) : \texttt{Bra}}
  \qquad
  \frac{\Gamma \vdash \sigma_1 : P_1 \qquad \Gamma \vdash \sigma_2 : P_2}{\Gamma \vdash \Op(\sigma_1, \sigma_2) : \texttt{Operator}} \\
  \\
  \frac{\Gamma \vdash S : \Sc}{\Gamma \vdash \type(S) : \texttt{Scalar}}
  \qquad
  \frac{\Gamma \vdash K : \K(\sigma)}{\Gamma \vdash \type(K) : \texttt{Ket}}
  \qquad
  \frac{\Gamma \vdash B : \B(\sigma)}{\Gamma \vdash \type(B) : \texttt{Bra}}
  \qquad
  \frac{\Gamma \vdash O : \Op(\sigma_1, \sigma_2)}{\Gamma \vdash \type(O) : \texttt{Operator}}
\end{gather*}

\textsc{(Basis)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma) \qquad a \text{ is an atomic basis of } A}{\Gamma \vdash a : A} \\
  \\
  \frac{\Gamma \vdash s : \tau \qquad \Gamma \vdash t : \sigma}{\Gamma \vdash (s, t) :  \tau \times \sigma }
  \qquad
  \frac{\Gamma \vdash \sigma : P_1 * P_2 \qquad \Gamma \vdash s : \sigma }{\Gamma \vdash \fst s : \pi_1(\sigma)}
  \qquad
  \frac{\Gamma \vdash \sigma : P_1 * P_2 \qquad \Gamma \vdash s : \sigma }{\Gamma \vdash \snd s : \pi_2(\sigma)}
\end{gather*}

\textsc{(Complex Scalar)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash C(\alpha) : \Sc}
  \qquad
  \frac{\Gamma \vdash s : \sigma \qquad \Gamma \vdash t : \sigma}{\Gamma \vdash \delta_{s, t} : \Sc} \\
  \\
  \frac{\Gamma \vdash S_1 : \Sc \qquad \Gamma \vdash S_2 : \Sc }{\Gamma \vdash S_1 + S_2 : \Sc }
  \qquad
  \frac{\Gamma \vdash S_1 : \Sc \qquad \Gamma \vdash S_2 : \Sc}{\Gamma \vdash S_1 \times S_2 : \Sc}
  \qquad
  \frac{\Gamma \vdash S : \Sc}{\Gamma \vdash S^* : \Sc}
  \qquad
  \frac{\Gamma \vdash B: \B(\tau) \qquad \Gamma \vdash K : \K(\tau) }{\Gamma \vdash B \cdot K : \Sc }
\end{gather*}

\textsc{(Ket)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash \mathbf{0}_{\mathcal{K}}(\tau) : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \ket{t} : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash K : \K(\tau)}{\Gamma \vdash K^\dagger : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash K : \K(\tau)}{\Gamma \vdash a . K : \K(\tau)} \\
  \\
  \frac{\Gamma \vdash K_1 : \K(\tau) \qquad \Gamma \vdash K_2 : \K(\tau) }{\Gamma \vdash K_1 + K_2 : \K(\tau) }
  \qquad
  \frac{\Gamma \vdash O : \Op(\tau, \rho) \qquad \Gamma \vdash K : \K(\rho) }{\Gamma \vdash O \cdot K : \K(\tau) }
  \qquad
  \frac{\Gamma \vdash K_1 : \K(\tau) \qquad \Gamma \vdash K_2 : \K(\rho) }{\Gamma \vdash K_1 \otimes K_2 : \K(\tau \times \rho)}
\end{gather*}

\textsc{(Bra)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash \mathbf{0}_{\mathcal{B}}(\tau) : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \bra{t} : \B(\tau)}
  \qquad
  \frac{\Gamma \vdash B : \B(\tau)}{\Gamma \vdash B^\dagger : \K(\tau)}
  \qquad
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash B : \B(\tau)}{\Gamma \vdash a . B : \B(\tau)} \\
  \\
  \frac{\Gamma \vdash B_1 : \B(\tau) \qquad \Gamma \vdash B_2 : \B(\tau) }{\Gamma \vdash B_1 + B_2 : \B(\tau) }
  \qquad
  \frac{\Gamma \vdash B : \B(\tau) \qquad \Gamma \vdash O : \Op(\tau, \rho) }{\Gamma \vdash B \cdot O : \B(\rho) } 
  \qquad
  \frac{\Gamma \vdash B_1 : \B(\tau) \qquad \Gamma \vdash B_2 : \B(\rho) }{\Gamma \vdash B_1 \otimes B_2 : \B(\tau \times \rho)}
\end{gather*}

\textsc{(Operator)}
\begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash \mathbf{0}_{\mathcal{O}}(\tau, \rho) : \Op(\tau, \rho)}
  \qquad
  \frac{\mathcal{WF}(\Gamma)}{\Gamma \vdash \mathbf{1}_{\mathcal{O}}(\tau) : \Op(\tau, \tau)}
  \qquad
  \frac{\Gamma \vdash K : \K(\tau) \qquad \Gamma \vdash B : \B(\rho) }{\Gamma \vdash K \otimes B : \Op(\tau, \rho)}
  \qquad
  \frac{\Gamma \vdash O : \Op(\tau, \rho)}{\Gamma \vdash O^\dagger : \Op(\rho, \tau)} \\
  \\
  \frac{\Gamma \vdash a : \Sc \qquad \Gamma \vdash O : \Op(\tau, \rho)}{\Gamma \vdash a . O : \Op(\tau, \rho)}
  \qquad
  \frac{\Gamma \vdash O_1 : \Op(\tau, \rho) \qquad \Gamma \vdash O_2 : \Op(\tau, \rho) }{\Gamma \vdash O_1 + O_2 : O(\tau, \rho) } \\
  \\
  \frac{\Gamma \vdash O_1 : \Op(\tau, \rho) \qquad \Gamma \vdash O_2 : \Op(\rho, \sigma) }{\Gamma \vdash O_1 \cdot O_2 : \Op(\tau, \sigma) }
  \qquad
  \frac{\Gamma \vdash O_1 : \Op(\tau_1, \rho_1) \qquad \Gamma \vdash O_2 : \Op(\tau_2, \rho_2) }{\Gamma \vdash O_1 \otimes O_2 : \Op(\tau_1 \times \tau_2, \rho_1 \times \rho_2)}
\end{gather*}


We make the modularity explicit by separating the complex number sort $\mathcal{C}$ from the scalar sort $\mathcal{S}$ in Dirac notations. It is necessary because the scalar language is defined by mutual induction with ket, bra and basis, which does not appear in standard language of complex. This also indicates the joint position in the term rewriting system: the rules for complex numbers can vary in different cases of $\sum_\mathcal{C}$, and our work on Dirac notations is to design the general rewriting rules involving inner products and Kronecker-Delta expressions. Separating the two languages allows us to apply the avatar lemma in theoretical analysis. From the implementation level, it means we can directly utilize different solvers that focus on complex numbers, and extend the language of complex numbers easily by modifying $\sum_\mathcal{C}$.

The same discussion applies for the language of basis. The atomic basis describes every individual subsystem in the physical level. The pairing and projections are for basis in Hilbert space with tensor products, which lie in the logic level.

We can consider possible candidates for instantiating $\Sigma_\mathcal{C}$, which touches the decidability problem of reals. Beyond the weakest one, the avatar $\{0, 1, *, +, \times\}$ itself \yx{any theorems on this one?}, we can also try to add symbols pervasively used in quantum, such as exponential functions, trigonometric functions and square/square root.

The choice of the atomic basis language $\Sigma_\mathcal{A}$ has large freedom and can be suited to different scenarios. Besides introducing constant symbols (e.g., $0$ and $1$ basis), richer language with operations on basis terms are also possible. 


Although we use the same characters in different sorts ($B \cdot K$ and $O \cdot K$, for example), they are actually different symbols and can be easily distinguished from the context. This is also reflected in the \texttt{CiME2} script. 

The language is intended to be used in the multi-sorted manner, but in the proof of confluence property, we check the unsorted version. The unsorted version simply removes all sort constraints, and its confluence is equivalent to that of the multi-sorted version, which is the persistancy proved in \cite{Aoto1997}.



\subsection{Denotational Semantics}

Denotational semantics explain the formal language as a process of calculation, where each expression $e$ is finally mapped to a mathematical object written as $\sem{e}$.
Because our language have a hierechy of types, the denotational semantics should reflect the typing relation: types are interpreted as the domain sets, and the typing judgement should be interpreted as set-theoretical membership. This is the consistency requirement we will stick to in the below.

\begin{definition}[typing consistency]
  For any context $\Gamma$, expression $e$ and type $T$, if $\Gamma \vdash e : T$, then $\sem{e} \in \sem{T}$.
\end{definition}

A valuation is also necessary for specifying the interpretation. The valuation $v$ maps all variables $x$ to their interpretation $v(x)$. The semantics of $e$ under valuation $v$ is written as $\sem{e}^v$, and we omit $v$ when it is obvious or assumed.
The valuations satisfying typing consistency are called \textbf{valid} valuations defined below.
\begin{definition}[valid valuation]
  A valuation $v$ is valid in well-formed context $\Gamma$ if for all $x : T \in \Gamma$, $v(x) \in \sem{T}^v$.
\end{definition}

In the following, we give the denotational semantics of core language $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$. We assume a well-formed context $\Gamma$ and a valid valuation $v$, and only consider the well-typed expressions.

\begin{definition}
  The set of all domains for the semantical interpretation of types in $\Sigma_{\mathcal{A}}$ is written as $\mathcal{A}$.
\end{definition}

\begin{definition}[semantics of kinds] The semantics of kinds are defined as sets of domains as follows:

  \begin{align*}
    & \sem{\texttt{Atom}} \equiv \mathcal{A},
    \qquad
    && \sem{P_1 * P_2} \equiv \{ S_1 \times S_2 : S_1 \in \sem{P_1}, S_2 \in \sem{P_2} \}, \\
    \\
    & \sem{\texttt{Scalar}} \equiv \{ \mathbb{C} \},
    \qquad
    && \sem{\texttt{Ket}} \equiv \{ \mathcal{H}_{\sem{P}} : P \text{ is a basis kind} \}, \\
    & \sem{\texttt{Bra}} \equiv \{ \mathcal{H}^*_{\sem{P}} : P \text{ is a basis kind} \},
    \qquad
    && \sem{\texttt{Operator}} \equiv \{ \textsf{Hom}(S_1, S_2) : S_1, S_2 \in \sem{\texttt{Ket}} \}.
  \end{align*}
\end{definition}

Basis types and Dirac types as terms have their types in kinds. The semantics of types are defined as domains, and should be contained in the semantics of kinds. Therefore, kinds are interpreted as sets of domains. \texttt{Atom} is interpreted as the set $\mathcal{A}$ of all different domains from the atomic basis language, and the kind $P_1 * P_2$ contains all different Cartesian products from $P_1$ and $P_2$. The semantics of \texttt{Ket}, \texttt{Bra} and \texttt{Operator} are defined as the set of all Hilbert spaces, Dual spaces and Homomorphisms, respectively.


\begin{definition}[semantics of types]
  The semantics of basis types are defined as domain sets as follows:
  \begin{align*}
    & \begin{aligned}
      & \sem{A} \equiv \sem{A}_\mathcal{A},
      \qquad
      && \sem{\sigma_1 \times \sigma_2} \equiv \sem{\sigma_1} \times \sem{\sigma_2}, \\
      & \sem{\pi_1(\sigma)} \equiv S_1 \qquad \text{(where $\sem{\sigma} = S_1 \times S_2$)},
      && \sem{\pi_2(\sigma)} \equiv S_2 \qquad \text{(where $\sem{\sigma} = S_1 \times S_2$)}, \\
      & \sem{\pi_K(T)} \equiv \left\{
        \begin{array}{ll}
          S, & \text{ where } \sem{T} = \mathcal{H}_S, \\
          S_1, & \text{ where } \sem{T} = \textsf{Hom}(S_1, S_2),
        \end{array}
      \right.
      && \sem{\pi_B(T)} \equiv \left\{
        \begin{array}{ll}
          S, & \text{ where } \sem{T} = \mathcal{H}^*_S, \\
          S_2, & \text{ where } \sem{T} = \textsf{Hom}(S_1, S_2),
        \end{array}
      \right.
    \end{aligned} \\
    \\
    & \begin{aligned}
      \sem{\Sc} \equiv \mathbb{C},
      \qquad
      \sem{\K(\sigma)} \equiv \mathcal{H}_{\sem{\sigma}}, 
      \qquad 
      \sem{\B(\sigma)} \equiv \mathcal{H}^*_{\sem{\sigma}},
      \qquad
      \sem{\Op(\sigma, \tau)} \equiv \textsf{Hom}(\sem{\sigma}, \sem{\tau}),
    \end{aligned} \\
    \\
    & \begin{aligned}
      \sem{\texttt{type}(t)} \equiv \sem{T} \qquad \text{(where $\Gamma \vdash t : T$)}
    \end{aligned}
  \end{align*}
\end{definition}

Because we only consider well-typed terms, the semantics are always well-defined.


\begin{definition}[semantics of basis]
  For atomic basis $\Sigma_\mathcal{A}$ with domain $A$, the domain of basis $\mathcal{E}$ is the binary tree algebra over $A$, which is defined as 
  $
  \mathcal{D}_\mathcal{E} = \mu X.(A \cup (X \times X)),
  $
  the smallest set that contains $A$ and is closed under Cartesian product.

  The semantics of symbols in $\mathcal{E}$ are defined as follows:
  \begin{align*}
    & \text{(Atomic Basis)} && \sem{a} \equiv \sem{a}_\mathcal{A}, \\
    & \text{(Pairing)} &&
    \sem{(t_1, t_2)} \equiv (\sem{t_1}, \sem{t_2}), \\
    & \text{(First Projection)} &&
    \sem{\fst t} \equiv x_1 \qquad (\text{where } \sem{t} = (x_1, x_2)), \\
    & \text{(Second Projection)} &&
    \sem{\snd t} \equiv x_2 \qquad (\text{where } \sem{t} = (x_1, x_2))
  \end{align*}
\end{definition}


% The semantics for Dirac notations are based on linear algebra, but some explanation on typing is necessary here. In mathematics we commonly distinguish linear spaces with different sizes, which corresponds to a more meticulous type system with basis set information. But our internal language only use sorts to represent vectors or operators, and the space itself is untyped. It is equivalent to say that we consider only one universal linear space. On the one hand, it can be understood as the direct sum of all different, typed linear spaces. On the other hand, it is the linear space with basis set $\mathcal{D}_\mathcal{E}$. From the isomorphism $\mathcal{H}_{A\cup B} \cong \mathcal{H}_A \oplus \mathcal{H}_B$, $\mathcal{H}_{A \times B} \cong \mathcal{H}_A \otimes \mathcal{H}_B$, we have
% $$
% \mathcal{H}_{\mathcal{D}_\mathcal{E}} = \mathcal{H}_{\mu X.(A\cup (X \times X))} \cong \mu V. \mathcal{H}_A \oplus (V \otimes V).
% $$


\begin{definition}[semantics of scalar]
  The domain of scalars $\mathcal{D}_\mathcal{S} = \mathbb{C}$ is the complex field.
  The semantics of the symbols are defined as follows:
  \begin{align*}
    & \text{(Complex Number)} &&
    \sem{C(\alpha)} \equiv \sem{\alpha}_\mathcal{C}, \\
    & \text{(Kronecker Delta)} &&
    \sem{\delta_{s, t}} \equiv \left\{
      \begin{array}{ll}
        1, & \text{where } \sem{s} = \sem{t}, \\
        0, & \text{where } \sem{s} \neq \sem{t}, 
      \end{array}
    \right. \\
    & \text{(Addition)} &&
    \sem{S_1 + S_2} \equiv \sem{S_1} + \sem{S_2}, \\
    & \text{(Multiplication)} &&
    \sem{S_1 \times S_2} \equiv \sem{S_1} \times \sem{S_2}, \\
    & \text{(Conjugate)} &&
    \sem{S^*} \equiv \sem{S}^*, \\
    & \text{(Inner Product)} &&
    \sem{B \cdot K} \equiv \langle \sem{B}^*, \sem{K} \rangle.
  \end{align*}
\end{definition}

Note that we use the symbol $C(\alpha)$ to introduce complex numbers as scalars.
One interesting decision is the explanation for Dirac notation inner product $B \cdot K$. An other possibility is to let $\sem{B \cdot K} \equiv \langle \sem{B}, \sem{K} \rangle$, which may be closer to the inner product in linear algebra. The two explanations only differ in the convention sense. Our choice sets Dirac notation inner product linear on the bra $B$, which makes the rewriting rules of bra and ket more symmetric. Also, it enables easier equivalence checking for transpose in the extended language.


\begin{definition}[semantics of ket/bra]
  The domain for the semantics of ket and bra are $\mathcal{H}_{\mathcal{D}_\mathcal{E}}$ and $\mathcal{H}_{\mathcal{D}_\mathcal{E}}^*$ respectively.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Vector)} &&
    \sem{\mathbf{0}_\mathcal{K}(\sigma)} \equiv \mathbf{0} && \sem{\mathbf{0}_\mathcal{B}(\sigma)} \equiv \mathbf{0}^*, \\
    & \text{(Basis Vector)} &&
    \sem{\ket{t}} \equiv \mathbf{e}_t && \sem{\bra{t}} \equiv \mathbf{e}^t, \\
    & \text{(Adjoint)} &&
    \sem{B^\dagger} \equiv \sem{B}^* && \sem{K^\dagger} \equiv \sem{K}^*, \\
    & \text{(Scalar Multiplication)} &&
    \sem{S.K} \equiv \sem{S} \sem{K} && \sem{S.B} \equiv \sem{S} \sem{B}, \\
    & \text{(Addition)} &&
    \sem{K_1 + K_2} \equiv \sem{K_1} + \sem{K_2} && \sem{B_1 + B_2} \equiv \sem{B_1} + \sem{B_2}, \\
    & \text{(Linear Operator)} &&
    \sem{O \cdot K} \equiv \sem{O} \cdot \sem{K} && \sem{B \cdot O} \equiv (\sem{O}^\dagger \cdot \sem{B}^*)^*, \\
    & \text{(Tensor Product)} &&
    \sem{K_1 \otimes K_2} \equiv \sem{K_1} \otimes \sem{K_2} && \sem{B_1 \otimes B_2} \equiv \sem{B_1} \otimes \sem{B_2}.
  \end{align*}
\end{definition}



\begin{definition}[semantics of operator]
  The domain for the semantics of operators is the homomorphism $\mathcal{D}_\mathcal{O} = \textrm{Hom}(\mathcal{H}_{\mathcal{D}_\mathcal{E}}, \mathcal{H}_{\mathcal{D}_\mathcal{E}})$.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Operator)} &&
    \sem{\mathbf{0}_\mathcal{O}(\sigma, \tau)} \equiv \mathbf{0}_{\textrm{op}}, \\
    & \text{(Identity Operator)} &&
    \sem{\mathbf{1}_\mathcal{O}(\sigma)} \equiv \mathbf{I}, \\
    & \text{(Outer Product)} &&
    \sem{K \otimes B} \equiv \lambda \mathbf{v}. \langle \sem{B}^*, \mathbf{v}\rangle \sem{K}, \\
    & \text{(Adjoint)} &&
    \sem{O^\dagger} \equiv \sem{O}^\dagger, \\
    & \text{(Scalar Operator)} &&
    \sem{S.O} \equiv \sem{S} \sem{O}, \\
    & \text{(Addition)} &&
    \sem{O_1 + O_2} \equiv \sem{O_1}+\sem{O_2}, \\
    & \text{(Operator Multiplication)} &&
    \sem{O_1 \cdot O_2} \equiv \sem{O_1} \cdot \sem{O_2}, \\
    & \text{(Tensor Product)} &&
    \sem{O_1 \otimes O_2} \equiv \sem{O_1} \otimes \sem{O_2},
  \end{align*}
\end{definition}


\subsubsection*{Example}


\newcommand{\tr}{\mathrm{tr}}
\newcommand{\pass}{\textcolor{blue}{\textbf{ [PASS] }}}
\newcommand{\fail}{\textcolor{red}{\textbf{ [FAIL] }}}

\section{Example List}

\subsection{Textbook Examples}

\begin{example}[QCQI (2.10)] \pass
  $$
  A\left( \sum_i a_i \ket{v_i} \right) = \sum_i a_i A(\ket{v_i}).
  $$
\end{example}

\begin{example}[QCQI (2.13)] \pass
  $$
  \left( \ket{v}, \sum_i \lambda_i \ket{w_i} \right) = \sum_i \lambda_i (\ket{v}, \ket{w_i}).
  $$
  $$
  (\ket{v}, \ket{w}) = (\ket{w}, \ket{v})^*.
  $$
\end{example}

\begin{example}[QCQI Exercise 2.6] \pass
  $$
  \left( \sum_i \lambda_i \ket{w_i}, \ket{v} \right) = \sum_i \lambda_i^* (\ket{w_i}, \ket{v}).
  $$
\end{example}

\begin{example}[QCQI (2.18)] \pass
  For orthonormal basis $\ket{i}$,
  $$
  \left( \sum_i v_i \ket{i}, \sum_j w_j \ket{j} \right) = \sum_{ij}v_i^*w_j \delta_{ij} = \sum_i v_i^* w_i.
  $$
\end{example}

\begin{example}[QCQI (2.21)] \pass
  $$
  \left( \sum_i \ket{i}\bra{i} \right) \ket{v} = \sum_i \ket{i} \braket{i|v}.
  $$
  Notice the slippery informal expression here. $\ket{v}$ should actually be $v$.
\end{example}

\begin{example}[QCQI (2.22)] \pass
  $$
  \sum_i\ket{i}\bra{i} = I.
  $$
  (In our language, identity operator $I$ will be a symbol.a)
\end{example}


\begin{example}[QCQI (2.24-2.25)] \pass
  $$
  \sum_{ij} \ket{w_j}\bra{w_j}A\ket{v_i}\bra{v_i} = \sum_{ij}\bra{w_j}A\ket{v_i}\ket{w_j}\bra{v_i}.
  $$
\end{example}

\begin{example}[QCQI (2.26)] \pass
  $$
  \braket{v|v}\braket{w|w} = \sum_i\braket{v|i}\braket{i|v}\braket{w|w}.
  $$
\end{example}
\textbf{Remark:} need to detect $\sum_{i\in\mathbf{U}}\ket{i}\bra{i} \to \mathbf{1}_\mathcal{O}$.

\begin{example}[QCQI Exercise 2.14] \pass
  $$
  \left( \sum_i a_i A_i \right)^\dagger = \sum_i a_i^* A_i^\dagger.
  $$
\end{example}

\begin{example}[QCQI Exercise 2.16] \pass
  Show that any projector $P\equiv \sum_{i=1}^k \ket{i}\bra{i}$ satisfies the equation $P^2=P$.
\end{example}

\begin{example}[QCQI (2.46)] \pass
  $$
    (A \otimes B)\left(\sum_i a_i \ket{v_i}\otimes\ket{w_i}\right) \equiv \sum_i a_i A \ket{v_i} \otimes B\ket{w_i}.
  $$
\end{example}

\begin{example}[QCQI (2.49)] \pass
  $$
    \left(\sum_i a_i \ket{v_i}\otimes\ket{w_i}, \sum_j b_j \ket{v'_j}\otimes \ket{w'_j}\right) \equiv \sum_{ij}a_i^*b_j\braket{v_i|v'_j}\braket{w_i|w'_j}.
  $$
\end{example}

\begin{example}[QCQI (2.61)] \pass
  $$
    \sum_i\bra{i}A\ket{\psi}\braket{\psi|i} = \bra{\psi}A\ket{\psi}.
  $$
\end{example}

% \begin{example}[QCQI Exercise 2.43] \fail
%   Show that for $j,k = 1,2,3$,
%   $$
%     \sigma_j\sigma_k = \delta_{jk}I + i\sum_{l=1}^3\epsilon_{jkl}\sigma_l.
%   $$
%   This can be checked with the help of Mathematica.
% \end{example}

\begin{example}[QCQI (2.128)] \pass
  $$
    \sum_{m',m''}\bra{\psi}M_m^\dagger\bra{m'}(I\otimes\ket{m}\bra{m})M_{m''}\ket{\psi}\ket{m''} = \bra{\psi}M_m^\dagger M_m\ket{\psi}.
  $$
\end{example}

\begin{example}[QCQI Theorem 4.1] \pass
  Suppose $U$ is a unitary operation on a single qubit. Then there exist real numbers $\alpha, \beta, \gamma$ and $\delta$ such that $$
  U = \left[
  \begin{array}{cc}
  e^{i(\alpha - \beta/2 - \delta/2)} \cos \frac{\gamma}{2} & -e^{i(\alpha - \beta/2 + \delta/2)} \sin \frac{\gamma}{2} \\
  e^{i(\alpha + \beta/2 - \delta/2)} \sin \frac{\gamma}{2} & e^{i(\alpha + \beta/2 + \delta/2)} \cos \frac{\gamma}{2}
  \end{array}
  \right]
  = e^{i\alpha}R_z(\beta)R_y(\gamma)R_z(\delta),
  $$
  where
\[
  R_x(\theta) \equiv
  \begin{bmatrix}
  \cos \frac{\theta}{2} & -i \sin \frac{\theta}{2} \\
  -i \sin \frac{\theta}{2} & \cos \frac{\theta}{2}
  \end{bmatrix}
  \qquad
  R_y(\theta) \equiv
  \begin{bmatrix}
  \cos \frac{\theta}{2} & -\sin \frac{\theta}{2} \\
  \sin \frac{\theta}{2} & \cos \frac{\theta}{2}
  \end{bmatrix}
  \qquad
  R_z(\theta) \equiv
  \begin{bmatrix}
  e^{-i \theta / 2} & 0 \\
  0 & e^{i \theta / 2}
  \end{bmatrix}
  \]
  are the rotation gates.
\end{example}


\subsection{Operation on maximally entangled state}
\begin{example} \pass
  Assume $S$ and $T$ are subsystems on Hilbert space $\mathcal{H}_T$ and $\ket{\Phi}_{S,T} = \sum_i \ket{i}\ket{i}$ is a maximally entangled state. Then for all operators $A\in\mathcal{L}(\mathcal{H}_T, \mathcal{H}_T)$, we have 
  $$
  A_S\ket{\Phi}_{S, T} = A_T^\top\ket{\Phi}_{S, T}.
  $$
\end{example}


\subsection{CoqQ Examples}
\begin{definition}
  Some high-level operators are encoded as follows.  
  \begin{gather*}
    \tr(A) \equiv \sum_{i\in\mathbf{U}} \bra{i} A \ket{i} \\
    SWAP(A) \equiv \sum_{i\in\mathbf{U}}\sum_{j\in\mathbf{U}}\sum_{k\in\mathbf{U}}\sum_{l\in\mathbf{U}} \bra{i, j} A \ket{k, l} \ket{j, i}\bra{l, k} \\
    \tr_1(A) \equiv \sum_{i\in\mathbf{U}}\sum_{j\in\mathbf{U}} (\sum_{k\in\mathbf{U}} \bra{k, i} A \ket{k, j}) \ket{i}\bra{j} \\
    \tr_2(A) \equiv \sum_{i\in\mathbf{U}}\sum_{j\in\mathbf{U}} (\sum_{k\in\mathbf{U}} \bra{i, k} A \ket{j, k}) \ket{i}\bra{j} \\
    so2choi(E) \equiv \sum_{i\in\mathbf{U}}\sum_{j\in\mathbf{U}} \ket{i}\bra{j} \otimes (\sum_{k\in\mathbf{U}} E_k \ket{i}\bra{j} E_k^\dagger) \\
    krausso(M, f)(X) \equiv \sum_{i \in M} f_i \cdot X \cdot f_i^\dagger \\
    elemso(f, k)(X) \equiv f_k \cdot X \cdot f_k^\dagger \\
    dualqm(M, f)(O) \equiv \sum_{i\in M} f_i^\dagger \cdot O_i \cdot f_i
  \end{gather*}
\end{definition}

Note: the identity operator is encoded as $\sum_{i \in \mathbf{U}}\ket{i}\bra{i}$, not $\mathbf{1}_\mathcal{O}$. They are different.

(In the order of their appearance in CoqQ.)
\begin{enumerate}
  \item \pass $\bra{p}A\ket{i}\braket{j|q} = \delta_{j,q}\bra{p}A\ket{i}$
  \item \pass $\bra{p}(\ket{i}\bra{j}A)\ket{q} = \delta_{i, p}\bra{j}A\ket{q}$
  \item \pass $\bra{i}M^*\ket{j} = \bra{i}M\ket{j}^*$
  \item \pass $\bra{i}M^\dagger\ket{j} = \bra{j}M\ket{i}^*$
  \item \pass $(a A + B)^* = a^* A^* + B^*$
  \item \pass $(A+B)^\dagger = A^\dagger + B^\dagger$
  \item \pass $(c A)^\dagger = c^* A^\dagger$
  \item \pass $(c A + B)^\dagger = c^* A^\dagger + B^\dagger$
  \item \pass $(A \cdot B)^\dagger = B^\dagger \cdot A^\dagger$
  \item \pass $(M^\dagger)^\dagger = M$
  \item \pass $(aI)^\dagger = a^* I$
  \item \pass $(1 I)^\dagger = I$
  \item \pass $(\ket{i}\bra{j})^* = \ket{i}\bra{j}$
  \item \pass $(\ket{i}\bra{j})^\dagger = \ket{j}\bra{i}$
  \item \pass $M^\top = (M^*)^\dagger$
  \item \pass $M^\top = (M^\dagger)^*$
  \item \pass $M^* = (M^\dagger)^\top$
  \item \pass $\tr(M^\dagger) = \tr(M)^*$
  \item \pass $\tr(M^*) = \tr(M)^*$
  \item \pass $(\bra{i}M)^\dagger = M^\dagger \ket{i}$
  \item \pass $(M \ket{i})^\dagger = \bra{i} M^\dagger$
  \item \pass $\bra{u} \left( \sum_{i} a_i \ket{i}\bra{i} \right) \ket{u} = \sum_i a_i \braket{u|i}\braket{i|u}$
  \item \pass $\bra{i}(A\cdot B^\dagger)\ket{j} = \bra{i} A (\bra{j}B)^\dagger$
  \item \pass $A \cdot B = \sum_i (A \ket{i})(\bra{i} B)$
  \item \pass $\bra{i}(\sum_{i \in \mathbf{U}} d_i \ket{i}\bra{i} A) = d_i \bra{i} A$
  \item \pass $\tr(A) = \sum_{i \in \mathbf{U}}\bra{i} A \ket{i}$
  \item \pass $\tr(A B) = \tr(B A)$ (entry expansion is critical here)
  \item \pass $\tr(c A + B) = c\ \tr(A) + \tr(B)$
  \item \pass $\tr(A^\dagger) = \tr(A)^*$
  \item \pass $\tr(A^\top) = \tr(A)$
  \item \pass $\tr(A^*) = \tr(A)^*$
  \item \pass $\tr(\ket{u}\bra{v}) = \braket{v|u}$
  \item \pass $\tr(\ket{u}\bra{v}) = \braket{v|u}$ ($u$, $v$ are arbitrary vectors)
  \item \pass $\sum_{i\in\mathbf{U}} \ket{i}\bra{i} = I$
  \item \pass $\ket{i}\bra{j}\cdot\ket{k}\bra{l} = \delta_{j,k}\ket{i}\bra{l}$
  \item \pass $\ket{i}\bra{j}\cdot\ket{j}\bra{k} = \ket{i}\bra{k}$
  \item \pass $\tr(A \ket{i}\bra{j}) = \bra{j} (A \ket{i})$
  \item \pass $A = \sum_{j\in\mathbf{U}}\sum_{i\in\mathbf{U}} \bra{i}(A\ket{j}) \ket{i}\bra{j}$
  \item \pass $\ket{v} = \sum_{i\in\mathbf{U}}(\braket{i|v})\ket{i}$
  \item \pass $(A\ket{u})\bra{v} = A(\ket{u}\bra{v})$
  \item \pass $\ket{u}(A\ket{v})^\dagger = (\ket{u}\bra{v})A^\dagger$
  \item \pass $\bra{b} = \sum_{i\in\mathbf{U}}(\braket{b|i}\bra{i})$
  \item \pass $(A\cdot B)\ v = A (B\ v)$
  \item \pass $\sum_{i}\sum_{j}F_i G_j A G_j^\dagger F_i^\dagger = \sum_i F_i (\sum_j G_j A G_j^\dagger) F_i^\dagger$
  \item \pass $(A\cdot B)\cdot C = A \cdot (B \cdot C)$
  \item \pass $\sum_i F_i \cdot (\sum_j \sum_k G_j \cdot H_k \cdot A \cdot H_k^\dagger \cdot G_j^\dagger) \cdot F_i^\dagger = \sum_i \sum_j F_i \cdot G_j \cdot (\sum_k H_k \cdot A \cdot H_k^\dagger) \cdot G_j^\dagger \cdot F_i^\dagger$
  \item \pass $A\cdot(a B + C) = a (A\cdot B) + (A\cdot C)$
  \item \pass $(A_1 + A_2)\cdot B = A_1 \cdot B + A_2 \cdot B$
  \item \pass $A \cdot (B_1 + B_2) = A \cdot B_1 + A \cdot B_2$
  \item \pass $(-A) \cdot B = - (A \cdot B)$
  \item \pass $A \cdot (-B) = - (A \cdot B)$
  \item \pass $(k A) \cdot B = k (A \cdot B)$
  \item \pass $A \cdot (k B) = k (A \cdot B)$
  \item \pass $(k A_1 + A_2) \cdot B = k (A_1 \cdot B) + A_2 \cdot B$
  \item \pass $A \cdot (k B_1 + B_2) = k (A \cdot B_1) + A \cdot B_2$
  \item \pass $A \cdot B \cdot C \cdot D = A \cdot (B \cdot C) \cdot D$
  \item \pass $\sum_i \sum_j br_{i, j} \cdot ((f_i \cdot (a X + Y)) \cdot f_i^\dagger \cdot br_{i, j}^\dagger) = \sum_i a \sum_j br_{i, j} \cdot ((f_i \cdot X) \cdot f_i^\dagger) \cdot br_{i, j}^\dagger + \sum_i \sum_j br_{i, j} \cdot ((f_i \cdot Y) \cdot f_i^\dagger) \cdot br_{i, j}^\dagger$
  \item \pass $c > 0 \to c \sum_i (f_i \cdot X \cdot f_i^\dagger) = \sum_i ((\sqrt{c} f_i \cdot X) \cdot (\sqrt{c} f_i^\dagger))$
  \item \pass $(M \otimes N)^\dagger = M^\dagger \otimes N^\dagger$
  \item \pass $\tr (M \otimes N) = \tr(M) \tr(N)$ (Index split is required)
  \item \pass $SWAP(SWAP(A))=A$
  \item \pass $A = \sum_{i \in \mathbf{U}} \bra{\fst i} A \ket{\snd i} \ket{\fst i} \bra{\snd i}$
  \item \pass $\sum_{i\in T} f_i \cdot (\sum_{j \in R} g_j \cdot X \cdot g_j^\dagger) \cdot f_i^\dagger = \sum_{i \in T\times R} f_{\fst k} \cdot g_{\snd k} \cdot X \cdot f_{\fst k}^\dagger \cdot g_{\snd k}^\dagger$
  \item \pass $SWAP(a X + Y) = a SWAP(X) + SWAP(Y)$
  \item \pass $SWAP(A\otimes B) = B \otimes A$
  \item \pass $\tr(SWAP(A)) = \tr(A)$
  \item \pass $SWAP(A \cdot B) = SWAP(A) \cdot SWAP(B)$
  \item \pass $SWAP(A)^\top = SWAP(A^\top)$
  \item \pass $SWAP(A)^\dagger = SWAP(A^\dagger)$
  \item \pass $\tr_2(A) = \tr_1(SWAP(A))$
  \item \pass $\tr_1(A) = \tr_2(SWAP(A))$
  \item \pass $\tr_2(c A + B) = c \tr_2(A) + \tr_2(B)$
  \item \pass $\tr(A) = \tr(\tr_2(A))$
  \item \pass $\tr(A) = \tr(\tr_1(A))$
  \item \pass $\tr_1 (A \cdot (I \otimes B)) = \tr_1 (A) \cdot B$
  \item \pass $I \otimes I = I$
  \item \pass $\bra{i} A \cdot B \ket{j} = \sum_{a\in\mathbf{U}} \sum_{b\in\mathbf{U}} \bra{i}A\ket{a,b}\bra{a,b}B\ket{j}$
  \item \pass $\bra{k,p} ((\ket{i}\bra{j} \otimes I) \cdot A) \ket{q} = \delta_{i, k} \bra{j, p} A \ket{q}$
  \item \pass $\bra{p} (A \cdot (\ket{i}\bra{j} \otimes I)) \ket{k, q} = \delta_{j, k} \bra{p} A \ket{i, q}$
  \item \pass $\tr_1(so2choi(E) \cdot (X^\top \otimes I)) = \sum_{k\in\mathbf{U}} E_k X E_k^\dagger$
  \item \fail $so2choi(a X + Y) =a\ so2choi(X) + so2choi(Y)$ ($aX + Y$ is not well formalized)
  \item \pass $\tr_2(A \cdot (B \otimes I)) = \tr_2(A) \cdot B$
  \item \pass $\tr (so2choi(E)\cdot (X^\top \otimes Y)) = \tr(E(X) \cdot Y)$
  \item \pass $\tr (E(X) \cdot A) = \tr (X \cdot E^*(A))$
  \item \pass $\tr (A \cdot E(X)) = \tr (E^*(X) \cdot A)$
  \item \pass $\sum_{i \in \mathbf{U}} \ket{v}\bra{i} X \ket{i}\bra{v} = \tr(X) * \ket{v}\bra{v}$
  \item \pass $\sum_{i \in \mathbf{U}} \ket{i}\bra{v}X\ket{v}\bra{i} = \bra{v}X\ket{v} I$
  \item \pass $\sum_{i \in M} elemso(f, i)(X) = krausso(M, f)(X)$
  \item \pass $\sum_{i \in M} \tr(elemso(f,i)(X)\cdot O_i) = \tr (X \cdot dualqm(M, f)(O))$
  \item \pass $\sum_{i \in M} \tr(O_i \cdot elemso(f,i)(X)) = \tr (dualqm(M,f)(O)\cdot X)$
\end{enumerate}

\subsection{PQC/Quantum Black Box Equivalence Checking}
\begin{figure*}[h]
  \includegraphics*[width=\textwidth]{QCQI.Fig4.5.png}
\end{figure*}

\begin{figure*}[h]
  \includegraphics*[width=\textwidth]{QCQI.Fig4.8.png}
\end{figure*}


\subsection{Semnatic Calculation of a Simple qWhile Program}
We formalized the small-step operational semantics of quantum while programs as a term rewriting system.
\begin{definition}[TRS for qWhile]
  \begin{align*}
    \langle \textbf{abort}, \rho \rangle &\longrightarrow \langle \textbf{Halt}, \textbf{0}_\mathcal{O} \rangle \\
    \langle \textbf{skip}, \rho \rangle &\longrightarrow \langle \textbf{Halt}, \rho \rangle \\
    \langle q :=0, \rho \rangle &\longrightarrow \langle \textbf{Halt}, \sum_{i \in \textbf{U}} (\ket{0}\otimes\bra{1})_{q;q} \cdot \rho \cdot (\ket{1}\otimes\bra{0})_{q;q} \rangle \\
    \langle U, \rho \rangle & \longrightarrow \langle \textbf{Halt}, U \cdot \rho \cdot U^\dagger \rangle \\
    \langle \textbf{if } P \textbf{ then } S_1 \textbf{ else } S_2 \textbf{ end}, \rho \rangle &\longrightarrow \{| \langle S_1, P \cdot \rho \cdot P \rangle, \langle S_2, (\mathbf{1}_\mathcal{O} + (-1).P) \cdot \rho \cdot (\mathbf{1}_\mathcal{O} + (-1).P)\rangle |\} \\
     & \vdots
  \end{align*}
  Note that the calculations of quantum states are represented by the syntax of Dirac notations defined above.
\end{definition}

\begin{example}
  $\langle \textbf{ while}^2\ (\ket{0}\otimes\bra{0})_q \textbf{ do } X_q\ \textbf{end}, (\ket{0}\otimes\bra{0})_q \rangle \longrightarrow \langle \textbf{ Halt}, (\ket{1}\otimes\bra{1})_q \rangle$
\end{example}

\textbf{Remark:} It should take 140 steps to complete the calculation!




\section{Labelled Dirac Notation}

\begin{definition}[quantum registers]
  \begin{align*}
    R ::= x\ |\ (R, R)\ |\ \fst R\ |\ \snd R
  \end{align*}
  We define the following relations for quantum registers:
  \begin{itemize}
    \item $R$ \textbf{belongs to} $Q$, written as $R\ \text{in}\ Q$,
    \item $R$ \textbf{is disjoint with} $Q$, written as $R \| Q$.
  \end{itemize}
\end{definition}

\textbf{Remark:} We still have a speical algorithm deciding the relations.

\begin{definition}[register set]
  \begin{align*}
    S ::= \emptyset\ |\ \{ R \} \ |\ S \cup S\ |\ S \setminus S
  \end{align*}
\end{definition}

\textbf{Remark: } $ S_1 \cap S_2 \equiv S_1 \cup S_2 \setminus (S_1 \setminus S_2) \setminus (S_2 \setminus S_1) $

\subsubsection*{\textsf{REG}}
\begin{gather*}
  \fst (R_1, R_2) \reduce R_1 \qquad 
  \snd (R_1, R_2) \reduce R_2 \qquad
  (\fst R, \snd R) \reduce R
\end{gather*}


\subsubsection*{\textsf{RSET}}
\begin{gather*}
  S \cup \emptyset \reduce S
  \qquad
  S \cup S \reduce S
  \qquad
  \{ \fst R \} \cup \{ \snd R \} \reduce R \\
  S \setminus \emptyset \reduce S
  \qquad
  \emptyset \setminus S \reduce \emptyset
  \qquad
  S \setminus S \reduce \emptyset \\
  (S_1 \cup S_2) \setminus X \reduce (S_1 \setminus X) \cup (S_2 \setminus X)
  \qquad
  S_1 \setminus (S_2 \cup S_3) \reduce (S_1 \setminus S_2) \setminus S_3 \\
  \\
  \frac{ R_1 \textrm{ in } R_2 }{ \{ R_1 \} \cup \{ R_2 \} \reduce \{ R_2 \} }
  \qquad
  \frac{ R_1 \textrm{ in } R_2 }{ \{ R_1 \} \setminus \{ R_2 \} \reduce \emptyset } \\
  \\
  \frac{ R_1 \textrm{ in } R_2 }{ \{R_2\} \setminus \{R_1\} \reduce (\{\fst R_2\} \setminus \{R_1\}) \cup (\{\snd R_2\} \setminus \{R_1\})}
  \qquad
  \frac{R_1 \| R_2}{ \{ R_1 \} \setminus \{ R_2 \} \reduce \{ R_1 \}} 
\end{gather*}

\begin{definition}[labelled core language]
  The \textbf{labelled core langauge} includes all symbols in the core language of Dirac notation, as well as symbols for the three new sorts.
  \begin{align*}
    & && S ::=\ \tilde{B} \cdot \tilde{K} \\
    & \tilde{\mathcal{K}}\text{(labelled ket)}&& \tilde{K} ::=\ K_{R}\ |\ \tilde{B}^\dagger\ |\ S.\tilde{K}\ |\ \tilde{K} + \tilde{K}\ |\ \tilde{O} \cdot \tilde{K}\ |\ \tilde{K} \otimes \tilde{K} \\
    & \tilde{\mathcal{B}}\text{(labelled bra)} && \tilde{B} ::=\ B_{R}\ |\ \tilde{K}^\dagger\ |\ S.\tilde{B}\ |\ \tilde{B} + \tilde{B}\ |\ \tilde{B} \cdot \tilde{O}\ |\ \tilde{B} \otimes \tilde{B} \\
    & \tilde{\mathcal{O}}\text{(labelled operator)} &&\tilde{O} ::=\ O_{R; R}\ |\ \tilde{K}\otimes\tilde{B}\ |\ \tilde{O}^\dagger\ |\ S.\tilde{O}\ |\ \tilde{O} + \tilde{O}\ |\ \tilde{O} \cdot \tilde{O}\ |\ \tilde{O} \otimes \tilde{O}
  \end{align*}
  In other words, we don't allow variables for labelled core language for now.
\end{definition}

\subsubsection*{\textsf{LABEL-CORE}}
We generally copied the symbols ($\dagger, S.\tilde{X}, +, \cdot, \otimes$) from the core language. Therefore we also need a copy of the corresponding rewriting rules.

\subsubsection*{\textsf{TSR-DECOMP}}

\begin{gather*}
  \ket{(s, t)}_{(Q, R)} \reduce \ket{s}_{Q} \otimes \ket{t}_{R}
  \qquad
  \bra{(s, t)}_{(Q, R)} \reduce \bra{s}_{Q} \otimes \bra{s}_{R} \\
  {\mathbf{0}_\mathcal{K}}_{(Q, R)} \reduce {\mathbf{0}_\mathcal{K}}_{Q} \otimes {\mathbf{0}_\mathcal{K}}_{R}
  \qquad
  {\mathbf{0}_\mathcal{B}}_{(Q, R)} \reduce {\mathbf{0}_\mathcal{B}}_{Q} \otimes {\mathbf{0}_\mathcal{B}}_{R} \\
  {\mathbf{0}_\mathcal{O}}_{(Q, R); (S, T)} \reduce {\mathbf{0}_\mathcal{O}}_{(Q, S)} \otimes {\mathbf{0}_\mathcal{O}}_{(R, T)} \\
  {\mathbf{0}_\mathcal{O}}_{(Q_1, Q_2); R} \reduce {\mathbf{0}_\mathcal{O}}_{Q_1; \fst R} \otimes {\mathbf{0}_\mathcal{O}}_{Q_2; \fst R}
  \qquad
  {\mathbf{0}_\mathcal{O}}_{Q; (R_1, R_2)} \reduce {\mathbf{0}_\mathcal{O}}_{\fst Q; R_1} \otimes {\mathbf{0}_\mathcal{O}}_{\snd Q; R_2} \\
  {\mathbf{1}_\mathcal{O}}_{(Q, R); (Q, R)} \reduce {\mathbf{1}_\mathcal{O}}_{Q; Q} \otimes {\mathbf{1}_\mathcal{O}}_{R; R} \\
  {\mathbf{1}_\mathcal{O}}_{(Q_1, Q_2); R} \reduce {\mathbf{1}_\mathcal{O}}_{Q_1; \fst R} \otimes {\mathbf{1}_\mathcal{O}}_{Q_2; \fst R}
  \qquad
  {\mathbf{1}_\mathcal{O}}_{Q; (R_1, R_2)} \reduce {\mathbf{1}_\mathcal{O}}_{\fst Q; R_1} \otimes {\mathbf{1}_\mathcal{O}}_{\snd Q; R_2}
\end{gather*}
\begin{gather*}
  (K_1 \otimes K_2)_{(Q, R)} \reduce {K_1}_{Q} \otimes {K_2}_{R}
  \qquad
  (B_1 \otimes B_2)_{(Q, R)} \reduce {B_1}_{Q} \otimes {B_2}_{R} \\
  (O_1 \otimes O_2)_{(Q, R); (S, T)} \reduce {O_1}_{Q; S} \otimes {O_2}_{R; T} \\
  (O_1 \otimes O_2)_{(Q_1, Q_2); R} \reduce {O_1}_{Q_1; \fst R} \otimes {O_2}_{Q_2; \snd R}
  \qquad
  (O_1 \otimes O_2)_{Q; (R_1, R_2)} \reduce {O_1}_{\fst Q; R_1} \otimes {O_2}_{\snd Q; R_2}
\end{gather*}


\subsubsection*{\textsf{TSR-COMP}}
\begin{gather*}
  {K_1}_{\fst R} \otimes {K_1}_{\snd R} \reduce (K_1 \otimes K_2)_{R}
  \qquad
  {B_1}_{\fst R} \otimes {B_2}_{\snd R} \reduce (B_1 \otimes B_2)_{R} \\
  {O_1}_{\fst Q; \fst R} \otimes {O_2}_{\snd Q; \snd R} \reduce (O_1 \otimes O_2)_{Q; R}
\end{gather*}

\subsubsection*{\textsf{DOT-TSR}}
\begin{align*}
  \frac{R \| S}{{O_1}_{Q; R} \cdot {O_2}_{S; T} \reduce {O_1}_{Q; R} \otimes {O_2}_{S; T}}
\end{align*}

\subsubsection*{\textsf{LABEL-LIFT}}
\begin{gather*}
  (K_{R})^\dagger \reduce (K^\dagger)_{R}
  \qquad
  (B_{R})^\dagger \reduce (B^\dagger)_{R}
  \qquad
  (O_{Q; R})^\dagger \reduce (O^\dagger)_{Q; R} \\
  (K_{R})^\top \reduce (K^\top)_{R}
  \qquad
  (B_{R})^\top \reduce (B^\top)_{R}
  \qquad
  (O_{Q; R})^\top \reduce (O^\top)_{Q; R} \\
  (S.K)_{R} \reduce S.(K_{R})
  \qquad
  (S.B)_{R} \reduce S.(B_{R})
  \qquad
  (S.O)_{Q; R} \reduce S.(O_{Q; R}) \\
  (K_1 + K_2)_{R} \reduce {K_1}_{R} + {K_2}_{R}
  \qquad
  (B_1 + B_2)_{R} \reduce {B_1}_{R} + {B_2}_{R}
  \qquad
  (O_1 + O_2)_{Q; R} \reduce {O_1}_{Q; R} + {O_2}_{Q; R}
\end{gather*}
\begin{gather*}
  {O_1}_{Q; R} \cdot {O_2}_{R; S} \reduce (O_1 \cdot O_2)_{Q; S}
  \qquad
  O_{Q; R} \cdot K_{R} \reduce (O \cdot K)_{Q}
  \qquad
  B_{Q} \cdot O_{Q; R} \reduce (B \cdot O)_{R} \\
  B_{R} \cdot K_{R} \reduce B \cdot K \\
  (K \otimes B)_{Q; R} \reduce K_{Q} \otimes B_{R}
\end{gather*}

\subsubsection*{\textsf{OPT-EXT}}
I think the concept ``cylinder extension'' is only limited to endomorphisms. Besides, one quantum register should a sub-register of the other one, which is defined as follows:

\begin{definition}[sub-register]
  \begin{gather*}
    \fst R \preceq R \qquad \snd R \preceq R \qquad Q \preceq (Q, R) \qquad R \preceq (Q, R)
    \qquad 
    \frac{Q \preceq R \qquad R \preceq S}{Q \preceq S}
  \end{gather*}

  And we can further calculate the ``position'' of sub-register, which will be utilized during cylinder extension: assume $Q$ is a sub-register of $R$, then the position of $Q$ in $R$ is a string defined as follows:
  \begin{align*}
    & \textrm{pos}(\fst R, R) = 0 \\
    & \textrm{pos}(\snd R, R) = 1 \\
    & \textrm{pos}(Q, (Q, R)) = 0 \\
    & \textrm{pos}(R, (Q, R)) = 1 \\
    & \textrm{pos}(Q, S) = \textrm{pos}(R, S)\ \textrm{pos}(Q, R)
  \end{align*}
\end{definition}

\textbf{Remark:} For a well-formed quantum register, the sub-register position is well-defined.

\begin{definition}[cylinder extension]
  \begin{align*}
    \textrm{ext}(O, \epsilon) \equiv O
    && \textrm{ext}(O, p::0) \equiv O \otimes \mathbf{1}_\mathcal{O}
    && \textrm{ext}(O, p::1) \equiv \mathbf{1}_\mathcal{O} \otimes O
  \end{align*}
\end{definition}

\subsubsection*{\textsf{CYLINDER-EXT}}
\begin{gather*}
  \frac{Q \textrm{ is a subterm of } R \textrm{ at } p}{O_{Q; Q} \cdot K_{R} \reduce (\textrm{ext}(O, p) \cdot K)_{R}}
  \qquad
  \frac{Q \textrm{ is a subterm of } R \textrm{ at } p}{{O_1}_{Q; Q} \cdot {O_2}_{R; T} \reduce (\textrm{ext}(O_1, p) \cdot O_2)_{R; T}} \\
  \\
  \frac{R \textrm{ is a subterm of } Q \textrm{ at } p}{B_{Q} \cdot O_{R; R} \reduce (B \cdot \textrm{ext}(O, p))_{Q}}
  \qquad
  \frac{R \textrm{ is a subterm of } Q \textrm{ at } p}{{O_1}_{T; Q} \cdot {O_2}_{R; T} \reduce (O_1 \cdot \textrm{ext}(O_2, p))_{T; Q}} \\
\end{gather*}


\subsection{Labelled Extended Language}
\begin{definition}[labelled extended language]
  The \textbf{labelled extended language} consists of the symbols in labelled core langauge and unlabelled extended language, and add the new symbols of transpose and big-op for labelled bra, ket and operators, which is described in the following.
  \begin{align*}
    \tilde{K} ::= \tilde{B}^\top\ |\ \sum_{i \in M} \tilde{K}
    && \tilde{B} ::= \tilde{K}^\top\ |\ \sum_{i \in M} \tilde{B}
    && \tilde{O} ::= \tilde{O}^\top\ |\ \sum_{i \in M} \tilde{O}
  \end{align*}
  
\end{definition}


\subsubsection*{\textsf{LABEL-SUM}}
\begin{gather*}
  (\sum_{i \in M} K)_{R} \reduce \sum_{i \in M} (K_{R})
  \qquad
  (\sum_{i \in M} B)_{R} \reduce \sum_{i \in M} (B_{R})
  \qquad
  (\sum_{i \in M} O)_{Q; R} \reduce \sum_{i \in M} (O_{Q; R})
\end{gather*}

\subsubsection*{\textsf{LABEL-TEMP}}
\yx{These are ad-hoc rules for the examples for now. They are still not organized and require further investigations.}
\begin{gather*}
  \frac{R \textsf{ in } Q}{O_{P; R} \cdot (K_{Q} \otimes \tilde{K'}) \reduce (O_{P; R} \cdot K_{Q}) \otimes \tilde{K'}} 
  \qquad
  \frac{R \textsf{ in } Q}{O_{P; R} \cdot (K_{Q} \otimes \tilde{B}) \reduce (O_{P; R} \cdot K_{Q}) \otimes \tilde{B}} \\
  \\
  \frac{R \textsf{ in } Q}{{O_1}_{P; R} \cdot ({O_2}_{Q; T} \otimes \tilde{O_3}) \reduce ({O_1}_{P; R} \cdot {O_2}_{Q; T}) \otimes \tilde{O_3}} \\
  \\
  \frac{Q \textsf{ in } R}{(B_{R} \otimes \tilde{B'}) \cdot O_{Q;P} \reduce (B_{R} \cdot O_{Q;P}) \otimes \tilde{B'}} 
  \qquad
  \frac{Q \textsf{ in } R}{({O_1}_{T;R} \otimes \tilde{O'}) \cdot {O_2}_{Q;P} \reduce ({O_1}_{T;R} \cdot {O_2}_{Q;P}) \otimes \tilde{O'}} \\
  \\
  B_{R} \cdot (K_{R} \otimes \tilde{B'}) \reduce (B_{R} \cdot K_{R}) . \tilde{B'} 
  \qquad
  (\tilde{K'} \otimes B_{R}) \cdot K_{R} \reduce (B_{R} \cdot K_{R}) . \tilde{K'}
\end{gather*}


\end{document}
\endinput