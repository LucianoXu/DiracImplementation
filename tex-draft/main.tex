%%
%% This is file `sample-acmlarge.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,journal,bibtex,acmlarge')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmlarge.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[manuscript, review, timestamp]{acmart}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\usepackage{color}
\usepackage{amsmath}
%\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage[all]{xy}
\usepackage{multirow}
\usepackage{paralist}
\usepackage{hhline}
\usepackage{bm}
\usepackage{braket}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\CIRCLE}%
\newcommand{\xmark}{\Circle}%
\newcommand{\hmark}{\LEFTcircle}%
\renewcommand{\matrix}[1]{\begin{bmatrix}#1\end{bmatrix}}
\usepackage{wasysym}
\usepackage{extarrows}
\usepackage{tikz}
\usetikzlibrary{positioning, shapes.geometric, graphs}
\usepackage{wrapfig}
\usepackage{dsfont}



%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\newcommand{\yx}[1]{\textit{\color{blue}[YX] : #1}}



\newcommand*{\unit}{\texttt{unit}}
\newcommand*{\utt}{\texttt{tt}}
\newcommand*{\fst}{\texttt{fst}}
\newcommand*{\snd}{\texttt{snd}}
\newcommand*{\reduce}{\ \triangleright\ }
\newcommand*{\reducefrom}{\ \triangleleft\ }

\newcommand*{\zeroK}[1]{\mathbf{0}_{\mathcal{K}(#1)}}
\newcommand*{\zeroB}[1]{\mathbf{0}_{\mathcal{B}(#1)}}
\newcommand*{\zeroO}[1]{\mathbf{0}_{\mathcal{O}(#1)}}

\newcommand*{\sem}[1]{\llbracket #1 \rrbracket}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Decision Procedure for Dirac Notations}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\section{Introduction}

Importance of formal language ...

Decision procedure, methodology, different styles ...

Related work in formalizing quantum computing and quantum information ...

Our contribution:
\begin{itemize}
  \item A core language of Dirac notations. It is a sound abstract interpretation of the quantum states and operations. 
  \item A term rewriting system on the core language with congruence proved.
  \item An extension on the language and term rewriting system with more symbols. The TRS is not built with heuristics and not complete.
  \item An implementation of the language and TRS, with many practical examples calculated.
\end{itemize}


\section{Preliminaries}

\subsection{Linear algebra with tensor product}

\subsection{Quantum computing and Dirac notations}

\subsection{AC term rewriting}

\subsection{Confluence modulo Theory and the Avatar Lemma}

Our theories on Dirac notations can be divided into different parts, each containing its own language and computational methods. For example, the parts concerning complex numbers and basis vectors of vector spaces are relatively independent and complete; while the language and algorithm of Dirac notations are based on these components. Subsequent theoretical developments can build on this entire result, such as our extended Dirac language which incorporates a big operator sum and indices for quantum registers.

These components are relatively independent and complete, allowing us to refer to them as different modules. Traditionally, the entire formal system has been studied as a whole. This approach is straightforward and direct, avoiding the need to consider how the parts interact, but at the expense of flexibility. Taking Dirac notation as an example, when we expand the language of complex numbers or design a more comprehensive rewriting system, the properties of the entire formal system need to be reconsidered. To make theoretical results more general, we can explore a modular narrative and proof methodology. For rewriting systems, we can utilize the Avatar Lemma \cite{Arrighi2005}\cite{Arrighi2017}, which is introduced below.

% First we introduce some concepts about modularity and the avatar lemma.


\begin{definition}[Subsumption]
  A terminating and confluent relation $S$ subsumes a relation $S_0$ if whenever $t \to_{S_0} u$, $t$ and $u$ have the same $S$-normal form.
\end{definition}

\begin{definition}[Commuting relations]
  Two relations $X$ and $Y$ are said to be commuting if whenever $t \to_X u$ and $t \to_Y v$, there exists a term $w$ such that $u \to_Y w$ and $v \to_X w$.
\end{definition}

\begin{lemma}[The avatar lemma] \cite{Arrighi2005} Let $X$, $S$ and $S_0$ be three relations defined on a set such that:
  \begin{itemize}
    \item $S$ is terminating and confluent;
    \item $S$ subsumes $S_0$;
    \item $S_0 \cup X$ is locally confluent;
    \item $X$ commutes with $S^*$.
  \end{itemize}
  Then, the relation $S \cup X$ is locally confluent.
\end{lemma}

The smaller relation $S_0$ here is called the avatar, since it captures the critical part of the larger relation $S$ that will appear in the rest part $X$. The avatar lemma formalizes our intuition about the modularity of confluence: if we start with the locally confluent system $S_0 \cup X$ and extend the system from $S_0$ to $S$, which will not interfere with the other part $X$ and is still confluent, then the whole system $S\cup X$ will remain locally confluent. In our development of Dirac notations, we will use such avatars to represent the weakest requirement on complex numbers and basis.


\section{The Core Language}

One difficulty of formalizing Dirac notations and designing the rewriting rules is the overloading of operators. This feature makes Dirac notations flexible and easy to use, but also introduced ambiguity into the syntax. In the core langauge, we want to prove some desired properties of the term rewriting system, such as congruence and soundness, and we have to rely on existing theories and tools. Therefore we choose the untyped universal algebra with AC symbols.


\subsection{Language Syntax}

\begin{definition} [atomic basis signature]
  The \textbf{atomic basis signature} $\Sigma_\mathcal{A}$ is any finite language.
\end{definition}

Because we consider the tensor product structure, larger Hilbert spaces can be composed by the atomic ones, like the qubit Hilbert space. The atomic basis here characterize the basis of the atomic Hilbert spaces.
We limit the basis signature to finite languages to avoid problems of infinite dimensions.

\begin{definition} [complex number signature]
  The \textbf{complex number signature} $\Sigma_\mathcal{C}$ contains at least constant symbols $0, 1$, a unary symbol $*$ and binary symbols $+, \times$.
\end{definition}

Following the idea of the avatar lemma, the two signatures $\Sigma_\mathcal{A}$ and $\Sigma_\mathcal{C}$ characterize the language for atomic basis and complex numbers. 
The symbols for complex numbers are zero, one, conjugate, addition and multiplication respectively. Compared the avatar language in the Lineal paper\cite{Arrighi2017}, it adds the conjugate symbol since we need to deal with conjugate and inner product.
These symbols are only the least requirements as interfaces, and the real language to instantiate can contain more details. For example, the basis can contain symbols $0$ and $1$ for qubit spaces, and the complex numbers can still have exponential functions $e^x$ or square roots $\sqrt{x}$.

\begin{definition}[core language of Dirac Notation]
  The \textbf{core language of Dirac Notation}, denoted as $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, is a many-sorted language. It consists of the sort $\mathcal{C}$(complex number) with corresponding symbols from $\Sigma_\mathcal{C}$, as well as the following sorts for Dirac notations:
  \begin{align*}
    & \mathcal{E} \textrm{(basis)} && t ::= x\ |\ a\ |\ (t, t)\ |\ \fst\ t\ |\ \snd\ t, \\
    & \mathcal{S} \textrm{(scalar)} && S ::= x\ |\ C(\alpha)\ |\ \delta_{t, t}\ |\ S + S\ |\ S \times S\ |\ S^*\ |\ B \cdot K, \\
    & \mathcal{K} \textrm{(ket)} && K ::= x\ |\ \mathbf{0}_\mathcal{K}\ |\ \ket{t}\ |\ B^\dagger\ |\ S.K\ |\ K + K\ |\ O \cdot K\ |\ K \otimes K, \\
    & \mathcal{B} \textrm{(bra)} && B ::= x\ |\ \mathbf{0}_\mathcal{B}\ |\ \bra{t}\ |\ K^\dagger\ |\ S.B\ |\ B + B\ |\ B \cdot O\ |\ B \otimes B, \\
    & \mathcal{O} \textrm{(operator)} && O ::= x\ |\ \mathbf{0}_\mathcal{O}\ |\ \mathbf{1}_\mathcal{O}\ |\ K \otimes B\ |\ O^\dagger\ |\ S.O\ |\ O + O\ |\ O \cdot O\ |\ O \otimes O.
  \end{align*}
  Here we use $x$ to represent variables, $a$ to represent atomic basis in $\Sigma_\mathcal{A}$, lower case letters like $s, t$ to represent basis from $\Sigma_\mathcal{E}$, and Greek letters like $\alpha$ to represent complex number terms from $\Sigma_\mathcal{C}$. We use letters $S$, $K$, $B$, $O$ and their variants to represent terms from the scalar, ket, bra and operator sorts repsectively.

\end{definition}

We make the modularity explicit by separating the complex number sort $\mathcal{C}$ from the scalar sort $\mathcal{S}$ in Dirac notations. It is necessary because the scalar language is defined by mutual induction with ket, bra and basis, which does not appear in standard language of complex. This also indicates the joint position in the term rewriting system: the rules for complex numbers can vary in different cases of $\sum_\mathcal{C}$, and our work on Dirac notations is to design the general rewriting rules involving inner products and Kronecker-Delta expressions. Separating the two languages allows us to apply the avatar lemma in theoretical analysis. From the implementation level, it means we can directly utilize different solvers that focus on complex numbers, and extend the language of complex numbers easily by modifying $\sum_\mathcal{C}$.

The same discussion applies for the language of basis. The atomic basis describes every individual subsystem in the physical level. The pairing and projections are for basis in Hilbert space with tensor products, which lie in the logic level.

We can consider possible candidates for instantiating $\Sigma_\mathcal{C}$, which touches the decidability problem of reals. Beyond the weakest one, the avatar $\{0, 1, *, +, \times\}$ itself \yx{any theorems on this one?}, we can also try to add symbols pervasively used in quantum, such as exponential functions, trigonometric functions and square/square root.

The choice of the atomic basis language $\Sigma_\mathcal{A}$ has large freedom and can be suited to different scenarios. Besides introducing constant symbols (e.g., $0$ and $1$ base), richer language with operations on base terms are also possible. 


Although we use the same characters in different sorts ($B \cdot K$ and $O \cdot K$, for example), they are actually different symbols and can be easily distinguished from the context. This is also reflected in the \texttt{CiME2} script. 

The language is intended to be used in the multi-sorted manner, but in the proof of confluence property, we check the unsorted version. The unsorted version simply removes all sort constraints, and its confluence is equivalent to that of the multi-sorted version, which is the persistancy proved in \cite{Aoto1997}.


Transpose is also an important operation pervasively used in quantum information, but the core language here does not incoporate this symbol due to some confluence problems. Since transpose is involutive (i.e., $(B^\top)^\top = B$), we cannot encode the axiom $ (B \cdot K)^\top = K^\top \cdot B^\top$ in the naive term rewriting system. We discovered that the difficulty raises with coexistence of adjoint and transpose. We can alternatively have the transpose symbol only, but not both. In light of this, transpose is moved to the extended language, where equivalence are decided with more powerful techniques like ordered rewriting.

\subsection{Denotational Semantics}

Denotational semantics explain the formal languageas a process of calculation. For language $L$, it first specifies its domain $\mathcal{D}_L$. For syntax $S$ of $L$, the semantics $\sem{S} \in \mathcal{D}_L$, and the semantics of different symbols are defined by the rules as mathematical functions. For the modules, the domain for $\Sigma_\mathcal{C}$ is simply the complex field $\mathbb{C}$, and the domain for $\Sigma_\mathcal{A}$ is some finite set $A$. In the following, we give the denotational semantics of core language $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$. 

\begin{definition}[denotational semantics of basis]
  For atomic basis $\Sigma_\mathcal{A}$ with domain $A$, the domain of basis $\mathcal{E}$ is the binary tree algebra over $A$, which is defined as 
  $
  \mathcal{D}_\mathcal{E} = \mu X.(A\cup (X \times X)),
  $
  the smallest set that contains $A$ and is closed under Cartesian product.

  The semantics of symbols in $\mathcal{E}$ are defined as follows:
  \begin{align*}
    & \text{(Pairing)} &&
    \sem{(t_1, t_2)} \equiv (\sem{t_1}, \sem{t_2}), \\
    & \text{(First Projection)} &&
    \sem{\fst\ t} \equiv \left\{
      \begin{array}{ll}
        x_1, & \text{ where } \sem{t} = (x_1, x_2), \\
        a, & \text{ where } \sem{t} = a \in A,
      \end{array}
      \right. \\
    & \text{(Second Projection)} &&
    \sem{\snd\ t} \equiv \left\{
      \begin{array}{ll}
        x_2, & \text{ where } \sem{t} = (x_1, x_2), \\
        a, & \text{ where } \sem{t} = a \in A.
      \end{array}
      \right.
  \end{align*}
\end{definition}

\yx{We set $\fst\ a = a$ to avoid malformed terms.}


The semantics for Dirac notations are based on linear algebra, but some explanation on typing is necessary here. In mathematics we commonly distinguish linear spaces with different sizes, which corresponds to a more meticulous type system with basis set information. But our internal language only use sorts to represent vectors or operators, but the space itself is untyped. It is equivalent to say that we consider only one universal linear space. On the one hand, it can be understood as the direct sum of all different, typed linear spaces. On the other hand, it is the linear space with basis set $\mathcal{D}_\mathcal{E}$. From the isomorphism $\mathcal{H}_{A\cup B} \cong \mathcal{H}_A \oplus \mathcal{H}_B$, $\mathcal{H}_{A \times B} \cong \mathcal{H}_A \otimes \mathcal{H}_B$, we have
$$
\mathcal{H}_{\mathcal{D}_\mathcal{E}} = \mathcal{H}_{\mu X.(A\cup (X \times X))} \cong \mu V. \mathcal{H}_A \oplus (V \otimes V).
$$


\begin{definition}[denotational semantics of scalar]
  The domain of scalars $\mathcal{D}_\mathcal{S} = \mathbb{C}$ is the complex field.
  The semantics of the symbols are defined as follows:
  \begin{align*}
    & \text{(Complex Number)} &&
    \sem{C(\alpha)} \equiv \sem{\alpha}, \\
    & \text{(Kronecker Delta)} &&
    \sem{\delta_{s, t}} \equiv \left\{
      \begin{array}{ll}
        1, & \text{where } \sem{s} = \sem{t}, \\
        0, & \text{where } \sem{s} \neq \sem{t}, 
      \end{array}
    \right. \\
    & \text{(Addition)} &&
    \sem{S_1 + S_2} \equiv \sem{S_1} + \sem{S_2}, \\
    & \text{(Multiplication)} &&
    \sem{S_1 \times S_2} \equiv \sem{S_1} \times \sem{S_2}, \\
    & \text{(Conjugate)} &&
    \sem{S^*} \equiv \sem{S}^*, \\
    & \text{(Inner Product)} &&
    \sem{B \cdot K} \equiv \langle \sem{B}^*, \sem{K} \rangle.
  \end{align*}
\end{definition}

Note that we use the symbol $C(\alpha)$ to introduce complex numbers as scalars.
One interesting decision is the explanation for Dirac notation inner product $B \cdot K$. An other possibility is to let $\sem{B \cdot K} \equiv \langle \sem{B}, \sem{K} \rangle$, which may be closer to the inner product in linear algebra. The two explanations only differ in the convention sense. Our choice sets Dirac notation inner product linear on the bra $B$, which makes the rewriting rules of bra and ket more symmetric. Also, it enables easier equivalence checking for transpose in the extended language.


\begin{definition}[denotational semantics of ket/bra]
  The domain for the semantics of ket and bra are $\mathcal{H}_{\mathcal{D}_\mathcal{E}}$ and $\mathcal{H}_{\mathcal{D}_\mathcal{E}}^*$ respectively.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Vector)} &&
    \sem{\mathbf{0}_\mathcal{K}} \equiv \mathbf{0} && \sem{\mathbf{0}_\mathcal{B}} \equiv \mathbf{0}^*, \\
    & \text{(Basis Vector)} &&
    \sem{\ket{t}} \equiv \mathbf{e}_t && \sem{\bra{t}} \equiv \mathbf{e}^t, \\
    & \text{(Adjoint)} &&
    \sem{B^\dagger} \equiv \sem{B}^* && \sem{K^\dagger} \equiv \sem{K}^*, \\
    & \text{(Scalar Multiplication)} &&
    \sem{S.K} \equiv \sem{S} \sem{K} && \sem{S.B} \equiv \sem{S} \sem{B}, \\
    & \text{(Addition)} &&
    \sem{K_1 + K_2} \equiv \sem{K_1} + \sem{K_2} && \sem{B_1 + B_2} \equiv \sem{B_1} + \sem{B_2}, \\
    & \text{(Linear Operator)} &&
    \sem{O \cdot K} \equiv \sem{O} \cdot \sem{K} && \sem{B \cdot O} \equiv (\sem{O}^\dagger \cdot \sem{B}^*)^*, \\
    & \text{(Tensor Product)} &&
    \sem{K_1 \otimes K_2} \equiv \sem{K_1} \otimes \sem{K_2} && \sem{B_1 \otimes B_2} \equiv \sem{B_1} \otimes \sem{B_2}.
  \end{align*}
\end{definition}



\begin{definition}[denotational semantics of operator]
  The domain for the semantics of operators is the homomorphism $\mathcal{D}_\mathcal{O} = \textrm{Hom}(\mathcal{H}_{\mathcal{D}_\mathcal{E}}, \mathcal{H}_{\mathcal{D}_\mathcal{E}})$.
  The symbols are explained as follows:
  \begin{align*}
    & \text{(Zero Operator)} &&
    \sem{\mathbf{0}_\mathcal{O}} \equiv \mathbf{0}_{\textrm{op}}, \\
    & \text{(Identity Operator)} &&
    \sem{\mathbf{1}_\mathcal{O}} \equiv \mathbf{I}, \\
    & \text{(Outer Product)} &&
    \sem{K \otimes B} \equiv \lambda \mathbf{v}. \langle \sem{B}^*, \mathbf{v}\rangle \sem{K}, \\
    & \text{(Adjoint)} &&
    \sem{O^\dagger} \equiv \sem{O}^\dagger, \\
    & \text{(Scalar Operator)} &&
    \sem{S.O} \equiv \sem{S} \sem{O}, \\
    & \text{(Addition)} &&
    \sem{O_1 + O_2} \equiv \sem{O_1}+\sem{O_2}, \\
    & \text{(Operator Multiplication)} &&
    \sem{O_1 \cdot O_2} \equiv \sem{O_1} \cdot \sem{O_2}, \\
    & \text{(Tensor Product)} &&
    \sem{O_1 \otimes O_2} \equiv \sem{O_1} \otimes \sem{O_2},
  \end{align*}
\end{definition}


\subsection{Axiomatic Semantics}

To further study the properties of this language, we try to axiomatize the equivalence in the denotational semantics as a proof system with equations, which results in the axiomatic semantics $AX$. The formal proof system should be sound in the sense that the axioms as equations hold in the denotational semantics. Meanwhile, the equivalence defined by axioms should be as comprehensive as possible compared to that in the denotational semantics, enabling it to cover most of the equivalence relations in which we are interested.

Although the formal system implies the equivalence of Dirac notations we desire, it does not point out how to correctly apply the axioms. Therefore, we still need to design an algorithm to decide the equivalence. A classical approach is to assign directions to the application of equations, resulting in the term rewriting system in the next section.

The axiomatic semantics then serve as the criterion for the proof of soundness and completeness of the rewriting algorithm. But before that, let's fix the bridge first.
The symbol $\vdash_{AX}$ is omitted for the axioms.

\begin{definition}[axiomatic semantics of complex numbers]
  \begin{gather*}
    0 + \alpha = \alpha
    \qquad
    \alpha + \beta = \beta + \alpha
    \qquad
    (\alpha + \beta) + \gamma = \alpha + (\beta + \gamma) \\
    0 \times \alpha = 0
    \qquad
    1 \times \alpha = \alpha
    \qquad
    \alpha \times \beta = \beta \times \alpha \\
    (\alpha \times \beta) \times \gamma = \alpha \times (\beta \times \gamma) \qquad
    \alpha \times (\beta + \gamma) = \alpha \times \beta + \alpha \times \gamma \\
    (\alpha + \beta)^* = \alpha^* + \beta^*
    \qquad
    (\alpha \times \beta)^* = \alpha^* \times \beta^*
    \qquad
    (\alpha^*)^* = \alpha
  \end{gather*}
\end{definition}
Compared to the ``scalar rewrite system'' in the Lineal paper\cite{Arrighi2017}, here we have three more axioms for the conjugate symbol.


\begin{definition}[BASIS]
  \begin{gather*}
      \fst\ (s, t) = s
      \qquad
      \snd\ (s, t) = t
      \qquad
      (\fst\ s, \snd\ s) = s
  \end{gather*}
\end{definition}

Although in the denotational semantics we have to consider the case where projections are applied on atomic basis, we can omit the two rules 
$
\fst\ a = a,
\snd\ a = a
$
in the axiomatic semantics, as the extra definition in the denotational semantics are only necessary for technical reasons.



Many axioms have the similar form for scalars, bra, ket and operators. In the following we express them in a unified style and use the letter $D$ to represent some Dirac notation term of the appropriate sort.

\begin{definition}[UNI-LINEAR]
  \begin{gather*}
    D + \mathbf{0} = D
    \qquad
    D_1 + D_2 = D_2 + D_1
    \qquad
    (D_1 + D_2) + D_3 = D_1 + (D_2 + D_3) \\
    C(0).D = \mathbf{0}
    \qquad
    C(1).D = D
    \qquad
    S.\mathbf{0} = \mathbf{0} \\
    S_1.(S_2.D) = (S_1 \times S_2).D
    \qquad
    S.(D_1 + D_2) = S.D_1 + S.D_2
  \end{gather*}
\end{definition}

\begin{definition}[UNI-ADJOINT]
  \begin{gather*}
    \textbf{0}^\dagger = \textbf{0}
    \qquad
    \mathbf{1}_\mathcal{O}^\dagger = \mathbf{1}_\mathcal{O}
    \qquad
    \ket{t}^\dagger = \bra{t}
    \qquad
    (D^\dagger)^\dagger = D \\
    (S.D)^\dagger = S^*.(D^\dagger)
    \qquad
    (D_1 + D_2)^\dagger = D_1^\dagger + D_2^\dagger \\
    (D_1 \cdot D_2)^\dagger = D_2^\dagger \cdot D_1^\dagger \\
    (K_1 \otimes K_2)^\dagger = K_1^\dagger \otimes K_2^\dagger
    \qquad
    (B_1 \otimes B_2)^\dagger = B_1^\dagger \otimes B_2^\dagger
    \qquad
    (O_1 \otimes O_2)^\dagger = O_1^\dagger \otimes O_2^\dagger \\
    (K \otimes B)^\dagger = B^\dagger \otimes K^\dagger
  \end{gather*}
\end{definition}


\begin{definition}[UNI-DOT]
  \begin{gather*}
      \textbf{0} \cdot D = \textbf{0}
      \qquad
      \textbf{1}_\mathcal{O} \cdot D = D \\
      D_1 \cdot (S.D_2) = S.(D_1 \cdot D_2)
      \qquad
      D_0 \cdot (D_1 + D_2) = D_0 \cdot D_1 + D_0 \cdot D_2 \\
      D_0 \cdot (D_1 \cdot D_2) = (D_0 \cdot D_1) \cdot D_2 \\
      (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) = (B_1 \cdot K_1) \times (B_2 \cdot K_2) \\
      (O_1 \otimes O_2) \cdot (K_1 \otimes K_2) = (O_1 \cdot O_1) \times (B_2 \cdot K_2) \\
      (B_1 \otimes B_2) \cdot (O_1 \otimes O_2) = (B_1 \cdot K_1) \times (O_2 \cdot O_2) \\
      (O_1 \otimes O_2) \cdot (O_1' \otimes O_2') = (O_1 \cdot O_1') \times (O_2 \cdot O_2') \\
      (K_1 \otimes B_1) \cdot (K_2 \otimes B_2) = (B_1 \cdot K_2) . (K_1 \otimes B_2)
  \end{gather*}
\end{definition}


\begin{definition}[UNI-TENSOR]
  \begin{gather*}
      \mathbf{0} \otimes D = \mathbf{0}
      \qquad
      D \otimes \mathbf{0} = \mathbf{0}
      \qquad
      \mathbf{1}_\mathcal{O} \otimes \mathbf{1}_\mathcal{O} = \mathbf{1}_\mathcal{O} \\
      \ket{s} \otimes \ket{t} =\ket{(s, t)} \\
      D_1 \otimes (S.D_2) = S.(D_1 \otimes D_2)
      \qquad
      D_0 \otimes (D_1 + D_2) = D_0 \otimes D_1 + D_0 \otimes D_2 \\
      (K_1 \otimes B) \cdot K_2 = (B \cdot K_2).K_1
      \qquad
      B_1 \cdot (K \otimes B_2) = (B_1 \cdot K).B_2 \\
      (K \otimes B) \cdot O = K \otimes (B \cdot O)
      \qquad
      O \cdot (K \otimes B) = (O \cdot K) \otimes B \\
      (K_1 \otimes B_1) \otimes (K_2 \otimes B_2) = (K_1 \otimes K_2) \otimes (B_1 \otimes B_2) \\
  \end{gather*}
\end{definition}

Note the axiom $\ket{s} \otimes \ket{t} =\ket{(s, t)}$ here. The combination of two subsystems can either be expressed as tensor product in linear algebra (on the left), or by data structure of pairing (on the right). This points to the isomorphism $\mathcal{H}_{A \times B} \cong \mathcal{H}_A \otimes \mathcal{H}_B$.

Because the symbols and semantics of scalars are different, we list the axioms of scalars as follows.

\begin{definition}[SCR-BASIC]
  \begin{gather*}
    C(0) + S = S
    \qquad
    S_1 + S_2 = S_2 + S_1
    \qquad
    (S_1 + S_2) + S_3 = S_1 + (S_2 + S_3) \\
    C(0) \times S = C(0)
    \qquad
    C(1) \times S = S
    \qquad
    S_1 \times S_2 = S_2 \times S_1 \\
    (S_1 \times S_2) \times S_3 = S_1 \times (S_2 \times S_3)
    \qquad
    S_1 \times (S_2 + S_3) = S_1 \times S_2 + S_1 \times S_3 \\
    C(\alpha) + C(\beta) = C(\alpha + \beta)
    \qquad
    C(\alpha) \times C(\beta) = C(\alpha \times \beta)
    \qquad
    C(\alpha)^* = C(\alpha^*) \\
    \delta_{s, t}^* = \delta_{s, t}
    \qquad
    (S_1 + S_2)^* = S_1^* + S_2^*
    \qquad
    (S_1 \times S_2)^* = S_1^* \times S_2^*
    \qquad
    (S^*)^* = S
    \qquad
    (B \cdot K)^* = K^\dagger \cdot B^\dagger
  \end{gather*}  
\end{definition}

\begin{definition}[SCR-DELTA]
  \label{def: SCR-DELTA}
  \begin{gather*}
    \delta_{s, s} = C(1) \\
    s, t \text{ are different constants} \vdash_{AX} \delta_{s, t} = C(0)  \tag{*} \\
    (\bigwedge_i s_i = t_i) \leftrightarrow (\bigwedge_i s_i' = t_i') \vdash_{AX} \prod_i \delta_{s_i, t_i} = \prod_i \delta_{s_i', t_i'} \tag{**}
  \end{gather*}
\end{definition}

An example for the (**) axiom is $\delta_{i, j} \times \delta_{j, k} = \delta_{i, k} \times \delta_{j, k}$. This means the reasoning of Delta operators also involve some propositional logic.

\begin{definition}[SCR-DOT]
  \begin{gather*}
    \mathbf{0} \cdot K = C(0) \\
    B \cdot (S.K) = S \times (B \cdot K) \\
    B \cdot (K_1 + K_2) = B_0 \cdot K_1 + B_0 \cdot K_2 \\
    \bra{s} \cdot \ket{t} = \delta_{s, t} \\
    (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) = (B_1 \cdot K_1) \times (B_2 \cdot K_2)
  \end{gather*}
\end{definition}

The symmetric rules can be deduced. For example,
\begin{align*}
(B_1 + B_2) \cdot K & = (((B_1 + B_2) \cdot K)^*)^* \\
& = (K^\dagger \cdot (B_1 + B_2)^\dagger)^* \\
& = (K^\dagger \cdot (B_1^\dagger + B_2^\dagger))^* \\
& = (K^\dagger \cdot B_1^\dagger + K^\dagger \cdot B_2^\dagger)^* \\
& = (K^\dagger \cdot B_1^\dagger)^* + (K^\dagger \cdot B_2^\dagger)^* \\
& = (B_1^\dagger)^\dagger \cdot (K^\dagger)^\dagger + (B_2^\dagger)^\dagger \cdot (K^\dagger)^\dagger \\
& = B_1 \cdot K + B_2 \cdot K.
\end{align*}

The axiomatic semantics are concluded above. To mitigate the formalization workload, its consistency compared to the denotational semantics is not directly proved here. Instead, we first prove the completeness of the term rewriting system w.r.t. the axioms, then prove the soundness of all the rewriting rules in \texttt{CoqQ} directly, which in the end implies that the axiomatic semantics is not stronger than the denotational one.


\subsection{Decision algorithm: AC term rewriting}
\label{sec: typed_dirac_rules}

It is reasonable to assume that we have the rewriting term system to decide the complex number in $\Sigma_\mathcal{C}$ and atomic basis in $\Sigma_\mathcal{A}$, which are described in the following.

\begin{definition}[TRS $R_{\Sigma_\mathcal{A}}$]
  For the atomic basis language $\Sigma_\mathcal{A}$, the TRS $R_{\Sigma_\mathcal{A}}$ is any terminating and confluent TRS.
\end{definition}


\begin{definition}[TRS $R_{\Sigma_\mathcal{C}}$]
  For the complex number language $\Sigma_\mathcal{C}$, the TRS $R_{\Sigma_\mathcal{C}}$ is an TRS such that:
  \begin{itemize}
    \item $S$ is terminating and ground confluent,
    \item for all closed terms $\alpha$, $\beta$ and $\gamma$, the pair of terms
    \begin{itemize}
        \item $0 + \alpha$ and $\alpha$,
        \item $0 \times \alpha$ and $0$,
        \item $1 \times \alpha$ and $\alpha$,
        \item $\alpha \times (\beta + \gamma)$ and $(\alpha \times \beta) + (\alpha \times \gamma)$,
        \item $(\alpha + \beta) + \gamma$ and $\alpha + (\beta + \gamma)$,
        \item $\alpha + \beta$ and $\beta + \alpha$,
        \item $(\alpha \times \beta) \times \gamma$ and $\alpha \times (\beta \times \gamma)$,
        \item $\alpha \times \beta$ and $\beta \times \alpha$,
        \item $(\alpha + \beta)^*$ and $\alpha^* + \beta^*$,
        \item $(\alpha \times \beta)^*$ and $\alpha^* \times \beta^*$,
        \item $(\alpha^*)^*$ and $\alpha$
    \end{itemize}
    have the same normal forms,
    \item $0$ and $1$ are normal terms.
  \end{itemize}  
\end{definition}

This definition follows the ``scalar rewrite system'' in Linear\cite{Arrighi2017}.


To decide the equivalence of two Dirac notation terms, we will use a variant of standard term rewritings called \textbf{AC-Rewriting} to deal with the associative and commutative symbols such as $+$ and $\times$. But here is one excpetion: the dot symbols in the core language is associative only, just like linear operations, but one important tool called \texttt{CiME2} we will use later does not support associative only symbols. In this consideration, we have to handle the associativity using rules hard-coded by hand.

\begin{definition} [TRS $R_\mathfrak{DN}$]
  The AC-rewrite system for the core language, written as $R_\mathfrak{DN}$, consists of all the rules in Sec.\ref{sec: typed_dirac_rules}.
  The AC-symbols are $+$ (for all sorts) and $\times$. The commutative symbol is $\delta_{s, t}$.
\end{definition}


\subsubsection*{\textsf{BASIS}}
\begin{gather*}
    \fst\ (e_1, e_2) \reduce e_1
    \qquad
    \snd\ (e_1, e_2) \reduce e_2
    \qquad
    (\fst\ e, \snd\ e)\reduce e
\end{gather*}

\subsubsection*{\textsf{DELTA}}
\begin{gather*}
  \delta{s, s} \reduce C(1)
  \qquad
  \delta_{u, (s, t)} \reduce \delta_{\fst\ u, s} \times \delta_{\snd\ u, t} 
  \qquad
  \delta_{\fst\ u, \fst\ v}\times\delta_{\snd\ u, \snd\ v} \reduce \delta_{u, v}
\end{gather*}

\textbf{Remark:} These last two rules are for completion.


\subsubsection*{\textsf{SCR-COP}}
\begin{gather*}
   C(0) + S \reduce S
  \qquad
   C(\alpha) + C(\beta) \reduce C(\alpha + \beta)
  \qquad
   S + S \reduce C(1 + 1) \times S \\
   C(\alpha) \times S + S \reduce C(\alpha + 1) \times S
  \qquad
   C(\alpha) \times S + C(\beta) \times S \reduce C(\alpha + \beta) \times S
  \\
  \\
   C(0) \times S \reduce C(0)
  \qquad
   C(1) \times S \reduce S
  \qquad
   C(\alpha) \times C(\beta) \reduce C(\alpha \times \beta)
  \qquad
   S_1 \times (S_2 + S_3) \reduce S_1 \times S_2 + S_1 \times S_3
  \\
  \\
   C(\alpha)^* \reduce C(\alpha^*)
  \qquad
   \delta_{s, t}^* \reduce \delta_{s, t} \\
   (S_1 + S_2)^* \reduce S_1^* + S_2^*
  \qquad
   (S_1 \times S_2)^* \reduce S_1^* \times S_2^*
  \qquad
   (S^*)^* \reduce S
  \qquad
   (B \cdot K)^* \reduce K^\dagger \cdot B^\dagger
\end{gather*}



\subsubsection*{\textsf{SCR-DOT}}
\begin{gather*}
  \mathbf{0}_\mathcal{B} \cdot K \reduce C(0)
  \qquad
  B \cdot \mathbf{0}_\mathcal{K} \reduce C(0)
  \qquad
  (S.B) \cdot K \reduce S \times (B \cdot K)
  \qquad
  B \cdot (S.K) \reduce S \times (B \cdot K) \\
  (B_1 + B_2) \cdot K \reduce B_1 \cdot K + B_2 \cdot K
  \qquad
  B \cdot (K_1 + K_2) \reduce B \cdot K_1 + B \cdot K_2
  \qquad
  \bra{s} \cdot \ket{t} \reduce \delta_{s, t} \\
\end{gather*}

\begin{gather*}
  (B_1 \otimes B_2) \cdot \ket{t} \reduce (B_1 \cdot \ket{\fst\ t}) \times (B_2 \cdot \ket{\snd\ t}) \\
  \bra{t} \cdot (K_1 \otimes K_2) \reduce (\bra{\fst\ t} \cdot K_1) \times (\bra{\snd\ t} \cdot K_2) \\
  (B_1 \otimes B_2) \cdot (K_1 \otimes K_2) \reduce (B_1 \cdot K_1) \times (B_2 \cdot K_2)
\end{gather*}

\textbf{Remark:} The difficulty here comes from Hilbert space structure. The intuition is that, we decompose the multiplication (inner product) when at least one side is explicitly in tensor product form.

\subsubsection*{\textsf{SCR-SORT}}
\begin{gather*}
  (B \cdot O) \cdot K \reduce B \cdot (O \cdot K) \\
  \bra{s} \cdot ((O_1 \otimes O_2) \cdot K) \reduce ((\bra{\fst\ s} \cdot O_1) \otimes (\bra{\snd\ t} \cdot O_2)) \cdot K \\
  (B_1 \otimes B_2) \cdot ((O_1 \otimes O_2) \cdot K) \reduce ((B_1 \cdot O_1) \otimes (B_2 \cdot O_2)) \cdot K \\
\end{gather*}


\textbf{Remark:} Because we cannot use associative only symbols, we have to manually encode the decision logic. The first rule sorts the multiplication to the right, which breaks the symmetry of ket and bra. The remaining two rules are for completion.

\subsubsection*{\textsf{KET-ADJ}}
\begin{gather*}
  \textbf{0}_\mathcal{B}^\dagger \reduce \textbf{0}_\mathcal{K}
  \qquad
  \bra{t}^\dagger \reduce \ket{t}
  \qquad
  (K^\dagger)^\dagger \reduce K
  \qquad
  (S.B)^\dagger \reduce S^*.(B^\dagger) \\
  (B_1 + B_2)^\dagger \reduce B_1^\dagger + B_2^\dagger
  \qquad
  (B \cdot O)^\dagger \reduce O^\dagger \cdot B^\dagger
  \qquad
  (B_1 \otimes B_2)^\dagger \reduce B_1^\dagger \otimes B_2^\dagger
\end{gather*}

\subsubsection*{\textsf{KET-SCR}}
\begin{gather*}
  C(0).K \reduce \textbf{0}_{\mathcal{K}}
  \qquad
  C(1).K \reduce K
  \qquad
  S.\textbf{0}_\mathcal{K} \reduce \textbf{0}_\mathcal{K}
  \qquad
  S_1.(S_2.K) \reduce (S_1 \times S_2).K
  \qquad
  S.(K_1 + K_2) \reduce S.K_1 + S.K_2
\end{gather*}

\subsubsection*{\textsf{KET-ADD}}
\begin{gather*}
  K + \textbf{0}_\mathcal{K} \reduce K
  \qquad
  K + K \reduce C(1 + 1).K
  \qquad
  S.K + K \reduce (S + C(1)).K
  \qquad
  S_1.K + S_2.K \reduce (S_1 + S_2).K
\end{gather*}

\subsubsection*{\textsf{KET-MLT}}
\begin{gather*}
  \textbf{0}_\mathcal{O} \cdot K \reduce \textbf{0}_\mathcal{K}
  \qquad
  O \cdot \mathbf{0}_{\mathcal{K}} \reduce \mathbf{0}_{\mathcal{K}}
  \qquad
  \textbf{1}_\mathcal{O} \cdot K \reduce K \\
  (S.O) \cdot K \reduce S.(O \cdot K)
  \qquad
  O \cdot (S.K) \reduce S.(O \cdot K) \\
  (O_1 + O_2) \cdot K \reduce O_1 \cdot K + O_2 \cdot K
  \qquad
  O \cdot (K_1 + K_2) \reduce O \cdot K_1 + O \cdot K_2 \\
  \textcolor{red}{ (K_1 \otimes B) \cdot K_2 \reduce (B \cdot K_2).K_1}
  \qquad
  \textcolor{red}{ (O_1 \cdot O_2) \cdot K \reduce O_1 \cdot (O_2 \cdot K)} \\
  \textcolor{red}{ (O_1 \otimes O_2) \cdot ((O_1' \otimes O_2') \cdot K) \reduce ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2')) \cdot K} \\
  (O_1 \otimes O_2) \cdot \ket{t} \reduce (O_1 \cdot \ket{\fst\ t}) \otimes (O_2 \cdot \ket{\snd\ t}) \\
  (O_1 \otimes O_2) \cdot (K_1 \otimes K_2) \reduce (O_1 \cdot K_1) \otimes (O_2 \cdot K_2)
\end{gather*}

\textbf{Remark:} Again, the difficulty comes from space structure. The intuition for reductions is also the same: decompose the multiplication when at least one side is explicitly in tensor product form.


\subsubsection*{\textsf{KET-TSR}}
\begin{gather*}
  \mathbf{0}_\mathcal{K} \otimes K \reduce \mathbf{0}_\mathcal{K}
  \qquad
  K \otimes \mathbf{0}_\mathcal{K} \reduce \mathbf{0}_\mathcal{K}
  \qquad
  \ket{s} \otimes \ket{t}\reduce\ket{(s, t)} \\
  (S.K_1) \otimes K_2 \reduce S.(K_1 \otimes K_2)
  \qquad
  K_1 \otimes (S.K_2) \reduce S.(K_1 \otimes K_2) \\
  (K_1 + K_2) \otimes K_3 \reduce K_1 \otimes K_3 + K_2 \otimes K_3
  \qquad
  K_1 \otimes (K_2 + K_3) \reduce K_1 \otimes K_2 + K_1 \otimes K_3
\end{gather*}

\textbf{Remark: } The rules for bra are symmetric to the rules for ket. Only the correspondence of rules in red are different:

\begin{gather*}
  B_1 \cdot (K \otimes B_2) \reduce (B_1 \cdot K).B_2 \\
  B \cdot (O_1 \cdot O_2) \reduce (B \cdot O_1) \cdot O_2 \\
  (B \cdot (O_1 \otimes O_2)) \cdot (O_1' \otimes O_2') \reduce B \cdot ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2'))
\end{gather*}

\subsubsection*{\textsf{OPT-OUTER}}
\begin{gather*}
  \mathbf{0}_\mathcal{K} \otimes B \reduce \mathbf{0}_\mathcal{O}
  \qquad
  K \otimes \mathbf{0}_\mathcal{B} \reduce \mathbf{0}_\mathcal{O} \\
  (S.K) \otimes B \reduce S.(K \otimes B)
  \qquad
  K \otimes (S.B) \reduce S.(K \otimes B) \\
  (K_1 + K_2) \otimes B \reduce K_1 \otimes B + K_2 \otimes B
  \qquad
  K \otimes (B_1 + B_2) \reduce K \otimes B_1 + K \otimes B_2
\end{gather*}


\subsubsection*{\textsf{OPT-ADJ}}
\begin{gather*}
  \textbf{0}_\mathcal{O}^\dagger \reduce \textbf{0}_\mathcal{O}
  \qquad
  \textbf{1}_\mathcal{O}^\dagger \reduce \textbf{1}_\mathcal{O}
  \qquad
  (K \otimes B)^\dagger \reduce B^\dagger \otimes K^\dagger
  \qquad
  (O^\dagger)^\dagger \reduce O \\
  (S.O)^\dagger \reduce S^*.(O^\dagger)
  \qquad
  (O_1 + O_2)^\dagger \reduce O_1^\dagger + O_2^\dagger
  \qquad
  (O_1 \cdot O_2)^\dagger \reduce O_2^\dagger \cdot O_1^\dagger
  \qquad
  (O_1 \otimes O_2)^\dagger \reduce O_1^\dagger \otimes O_2^\dagger
\end{gather*}

\subsubsection*{\textsf{OPT-SCR}}
\begin{gather*}
  C(0).O \reduce \mathbf{0}_\mathcal{O}
  \qquad
  C(1).O \reduce O
  \qquad
  S.\textbf{0}_\mathcal{O} \reduce \textbf{0}_\mathcal{O} \\
  S_1.(S_2.O) \reduce (S_1 \times S_2).O
  \qquad
  S.(O_1 + O_2) \reduce S.O_1 + S.O_2
\end{gather*}

\subsubsection*{\textsf{OPT-ADD}}
\begin{gather*}
  O + \mathbf{0}_\mathcal{O} \reduce O
  \qquad
  O + O \reduce C(1 + 1).O
  \quad
  S.O + O \reduce (S + C(1)).O
  \quad
  S_1.O + S_2.O \reduce (S_1 + S_2).O
\end{gather*}

\subsubsection*{\textsf{OPT-MLT}}
\begin{gather*}
  \mathbf{0}_\mathcal{O} \cdot O \reduce \mathbf{0}_\mathcal{O}
  \qquad
  O \cdot \mathbf{0}_\mathcal{O} \reduce \mathbf{0}_\mathcal{O}
  \qquad
  \mathbf{1}_\mathcal{O} \cdot O \reduce O
  \qquad
  O \cdot \mathbf{1}_\mathcal{O} \reduce O \\
  (K \otimes B) \cdot O \reduce K \otimes (B \cdot O)
  \qquad
  O \cdot (K \otimes B) \reduce (O \cdot K) \otimes B\\
  (S.O_1) \cdot O_2 \reduce S.(O_1 \cdot O_2)
  \qquad
  O_1 \cdot (S.O_2) \reduce S.(O_1 \cdot O_2) \\
  (O_1 + O_2) \cdot O_3 \reduce O_1 \cdot O_3 + O_2 \cdot O_3
  \qquad
  O_1 \cdot (O_2 + O_3) \reduce O_1 \cdot O_2 + O_1 \cdot O_3 \\
  (O_1 \cdot O_2) \cdot O_3 \reduce O_1 \cdot (O_2 \cdot O_3) \\
  (O_1 \otimes O_2) \cdot (O_1' \otimes O_2') \reduce (O_1 \cdot O_1') \otimes (O_2 \cdot O_2') \\
  (O_1 \otimes O_2) \cdot ((O_1' \otimes O_2') \cdot O_3) \reduce ((O_1 \cdot O_1') \otimes (O_2 \cdot O_2')) \cdot O_3
\end{gather*}


\subsubsection*{\textsf{OPT-TSR}}
\begin{gather*}
  \mathbf{0}_\mathcal{O} \otimes O \reduce \mathbf{0}_\mathcal{O}
  \qquad
  O \otimes \mathbf{0}_\mathcal{O} \reduce \mathbf{0}_\mathcal{O} \\
  (K_1 \otimes B_1) \otimes (K_2 \otimes B_2) \reduce (K_1 \otimes K_2) \otimes (B_1 \otimes B_2) \\
  (S.O_1) \otimes O_2 \reduce S.(O_1 \otimes O_2)
  \qquad
  O_1 \otimes (S.O_2) \reduce S.(O_1 \otimes O_2) \\
  (O_1 + O_2) \otimes O_3 \reduce O_1 \otimes O_3 + O_2 \otimes O_3
  \qquad
  O_1 \otimes (O_2 + O_3) \reduce O_1 \otimes O_2 + O_1 \otimes O_3
\end{gather*}


\section{Confluence of $R_\mathfrak{DN}$}

We use \texttt{CiME2} to check the local confluence of the TRS of Dirac notation automatically.

We now present a smallest instantiation $R_{\Sigma_\mathcal{C}}$ of a complext scalar rewrite system. 

\begin{definition}[The rewrite system $R_{\Sigma_\mathcal{C}0}$]
  The system $R_{\Sigma_\mathcal{C}0}$ is defined by the following rules:
  \begin{gather*}
    0 + \alpha \reduce \alpha
    \qquad
    0 \times \alpha \reduce 0
    \qquad
    1 \times \alpha \reduce \alpha \\
    \alpha \times (\beta + \gamma) \reduce \alpha \times \beta + \alpha \times \gamma \\
    0^* \reduce 0
    \qquad
    1^* \reduce 1 \\
    (\alpha + \beta)^* \reduce \alpha^* + \beta^*
    \qquad
    (\alpha \times \beta)^* \reduce \alpha^* \times \beta^*
    \qquad
    (\alpha^*)^* \reduce \alpha
  \end{gather*}
  where $+$ and $\times$ are AC-symbols.
\end{definition}

We can compare the avatar $R_{\Sigma_\mathcal{C}0}$ above with the general complex number rewrite system $R_{\Sigma_\mathcal{C}}$ and prove the subsumption relation.

\begin{proposition}
  $R_{\Sigma_\mathcal{C}}$ subsumes $R_{\Sigma_\mathcal{C}0}$.
\end{proposition}

\begin{proof}
  Obvious.
\end{proof}


If a TRS $R$ contains AC-symbols, checking the critical pairs of $R$ is not enough to ensure the local confluence of $R$. This is because the LHS of rules can match the term unlocally. For example:
$$
(K_0 + K_1) + K_0 \reduce C(1 + 1).K_0 + K_1
$$
by the rule $ K + K \reduce C(1 + 1).K$. Therefore, to prove the confluence of a AC-rewrite system, we need to consider an extended system, as indicated by the following definition.

\begin{definition}[The extension rules]
  Let $X$ be a AC-rewrite system with AC symbols $f_1, \cdots, f_n$. We define the AC-rewrite system $X_{ext}$ as containing the same AC symbols as $X$, the same rules as $X$, plus the rule $f_i(t, x) \to f_i(u, x)$ for each rule $t \to u$ of $X$ where the head symbol of $t$ is $f_i$.
\end{definition}

This extension rules are automatically added for all rules encoded in \texttt{CiME2}.

\begin{proposition}
  The system $R_\mathfrak{DN} \cup R_{\Sigma_\mathcal{C}0}$ is locally confluent.
\end{proposition}
\begin{proof}
  Encoded and checked in \texttt{CiME2}.
\end{proof}


\begin{lemma}[confluence of $R_\mathfrak{DN}$]
  For any complex number rewrite system $R_{\Sigma_\mathcal{A}}$ and atomic basis rewrite system $R_{\Sigma_\mathcal{C}}$, the system $R_\mathfrak{DN} \cup R_{\Sigma_\mathcal{A}} \cup R_{\Sigma_\mathcal{C}}$ is confluence.
\end{lemma}
\begin{proof}
  Both $R_{\Sigma_\mathcal{A}}$ and $R_{\Sigma_\mathcal{C}}$ are terminating and confluent by definition. 
  The system $R_{\Sigma_\mathcal{C}}$ subsumes $R_{\Sigma_\mathcal{C}0}$, and $R_{\Sigma_\mathcal{A}}$ subsumes an empty rewriting system. 
  The system $R_\mathfrak{DN} \cup R_{\Sigma_\mathcal{C}0}$ is locally confluent. 
  The system $R_{\Sigma_\mathcal{C}}$ commutes with $R_\mathfrak{DN}^*$, because the terms in $\Sigma_\mathcal{C}$ appears in the left hand sides of rules in $R_\mathfrak{DN}$ only as variables and constants $0, 1$, therefore all the rules in $R_{\Sigma_\mathcal{C}}$ commutes with $R_\mathfrak{DN}^*$. 
  Then the avatar lemma finishes the proof.
\end{proof}


% \subsection{Checking by \texttt{CiME}}

% We encoded the typed Dirac notation in a simple TRS and checked the confluence of the whole system. Here is a summary of the rules.


% \begin{center}
%   \begin{tabular}{c|c}
%   \hline
%   Type & Rule Number \\
%   \hline
%   type checking & 27 \\
%   overloading polymorphic symbols & 22 \\
%   complex scalar avatar & 9 \\
%   Dirac notation & 141 \\
%   AC-symbol extension rules & 25 \\
%   \hline
%   Total & 224 \\
%   \hline
%   \end{tabular}
% \end{center}

% And all the 3133 critical pairs are joinable.

% \subsubsection*{About Reduandancy}
% I also checked through a \texttt{Python} script that removing any of the reduction rule will lead to non-confluence or change of the equational theory. For example, I found that removing 
% $$
%  (\fst\ e, \snd\ e)\reduce e
% $$
% or
% $$
%  (K_1 \otimes B_1) \otimes (K_2 \otimes B_2) \reduce (K_1 \otimes K_2) \otimes (B_1 \otimes B_2)
% $$
% respectively will still lead to a confluence TRS, but the equivalence induced by the TRS will be be changed.


\section{Termination of $R_\mathfrak{DN}$}

TODO.

\section{Soundness and Completeness of $R_\mathfrak{DN}$}

To evaluate the reliability and capability of $R_\mathfrak{DN}$, we consider their soundness and correctness, which are defined and proved below.

\begin{definition}[soundness and completeness]
  A formal system $F$ is sound to decide $\mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$ if for all $X, Y \in \mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, $F \vdash X = Y$ implies $\sem{X} = \sem{Y}$. If for another formal proof system $G$, for all $X, Y \in \mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, $G \vdash X = Y$ implies $F \vdash X = Y$, we say the system $F$ is complete for $G$.
\end{definition}

\begin{lemma}[soundness of $R_\mathfrak{DN}$]
  The system $R_\mathfrak{DN}$ is sound.
\end{lemma}
\begin{proof}
  The proof is a formalization in \texttt{CoqQ}. Based on the constructions of linear space, we encoded the language syntax and denotational semantics, and proved that for all rules $e_1 \reduce e_2$ in $R_\mathfrak{DN}$, the proposition $\sem{e_1} = \sem{e_2}$ holds.
\end{proof}

Then We consider completeness. The two deduction rules (*) and (**) in \ref{def: SCR-DELTA} cannot be encoded and proved in the term rewrite system $R_\mathfrak{DN}$. Other axioms are checked by normalizing both sides of the equations.

\begin{lemma}[relative completeness of $R_\mathfrak{DN}$]
  For any complete rewrite system $R_{\Sigma_\mathcal{A}}$ and $R_{\Sigma_\mathcal{E}}$, the system $R_\mathfrak{DN}\cup R_{\Sigma_\mathcal{A}} \cup R_{\Sigma_\mathcal{E}}$ is complete for the axiomatic semantics $AX$ excluding (*), (**).
\end{lemma}
\begin{proof}
  Encoded and calculated in the implementation of $R_\mathfrak{DN}$.
\end{proof}

The above results generally means that the TRS $R_\mathfrak{DN}$ is sound for the denotational semantics, and is not weaker than the axiomatic semantics. Combining these two, we can easily prove the consistency of the two sematnics as a byproduct.

\begin{lemma}[consistency of denotational and axiomatic semantics]
  The axiomatic semantics is consistent with the denotational one. In other words, for all $X, Y \in \mathfrak{DN}(\Sigma_\mathcal{A}, \Sigma_\mathcal{C})$, if $AX \vdash X = Y$, then $\sem{X} = \sem{Y}$.
\end{lemma}
\begin{proof}
  By induction on the proof by $AX$. The cases of axioms in $AX$ are proved by the relative completeness and soundness of $R_\mathfrak{DN}$. The deduction rules (*) and (**) in \ref{def: SCR-DELTA} can be checked by hand.
  \yx{A small problem here. Difference in s, t symbols does not imply that their semantical explanations are different. I should modify the premises of (*) and (**).}
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Extension: Sum and Transpose}

\yx{introduce a language of sets here}

\begin{definition}[Multi-set]
  \begin{align*}
    M ::= \emptyset\ |\ \mathbf{U}\ |\ M \cup M
  \end{align*}
\end{definition}

\subsubsection*{\textsf{SET-SIMP}}
\begin{gather*}
  \emptyset \cup M \reduce M
  \qquad
  \mathbf{U} \cup M \reduce \mathbf{U}
\end{gather*}

\begin{definition}[DNE]
    The \textbf{language of Dirac Notation Extended}, denoted as $\mathfrak{DNE}(\Sigma_\mathcal{B}, \Sigma_\mathcal{S})$, consists of the same sorts as the core language and the following new symbols:
    \begin{align*}
        & S ::= \sum_{i \in M} S\ |\ \lambda x.S\ |\ S\ t && K ::= B^\top\ |\ \sum_{i \in M} K\ |\ \lambda x.K\ |\ K\ t \\
        & B ::= K^\top\ |\ \sum_{i \in M} B\ |\ \lambda x.B\ |\ B\ t && O ::= O^\top\ |\ \sum_{i \in M} O\ |\ \lambda x.O\ |\ O\ t
    \end{align*}
    The index $i$ for summation is a bind variable, and $M$ is the variable for the multiset of summation. The common equivalence involving bind variables are adopted here: $\alpha$-conversion and substitutions.
\end{definition}

\section{TRS for DNE}

\subsubsection*{\textsf{BETA-REDUCTION}}
\begin{gather*}
  (\lambda x.A)\ t \reduce A[x:=t]
\end{gather*}
\textbf{Reamrk:} We need abstraction and application to represent Dirac notations dependent on some variable. For example, $\sum_{i \in M} v_i$.

\subsubsection*{\textsf{TRANS-KET}}
\begin{gather*}
  \mathbf{0}_\mathcal{B}^\top \reduce \mathbf{0}_\mathcal{K}
  \qquad
  \bra{s}^\top \reduce \ket{s}
  \qquad
  (K^\dagger)^\top \reduce (K^\top)^\dagger
  \qquad
  (K^\top)^\top \reduce K \\
  (S . B)^\top \reduce S . B^\top
  \qquad
  (B_1 + B_2)^\top \reduce B_1^\top + B_2^\top
  \qquad
  (B \cdot O)^\top \reduce O^\top \cdot B^\top
  \qquad
  (B_1 \otimes B_2)^\top \reduce B_1^\top \otimes B_2^\top
\end{gather*}

\subsubsection*{\textsf{TRANS-BRA}}
\begin{gather*}
  \mathbf{0}_\mathcal{K}^\top \reduce \mathbf{0}_\mathcal{B}
  \qquad
  \ket{s}^\top \reduce \bra{s}
  \qquad
  (B^\dagger)^\top \reduce (B^\top)^\dagger
  \qquad
  (B^\top)^\top \reduce B \\
  (S . K)^\top \reduce S . K^\top
  \qquad
  (K_1 + K_2)^\top \reduce K_1^\top + K_2^\top
  \qquad
  (O \cdot K)^\top \reduce K^\top \cdot O^\top
  \qquad
  (K_1 \otimes K_2)^\top \reduce K_1^\top \otimes K_2^\top
\end{gather*}



\subsubsection*{\textsf{TRANS-OPT}}
\begin{gather*}
  \mathbf{0}_\mathcal{O}^\top \reduce \mathbf{0}_\mathcal{O}
  \qquad
  \mathbf{1}_\mathcal{O}^\top \reduce \mathbf{1}_\mathcal{O}
  \qquad
  (K \otimes B)^\top \reduce B^\top \otimes K^\top
  \qquad
  (O^\dagger)^\top \reduce (O^\top)^\dagger
  \qquad
  (O^\top)^\top \reduce O \\
  (S . O)^\top \reduce S . O^\top
  \qquad
  (O_1 + O_2)^\top \reduce O_1^\top + O_2^\top
  \qquad
  (O_1 \cdot O_2)^\top \reduce O_2^\top \cdot O_1^\top
  \qquad
  (O_1 \otimes O_2)^\top \reduce O_1^\top \otimes O_2^\top
\end{gather*}

\textbf{Remark:} It has been checked by CiME2 that for the TRS $\mathfrak{DN}$ extended with transpose rules, the only unjoinable critical pairs are joinable with the equational theory $B\cdot K = K^\top \cdot B^\top$.


\subsubsection*{\textsf{SUM-ELIM}}

\begin{gather*}
  \sum_{i \in M} C(0) \reduce C(0)
  \qquad
  \sum_{i \in M} \mathbf{0}_\mathcal{K} \reduce \mathbf{0}_\mathcal{K}
  \qquad
  \sum_{i \in M} \mathbf{0}_\mathcal{B} \reduce \mathbf{0}_\mathcal{B}
  \qquad
  \sum_{i \in M} \mathbf{0}_\mathcal{O} \reduce \mathbf{0}_\mathcal{O}
\end{gather*}

One common condition is attached to all the following rules: variable $i$ does not have free appearance in term $s$

Here $S.A$ is interpreted as three cases: $S.K$, $S.B$ and $S.O$.
\begin{gather*}
  \sum_{i \in \mathbf{U}} \delta_{i, s} \reduce C(1)
  \qquad
  \sum_{i \in \mathbf{U}} (\delta_{i, s} \times S) \reduce S[i:=s] \\
  \sum_{i \in \mathbf{U}} (\delta_{i, s}.A) \reduce A[i:=s]
  \qquad
  \sum_{i \in \mathbf{U}} ((\delta_{i, s} \times S).A) \reduce S[i:=s].A[i:=s]
\end{gather*}

\textbf{Remark:} To avoid problems, we assume that bind variables cannot be substituted into sum expressions. For example:
$$
\sum_{i \in M} \delta_{i, s}[s:=i^2] \equiv \sum_{j \in M} \delta_{j, i^2}.
$$
In other words, the variables will never implicitly depend on bind variables.

\subsubsection*{\textsf{SUM-DIST}}

Here the $A^\dagger$, $A^\top$, $S.A$ and addition are interpreted in three sorts: ket, bra and operator.
The bind variable $i$ does not appear in $X$.
Here $A \cdot B$ is interpreted as four cases: $B \cdot K$, $O \cdot K$, $B \cdot O$ and $O_1 \cdot O_2$. $A \otimes B$ is interpreted as four cases: $K_1 \otimes K_2$, $B_1 \otimes B_2$, $K \otimes B$ and $O_1 \otimes O_2$.

\begin{gather*}
  \sum_{i \in M} (S_1 \times X) \reduce (\sum_{i \in M} S_1) \times X
  \qquad
  (\sum_{i \in M} S)^* \reduce \sum_{i \in M} S^* \\
  (\sum_{i \in M} A)^\dagger \reduce \sum_{i \in M} A^\dagger
  \qquad
  (\sum_{i \in M} A)^\top \reduce \sum_{i \in M} A^\top \\
  \sum_{i \in M} (X.A) \reduce X.(\sum_{i \in M} A)
  \qquad
  \sum_{i \in M} (S.X) \reduce (\sum_{i \in M} S). X \\
  \sum_{i \in M} (A \cdot X) \reduce (\sum_{i \in M} A) \cdot X
  \qquad
  \sum_{i \in M} (X \cdot B) \reduce X \cdot (\sum_{i \in M} B) \\
  \sum_{i \in M} (A \otimes X) \reduce (\sum_{i \in M} A) \otimes X
  \qquad
  \sum_{i \in M} (X \otimes B) \reduce X \otimes (\sum_{i \in M} B)
\end{gather*}

\subsubsection*{About \textsf{SUM-DIST}: push in or pull out?}
We can flip the direction of the rules in \textsf{SUM-DIST} to pull elements out of the summation. I believe the difference lies in the \textbf{information of bind variable dependencices}.

When pushing inside, the information of bind variable independence is lost. This makes elimination rule less complete. Maybe we want to do in the opposite way: pull everything out as much as possible. Those rules involve checking whether the subterm to be pulled out is independent on the bind variable. But this strategy makes matching elimination rule simpler.


\subsubsection*{\textsf{SUM-COMP}}
These rules are for completion.

\begin{gather*}
  \frac{A \cdot B \reduce C \qquad \text{(bind variable renamed)}}{A \cdot (\sum_{i \in M} B) \reduce \sum_{i \in M} C}
  \qquad
  \frac{A \cdot B \reduce C \qquad \text{(bind variable renamed)}}{(\sum_{i \in M} A) \cdot B \reduce \sum_{i \in M} C} \\
  \\
  \frac{A \otimes B \reduce C \qquad \text{(bind variable renamed)}}{A \otimes (\sum_{i \in M} B) \reduce \sum_{i \in M} C}
  \qquad
  \frac{A \otimes B \reduce C \qquad \text{(bind variable renamed)}}{(\sum_{i \in M} A) \otimes B \reduce \sum_{i \in M} C} \\
  \\
  \frac{S \neq C(1), i \text{ is free in } S}{\sum_{i \in M} S \reduce (\sum_{i \in M} C(1)) \times S}
  \qquad
  \frac{i \text{ is free in } A}{\sum_{i \in M} A \reduce (\sum_{i \in M} C(1)).A}
\end{gather*}

\subsubsection*{\textsf{SUM-ADD}}
Here the addition $A + B$ is interpreted in four sorts: scalar, ket, bra and operator.
\begin{align*}
  & (\sum_{i \in M} A) + (\sum_{j \in N} B) \reduce \sum_{k \in M \cup N} (A[i:=k] + B[j:=k])
\end{align*}

\subsection{Controlled Rewriting}

The following equalities hold for ket, bra and operators respectively, but there are no appropriate normal forms. 
\begin{gather*}
  \sum_i (\bra{i} \cdot K).\ket{i} = K
  \qquad
  \sum_i (B \cdot \ket{i}).\bra{i} = B \\
  \sum_i \sum_j (\bra{i} A \ket{j}).\ket{i}\bra{j} = A
  \qquad
  \sum_i \sum_j (\bra{i} A \ket{j}).\ket{j}\bra{i} = A^\top
\end{gather*}

We leave the control to the user by two functions: \textbf{EntryReduce} rewrite from left to right, and \textbf{EntryExpand} rewrite from right to left.

\subsection{Equivalence Checking}

Our goal is to design the algorithm that checks whether two terms are equivalent. Ideally this can be achieved by rewriting to normal forms, but for complicated scenarios, the normal form may not exist. This is the case with transpose and big operator. We have these axioms: 
\begin{align*}
& \text{(DOT-DUAL)} && B \cdot K = K^\top \cdot B^\top \\
& \text{(SUM-SWAP)} && \sum_{i \in M} \sum_{j \in N} A = \sum_{j \in N} \sum_{i \in M} A 
\end{align*}

Our algorithm for deciding equivalence takes these equations into consideration.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Labelled Dirac Notation}

\begin{definition}[quantum registers]
  \begin{align*}
    R ::= x\ |\ (R, R)\ |\ \fst\ R\ |\ \snd\ R
  \end{align*}
  We define the following relations for quantum registers:
  \begin{itemize}
    \item $R$ \textbf{belongs to} $Q$, written as $R\ \text{in}\ Q$,
    \item $R$ \textbf{is disjoint with} $Q$, written as $R \| Q$.
  \end{itemize}
\end{definition}

\textbf{Remark:} We still have a speical algorithm deciding the relations.

\begin{definition}[register set]
  \begin{align*}
    S ::= \emptyset\ |\ \{ R \} \ |\ S \cup S\ |\ S \setminus S
  \end{align*}
\end{definition}

\textbf{Remark: } $ S_1 \cap S_2 \equiv S_1 \cup S_2 \setminus (S_1 \setminus S_2) \setminus (S_2 \setminus S_1) $

\subsubsection*{\textsf{REG}}
\begin{gather*}
  \fst\ (R_1, R_2) \reduce R_1 \qquad 
  \snd\ (R_1, R_2) \reduce R_2 \qquad
  (\fst\ R, \snd\ R) \reduce R
\end{gather*}


\subsubsection*{\textsf{RSET}}
\begin{gather*}
  S \cup \emptyset \reduce S
  \qquad
  S \cup S \reduce S
  \qquad
  \{ \fst\ R \} \cup \{ \snd\ R \} \reduce R \\
  S \setminus \emptyset \reduce S
  \qquad
  \emptyset \setminus S \reduce \emptyset
  \qquad
  S \setminus S \reduce \emptyset \\
  (S_1 \cup S_2) \setminus X \reduce (S_1 \setminus X) \cup (S_2 \setminus X)
  \qquad
  S_1 \setminus (S_2 \cup S_3) \reduce (S_1 \setminus S_2) \setminus S_3 \\
  \\
  \frac{ R_1 \textrm{ in } R_2 }{ \{ R_1 \} \cup \{ R_2 \} \reduce \{ R_2 \} }
  \qquad
  \frac{ R_1 \textrm{ in } R_2 }{ \{ R_1 \} \setminus \{ R_2 \} \reduce \emptyset } \\
  \\
  \frac{ R_1 \textrm{ in } R_2 }{ \{R_2\} \setminus \{R_1\} \reduce (\{\fst\ R_2\} \setminus \{R_1\}) \cup (\{\snd\ R_2\} \setminus \{R_1\})}
  \qquad
  \frac{R_1 \| R_2}{ \{ R_1 \} \setminus \{ R_2 \} \reduce \{ R_1 \}} 
\end{gather*}

\begin{definition}[labelled core language]
  The \textbf{labelled core langauge} includes all symbols in the core language of Dirac notation, as well as symbols for the three new sorts.
  \begin{align*}
    & && S ::=\ \tilde{B} \cdot \tilde{K} \\
    & \tilde{\mathcal{K}}\text{(labelled ket)}&& \tilde{K} ::=\ K_{R}\ |\ \tilde{B}^\dagger\ |\ S.\tilde{K}\ |\ \tilde{K} + \tilde{K}\ |\ \tilde{O} \cdot \tilde{K}\ |\ \tilde{K} \otimes \tilde{K} \\
    & \tilde{\mathcal{B}}\text{(labelled bra)} && \tilde{B} ::=\ B_{R}\ |\ \tilde{K}^\dagger\ |\ S.\tilde{B}\ |\ \tilde{B} + \tilde{B}\ |\ \tilde{B} \cdot \tilde{O}\ |\ \tilde{B} \otimes \tilde{B} \\
    & \tilde{\mathcal{O}}\text{(labelled operator)} &&\tilde{O} ::=\ O_{R; R}\ |\ \tilde{K}\otimes\tilde{B}\ |\ \tilde{O}^\dagger\ |\ S.\tilde{O}\ |\ \tilde{O} + \tilde{O}\ |\ \tilde{O} \cdot \tilde{O}\ |\ \tilde{O} \otimes \tilde{O}
  \end{align*}
  In other words, we don't allow variables for labelled core language for now.
\end{definition}

\subsubsection*{\textsf{LABEL-CORE}}
We generally copied the symbols ($\dagger, S.\tilde{X}, +, \cdot, \otimes$) from the core language. Therefore we also need a copy of the corresponding rewriting rules.

\subsubsection*{\textsf{TSR-DECOMP}}

\begin{gather*}
  \ket{(s, t)}_{(Q, R)} \reduce \ket{s}_{Q} \otimes \ket{t}_{R}
  \qquad
  \bra{(s, t)}_{(Q, R)} \reduce \bra{s}_{Q} \otimes \bra{s}_{R} \\
  {\mathbf{0}_\mathcal{K}}_{(Q, R)} \reduce {\mathbf{0}_\mathcal{K}}_{Q} \otimes {\mathbf{0}_\mathcal{K}}_{R}
  \qquad
  {\mathbf{0}_\mathcal{B}}_{(Q, R)} \reduce {\mathbf{0}_\mathcal{B}}_{Q} \otimes {\mathbf{0}_\mathcal{B}}_{R} \\
  {\mathbf{0}_\mathcal{O}}_{(Q, R); (S, T)} \reduce {\mathbf{0}_\mathcal{O}}_{(Q, S)} \otimes {\mathbf{0}_\mathcal{O}}_{(R, T)} \\
  {\mathbf{0}_\mathcal{O}}_{(Q_1, Q_2); R} \reduce {\mathbf{0}_\mathcal{O}}_{Q_1; \fst\ R} \otimes {\mathbf{0}_\mathcal{O}}_{Q_2; \fst\ R}
  \qquad
  {\mathbf{0}_\mathcal{O}}_{Q; (R_1, R_2)} \reduce {\mathbf{0}_\mathcal{O}}_{\fst\ Q; R_1} \otimes {\mathbf{0}_\mathcal{O}}_{\snd\ Q; R_2} \\
  {\mathbf{1}_\mathcal{O}}_{(Q, R); (Q, R)} \reduce {\mathbf{1}_\mathcal{O}}_{Q; Q} \otimes {\mathbf{1}_\mathcal{O}}_{R; R} \\
  {\mathbf{1}_\mathcal{O}}_{(Q_1, Q_2); R} \reduce {\mathbf{1}_\mathcal{O}}_{Q_1; \fst\ R} \otimes {\mathbf{1}_\mathcal{O}}_{Q_2; \fst\ R}
  \qquad
  {\mathbf{1}_\mathcal{O}}_{Q; (R_1, R_2)} \reduce {\mathbf{1}_\mathcal{O}}_{\fst\ Q; R_1} \otimes {\mathbf{1}_\mathcal{O}}_{\snd\ Q; R_2}
\end{gather*}
\begin{gather*}
  (K_1 \otimes K_2)_{(Q, R)} \reduce {K_1}_{Q} \otimes {K_2}_{R}
  \qquad
  (B_1 \otimes B_2)_{(Q, R)} \reduce {B_1}_{Q} \otimes {B_2}_{R} \\
  (O_1 \otimes O_2)_{(Q, R); (S, T)} \reduce {O_1}_{Q; S} \otimes {O_2}_{R; T} \\
  (O_1 \otimes O_2)_{(Q_1, Q_2); R} \reduce {O_1}_{Q_1; \fst\ R} \otimes {O_2}_{Q_2; \snd\ R}
  \qquad
  (O_1 \otimes O_2)_{Q; (R_1, R_2)} \reduce {O_1}_{\fst\ Q; R_1} \otimes {O_2}_{\snd\ Q; R_2}
\end{gather*}


\subsubsection*{\textsf{TSR-COMP}}
\begin{gather*}
  {K_1}_{\fst\ R} \otimes {K_1}_{\snd\ R} \reduce (K_1 \otimes K_2)_{R}
  \qquad
  {B_1}_{\fst\ R} \otimes {B_2}_{\snd\ R} \reduce (B_1 \otimes B_2)_{R} \\
  {O_1}_{\fst\ Q; \fst\ R} \otimes {O_2}_{\snd\ Q; \snd\ R} \reduce (O_1 \otimes O_2)_{Q; R}
\end{gather*}

\subsubsection*{\textsf{DOT-TSR}}
\begin{align*}
  \frac{R \| S}{{O_1}_{Q; R} \cdot {O_2}_{S; T} \reduce {O_1}_{Q; R} \otimes {O_2}_{S; T}}
\end{align*}

\subsubsection*{\textsf{LABEL-LIFT}}
\begin{gather*}
  (K_{R})^\dagger \reduce (K^\dagger)_{R}
  \qquad
  (B_{R})^\dagger \reduce (B^\dagger)_{R}
  \qquad
  (O_{Q; R})^\dagger \reduce (O^\dagger)_{Q; R} \\
  (K_{R})^\top \reduce (K^\top)_{R}
  \qquad
  (B_{R})^\top \reduce (B^\top)_{R}
  \qquad
  (O_{Q; R})^\top \reduce (O^\top)_{Q; R} \\
  (S.K)_{R} \reduce S.(K_{R})
  \qquad
  (S.B)_{R} \reduce S.(B_{R})
  \qquad
  (S.O)_{Q; R} \reduce S.(O_{Q; R}) \\
  (K_1 + K_2)_{R} \reduce {K_1}_{R} + {K_2}_{R}
  \qquad
  (B_1 + B_2)_{R} \reduce {B_1}_{R} + {B_2}_{R}
  \qquad
  (O_1 + O_2)_{Q; R} \reduce {O_1}_{Q; R} + {O_2}_{Q; R}
\end{gather*}
\begin{gather*}
  {O_1}_{Q; R} \cdot {O_2}_{R; S} \reduce (O_1 \cdot O_2)_{Q; S}
  \qquad
  O_{Q; R} \cdot K_{R} \reduce (O \cdot K)_{Q}
  \qquad
  B_{Q} \cdot O_{Q; R} \reduce (B \cdot O)_{R} \\
  B_{R} \cdot K_{R} \reduce B \cdot K \\
  (K \otimes B)_{Q; R} \reduce K_{Q} \otimes B_{R}
\end{gather*}

\subsubsection*{\textsf{OPT-EXT}}
I think the concept ``cylinder extension'' is only limited to endomorphisms. Besides, one quantum register should a sub-register of the other one, which is defined as follows:

\begin{definition}[sub-register]
  \begin{gather*}
    \fst\ R \preceq R \qquad \snd\ R \preceq R \qquad Q \preceq (Q, R) \qquad R \preceq (Q, R)
    \qquad 
    \frac{Q \preceq R \qquad R \preceq S}{Q \preceq S}
  \end{gather*}

  And we can further calculate the ``position'' of sub-register, which will be utilized during cylinder extension: assume $Q$ is a sub-register of $R$, then the position of $Q$ in $R$ is a string defined as follows:
  \begin{align*}
    & \textrm{pos}(\fst\ R, R) = 0 \\
    & \textrm{pos}(\snd\ R, R) = 1 \\
    & \textrm{pos}(Q, (Q, R)) = 0 \\
    & \textrm{pos}(R, (Q, R)) = 1 \\
    & \textrm{pos}(Q, S) = \textrm{pos}(R, S)\ \textrm{pos}(Q, R)
  \end{align*}
\end{definition}

\textbf{Remark:} For a well-formed quantum register, the sub-register position is well-defined.

\begin{definition}[cylinder extension]
  \begin{align*}
    \textrm{ext}(O, \epsilon) \equiv O
    && \textrm{ext}(O, p::0) \equiv O \otimes \mathbf{1}_\mathcal{O}
    && \textrm{ext}(O, p::1) \equiv \mathbf{1}_\mathcal{O} \otimes O
  \end{align*}
\end{definition}

\subsubsection*{\textsf{CYLINDER-EXT}}
\begin{gather*}
  \frac{Q \textrm{ is a subterm of } R \textrm{ at } p}{O_{Q; Q} \cdot K_{R} \reduce (\textrm{ext}(O, p) \cdot K)_{R}}
  \qquad
  \frac{Q \textrm{ is a subterm of } R \textrm{ at } p}{{O_1}_{Q; Q} \cdot {O_2}_{R; T} \reduce (\textrm{ext}(O_1, p) \cdot O_2)_{R; T}} \\
  \\
  \frac{R \textrm{ is a subterm of } Q \textrm{ at } p}{B_{Q} \cdot O_{R; R} \reduce (B \cdot \textrm{ext}(O, p))_{Q}}
  \qquad
  \frac{R \textrm{ is a subterm of } Q \textrm{ at } p}{{O_1}_{T; Q} \cdot {O_2}_{R; T} \reduce (O_1 \cdot \textrm{ext}(O_2, p))_{T; Q}} \\
\end{gather*}


\subsection{Labelled Extended Language}
\begin{definition}[labelled extended language]
  The \textbf{labelled extended language} consists of the symbols in labelled core langauge and unlabelled extended language, and add the new symbols of transpose and big-op for labelled bra, ket and operators, which is described in the following.
  \begin{align*}
    \tilde{K} ::= \tilde{B}^\top\ |\ \sum_{i \in M} \tilde{K}
    && \tilde{B} ::= \tilde{K}^\top\ |\ \sum_{i \in M} \tilde{B}
    && \tilde{O} ::= \tilde{O}^\top\ |\ \sum_{i \in M} \tilde{O}
  \end{align*}
  
\end{definition}


\subsubsection*{\textsf{LABEL-SUM}}
\begin{gather*}
  (\sum_{i \in M} K)_{R} \reduce \sum_{i \in M} (K_{R})
  \qquad
  (\sum_{i \in M} B)_{R} \reduce \sum_{i \in M} (B_{R})
  \qquad
  (\sum_{i \in M} O)_{Q; R} \reduce \sum_{i \in M} (O_{Q; R})
\end{gather*}

\subsubsection*{\textsf{LABEL-TEMP}}
\yx{These are ad-hoc rules for the examples for now. They are still not organized and require further investigations.}
\begin{gather*}
  \frac{R \textsf{ in } Q}{O_{P; R} \cdot (K_{Q} \otimes \tilde{K'}) \reduce (O_{P; R} \cdot K_{Q}) \otimes \tilde{K'}} 
  \qquad
  \frac{R \textsf{ in } Q}{O_{P; R} \cdot (K_{Q} \otimes \tilde{B}) \reduce (O_{P; R} \cdot K_{Q}) \otimes \tilde{B}} \\
  \\
  \frac{R \textsf{ in } Q}{{O_1}_{P; R} \cdot ({O_2}_{Q; T} \otimes \tilde{O_3}) \reduce ({O_1}_{P; R} \cdot {O_2}_{Q; T}) \otimes \tilde{O_3}} \\
  \\
  \frac{Q \textsf{ in } R}{(B_{R} \otimes \tilde{B'}) \cdot O_{Q;P} \reduce (B_{R} \cdot O_{Q;P}) \otimes \tilde{B'}} 
  \qquad
  \frac{Q \textsf{ in } R}{({O_1}_{T;R} \otimes \tilde{O'}) \cdot {O_2}_{Q;P} \reduce ({O_1}_{T;R} \cdot {O_2}_{Q;P}) \otimes \tilde{O'}} \\
  \\
  B_{R} \cdot (K_{R} \otimes \tilde{B'}) \reduce (B_{R} \cdot K_{R}) . \tilde{B'} 
  \qquad
  (\tilde{K'} \otimes B_{R}) \cdot K_{R} \reduce (B_{R} \cdot K_{R}) . \tilde{K'}
\end{gather*}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Typed Dirac Notation}
The untyped Dirac notation is hard to use because we explicitly need different symbols to distinguish between the ambiguous semantics of the same syntax. We will use a typed version as the front-end language for the user, which is introduced below.



\subsection{Syntax and Typing}


\begin{definition}[types of Dirac notation core language]
  The \textbf{type of core language} is defined by
  \begin{align*}
    \tau ::= x\ |\ T\ |\ (\tau * \tau)\ |\ S\ |\ B(\tau)\ |\ K(\tau)\ |\ O(\tau, \tau)
  \end{align*}

  Here $x$ is a variable and $T$ is a constant of type. The $T$ and $(\tau * \tau)$ rules generate \textbf{types of spaces}. And the following rules generate \textbf{types of Dirac notations}.
\end{definition}
We use the set of orthonormal basis to represent the type of a Hilbert space. For example, the constant of the type for qubit Hilbert spaces is $\{0, 1\}$.

\begin{definition}[terms of Dirac notation core language]
  The \textbf{term of Dirac notations} $\mathfrak{DN}(\Sigma_\mathcal{B})$ is defined by
  \begin{align*}
    t ::= \ & x\ |\ b\ |\ (t, t)\ |\ \fst\ t\ |\ \snd\ t  && \text{(basis)} \\
    e ::= \ 
      &    x                          \\
      & |\ C(\alpha)                     && \text{(complex scalar)}   \\
      & |\ \delta_{t, t}              && \text{(Delta expression)} \\
      & |\ e + e                      && \text{(addition)} \\
      & |\ e \times e                 && \text{(multiplication)} \\
      & |\ \mathbf{0}_{\mathcal{K}(\tau)}\ |\ \mathbf{0}_{\mathcal{B}(\tau)}\ |\ \mathbf{0}_{\mathcal{O}(\tau, \tau)}    && \text{(zero operator)}\\
      & |\ \mathbf{1}_{\mathcal{O}(\tau)} && \text{(identity operator)}\\
      & |\ \ket{t}                    && \text{(ket)} \\
      & |\ \bra{t}                    && \text{(bra)} \\
      & |\ e^\dagger                        && \text{(adjoint or conjugate)} \\
      & |\ e \cdot e                  && \text{(multiplication)} \\
      & |\ e \otimes e                && \text{(tensor product)}
  \end{align*}
  Here $x$ is a variable, $b$ is a constant base, and $\alpha$ is a term in the underlining complex scalar language $\Sigma_\mathcal{B}$.
\end{definition}

\begin{definition}[typing rules]
  A typing assumption has the form $x : \tau$, meaning variable $x$ has the type $\tau$. A typing context $\Gamma$ consists of typing assumptions and each variable appears only once.

  A typing judgement $\Gamma \vdash e : \sigma$ indicates that $e$ is a term of type $\sigma$ in context $\Gamma$. The well-typed terms are defined by the following rules:
  \begin{gather*}
    \frac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}
  \end{gather*}
  Basis:
  \begin{gather*}
    \frac{b\ \textrm{is an atomic base of}\ T}{\Gamma \vdash b : T}\\
    \\
    \frac{\Gamma \vdash e_1 : \tau \qquad \Gamma \vdash e_2 : \sigma}{\Gamma \vdash (e_1, e_2) : ( \tau * \sigma )}
    \qquad
    \frac{\Gamma \vdash e : ( \tau * \sigma ) }{\Gamma \vdash \fst\ e : \tau}
    \qquad
    \frac{\Gamma \vdash e : ( \tau * \sigma ) }{\Gamma \vdash \snd\ e : \sigma} \\
  \end{gather*}
  Complex Scalar:
  \begin{gather*}
    \frac{}{\Gamma \vdash C(\alpha) : S}
    \qquad
    \frac{\Gamma \vdash s : \rho \qquad \Gamma \vdash t : \rho}{\Gamma \vdash \delta_{s, t} : S}
  \end{gather*}
  Ket and Bra:
  \begin{gather*}
    \\
    \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \ket{t} : K(\tau)}
    \qquad 
    \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \bra{t} : B(\tau)}
  \end{gather*}
  Adjoint and Conjugate:
  \begin{gather*}
    \frac{\Gamma \vdash e : S}{\Gamma \vdash e^\dagger : S}
    \qquad
    \frac{\Gamma \vdash e : K(\tau)}{\Gamma \vdash e^\dagger : B(\tau)}
    \qquad
    \frac{\Gamma \vdash e : B(\tau)}{\Gamma \vdash e^\dagger : K(\tau)}
    \qquad
    \frac{\Gamma \vdash e : O(\tau, \rho)}{\Gamma \vdash e^\dagger : O(\rho, \tau)} 
  \end{gather*}
  Multiplication:
  \begin{gather*}
    \frac{\Gamma \vdash a : S \qquad \Gamma \vdash b : S}{\Gamma \vdash a \times b : S}
    \qquad
    \frac{\Gamma \vdash s : S \qquad \Gamma \vdash e : K(\tau)}{\Gamma \vdash s \times e : K(\tau)} 
    \qquad
    \frac{\Gamma \vdash s : S \qquad \Gamma \vdash e : B(\tau)}{\Gamma \vdash s \times e : B(\tau)} 
    \qquad
    \frac{\Gamma \vdash s : S \qquad \Gamma \vdash e : O(\tau, \rho)}{\Gamma \vdash s \times e : O(\tau, \rho)}
  \end{gather*}
  Zero:
  \begin{gather*}
    \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{K}(\tau)} : K(\tau)}
    \qquad
    \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{B}(\tau)} : B(\tau)}
    \qquad
    \frac{}{\Gamma \vdash \mathbf{0}_{\mathcal{O}(\tau, \rho)} : K(\tau, \rho)}
  \end{gather*}
  One:
  \begin{gather*}
    \frac{}{\Gamma \vdash \mathbf{1}_{\mathcal{O}(\tau)} : O(\tau, \tau)}
  \end{gather*}
  Add:
  \begin{gather*}
    \frac{\Gamma \vdash e_1 : S \qquad \Gamma \vdash e_2 : S }{\Gamma \vdash e_1 + e_2 : S }
    \qquad
    \frac{\Gamma \vdash e_1 : K(\tau) \qquad \Gamma \vdash e_2 : K(\tau) }{\Gamma \vdash e_1 + e_2 : K(\tau) } \\
    \\
    \frac{\Gamma \vdash e_1 : B(\tau) \qquad \Gamma \vdash e_2 : B(\tau) }{\Gamma \vdash e_1 + e_2 : B(\tau) }
    \qquad
    \frac{\Gamma \vdash e_1 : O(\tau, \rho) \qquad \Gamma \vdash e_2 : O(\tau, \rho) }{\Gamma \vdash e_1 + e_2 : O(\tau, \rho) }
  \end{gather*}
  Dot:
  \begin{gather*}
    \frac{\Gamma \vdash e_1 : B(\tau) \qquad \Gamma \vdash e_2 : K(\tau) }{\Gamma \vdash e_2 \cdot e_1 : S } 
    \qquad 
    \frac{\Gamma \vdash e_1 : B(\tau) \qquad \Gamma \vdash e_2 : O(\tau, \rho) }{\Gamma \vdash e_2 \cdot e_1 : B(\rho) } \\
    \\
    \frac{\Gamma \vdash e_1 : O(\tau, \rho) \qquad \Gamma \vdash e_2 : K(\rho) }{\Gamma \vdash e_2 \cdot e_1 : K(\tau) }
    \qquad
    \frac{\Gamma \vdash e_1 : O(\tau, \rho) \qquad \Gamma \vdash e_2 : O(\rho, \sigma) }{\Gamma \vdash e_2 \cdot e_1 : O(\tau, \sigma) }
  \end{gather*}
  Tensor:
  \begin{gather*}
    \frac{\Gamma \vdash e_1 : K(\tau) \qquad \Gamma \vdash e_2 : B(\rho) }{\Gamma \vdash e_1 \otimes e_2 : O(\tau, \rho)}
    \qquad
    \frac{\Gamma \vdash e_1 : K(\tau) \qquad \Gamma \vdash e_2 : K(\rho) }{\Gamma \vdash e_1 \otimes e_2 : K(\tau * \rho)} \\
    \\
    \frac{\Gamma \vdash e_1 : B(\tau) \qquad \Gamma \vdash e_2 : B(\rho) }{\Gamma \vdash e_1 \otimes e_2 : B(\tau * \rho)}
    \qquad
    \frac{\Gamma \vdash e_1 : O(\tau_1, \rho_1) \qquad \Gamma \vdash e_2 : O(\tau_2, \rho_2) }{\Gamma \vdash e_1 \otimes e_2 : O(\tau_1 * \tau_2, \rho_1 * \rho_2)}\\
    \\
    \frac{\Gamma \vdash e_1 : O(\tau, \rho) \qquad \Gamma \vdash e_2 : K(\sigma) }{\Gamma \vdash e_1 \otimes e_2 : O(\tau * \sigma, \rho)} 
    \qquad
    \frac{\Gamma \vdash e_1 : K(\sigma) \qquad \Gamma \vdash e_2 : B(\tau, \rho) }{\Gamma \vdash e_1 \otimes e_2 : O(\sigma * \tau, \rho)} \\
    \\
    \frac{\Gamma \vdash e_1 : O(\tau, \rho) \qquad \Gamma \vdash B : B(\sigma) }{\Gamma \vdash e_1 \otimes e_2 : O(\tau, \rho * \sigma)}
    \qquad
    \frac{\Gamma \vdash e_1 : B(\sigma) \qquad \Gamma \vdash B : O(\tau, \rho) }{\Gamma \vdash e_1 \otimes e_2 : O(\tau, \sigma * \rho)}
  \end{gather*}
\end{definition}



\bibliographystyle{plain}
\bibliography{ref}

\end{document}
\endinput