
\section{Quantum Variable}

For array, we first support one-dimensional (dependent) array, i.e., tuple, ffun, and dffun.

\begin{itemize}
    \item $L$ : set of labels. Used to indicate quantum systems/quantum variables.
    \item $S\subseteq L$ : subsystems.
    \item \coqe{qvar := seq nat}.
    \item context: $\Gamma : \coqm{qvar}\rightarrow\coqm{option ihbFinType}$.
    If $\Gamma\ \mx = \coqm{Some}\ \mT$, we write $\Gamma\vdash \mx : \mT$, and say $\mx\in\Gamma$.
    \item Declaration for quantum variables: 
    
    \coqe{declare x : qvar T}
    $$\frac{\mx : \bN\quad \mx\notin\Gamma\quad\mT:\coqm{ihbfinType}\quad\coqm{declare}\ \mx : \coqm{qvar}\ \mT}{\Gamma\ [::\mx] = \coqm{Some}\ \mT}$$
    
    
    \coqe{declare x : qtuple n T}
    $$\frac{\mx,n: \bN\quad\mx\notin\Gamma\quad\mT:\coqm{ihbfinType}\quad\coqm{declare}\ \mx : \coqm{qtuple}\ n\ \mT}{\Gamma\ \mx = \coqm{Some}\ \coqm{n.-tuple}\ \mT,\quad \forall\,\mi:\coqm{'I\_n}, \Gamma\ [::\mx,\coqm{enum\_rank}\ \mi] = \coqm{Some}\ \mT}$$
    
    \coqe{declare x : qffun F T}
    $$\frac{\mx : \bN\quad\mF:\coqm{finType}\quad \mx\notin\Gamma\quad\mT:\coqm{ihbfinType}\quad\coqm{declare}\ \mx : \coqm{qffun}\ \mF\ \mT}{\Gamma\ \mx = \coqm{Some}\ \{\coqm{ffun F $\rightarrow$ T}\},\quad \forall\,\mi:\mF, \Gamma\ [::\mx,\coqm{enum\_rank}\ \mi] = \coqm{Some}\ \mT}$$
    
    \coqe{declare x : qdffun T}
    $$\frac{\mx : \bN\quad\mF:\coqm{finType}\quad \mx\notin\Gamma\quad\mT:\mF\rightarrow\coqm{ihbfinType}\quad\coqm{declare}\ \mx : \coqm{qdffun}\ \mT}{\Gamma\ \mx = \coqm{Some}\ \{\coqm{dffun $\forall$\,i\,:\,F, T i}\},\quad \forall\,\mi:\mF, \Gamma\ [::\mx,\coqm{enum\_rank}\ \mi] = \coqm{Some}\ \mT\ \mi}$$
    \item For any declared $\mx : \coqm{qvar}$, $\pset{\mx}\subseteq L$ gives the corresponding quantum subsystem of $\mx$.
    \item Compute disjointness of \coqe{x y : qvar}:
    \begin{coq}
    Fixpoint qvar_dis (x y : qvar) : bool :=
        match x,y with
        | Nil, _ => false
        | _, Nil => false
        | [:: hx], [:: hy] => hx != hy
        | hx :: tx, hy :: ty => if (hx == hy) then qvar_dis tx ty
                                else true
        end.
    Fixpoint qvar_dis_seq (x : qvar) (s : seq qvar) : bool :=
        match s with
        | Nil => true
        | h :: t => if qvar_dis x h then qvar_dis_seq x t else false
        end.
    Fixpoint qvar_seq_dis (s : seq qvar) : bool :=
        match s with
        | Nil => true
        | h :: t => if qvar_dis_seq h t then qvar_seq_dis t else false
        end.
    \end{coq}
    \item Assumption: $\forall\,\mx\ \my:\coqm{qvar}$ such that $\mx,\my\in\Gamma$, then $\coqm{qvar\_dis x y} = [\coqm{disjoint}\ \pset{\mx}\ \&\ \pset{\my}]$.
    \item quantum register? Question: how to composite variables? How to automatically derive the type? (i.e., $\Gamma\vdash (\mx,\my) : \mT_1\ast\mT_2 $).
\end{itemize}

\section{Dirac Notation}

\begin{definition}[syntax]
    We here consider the Dirac expressions inductively generated by:
    $$e ::= c\CtoQE\ \Big|\ |v\>_\mx\ \Big|\ {}_\mx\<v|\ 
    %\Big|\ M[\mx]\ 
    \Big|\ M[\mx,\my]\ \Big|\ e^\dag\ \Big|\ e^T\ \Big|\ e^\ast\ \Big|\ e + e\
    \Big|\ c \star e \ \Big|\ e \circ e\ \Big|\ e \cdot e\ \Big|\ e\otimes e\ \Big|\ \sum_i e_i$$
    %\ \Big|\ \prod_i e_i\ \Big|\ \bigotimes_i e_i$$
    where $c\in\complexnumber $ and the index $i$ of summation is over some $\coqm{finType}$ (unconditional). $c \star e$ is the scale operator.
    If $\Gamma\ x = \coqm{Some}\ \mT_\mx$ and $\Gamma\ y = \coqm{Some}\ \mT_\my$, then $v\in\cH_{\mT_\mx}$ and $M\in\cL(\cH_{\mT_\mx},\cH_{\mT_\my})$ (if $\mx = \my$, we write it as $M[\mx]$). 
    
    Notation: we write $M[\mx]$ for $M[\mx,\mx]$ and  $|v\>_\mx\<u|$
    for outer product $(|v\>\<u|)[\mx]$.
    
    Question: constant? $0\CtoQE, 1\CtoQE, {\bf 0}_S, {\bf 0}_{S,T}, I_S$?
\end{definition} 

\begin{definition}[type]
	For each well-formed Dirac expression $e$, it has a domain $S$ and a codomain $S^\prime$. We write $\vdash e : (S,S^\prime)$. Following are the typing rules:
	\begin{align*}
		\frac{}{\vdash c\CtoQE : (\emptyset, \emptyset)} \qquad
		\frac{}{\vdash |v\>_\mx : (\emptyset, \pset{\mx})} \qquad
		\frac{}{\vdash {}_\mx\<v| : (\pset{\mx},\emptyset)} \\
		\frac{}{\vdash M[\mx,\my] : (\pset{\mx}, \pset{\my})} \qquad
		\frac{\vdash e : (S,S^\prime)}{\vdash e^\dag : (S^\prime, S)} \qquad
		\frac{\vdash e : (S,S^\prime)}{\vdash e^T : (S^\prime, S)} \qquad
		\frac{\vdash e : (S,S^\prime)}{\vdash e^\ast : (S, S^\prime)} \qquad \\
		\frac{\vdash e_1 : (S,S^\prime)\quad\vdash e_2 : (S,S^\prime)}{\vdash e_1+e_2 : (S,S^\prime)}\qquad
		\frac{\vdash e : (S,S^\prime)}{\vdash c\star e : (S,S^\prime)}\qquad
		\frac{\vdash e_1 : (S^\prime,S^{\prime\prime})\quad\vdash e_2 : (S,S^\prime)}{\vdash e_1\circ e_2 : (S,S^{\prime\prime})}\\
		\frac{\vdash e_1 : (S_1,S_1^{\prime})\quad\vdash e_2 : (S_2,S_2^{\prime})\quad [\coqm{disjoint}\ S_1\ \&\ S_2-S_1^\prime] \quad [\coqm{disjoint}\ S_2^\prime\ \&\ S_1^\prime-S_2]}{\vdash e_1\cdot e_2 : (S_1\cup(S_2-S_1^\prime), S_2^\prime\cup(S_1^\prime-S_2)}\\
		\frac{\vdash e_1 : (S_1,S_1^{\prime})\quad\vdash e_2 : (S_2,S_2^{\prime})\quad [\coqm{disjoint}\ S_1\ \&\ S_2] \quad [\coqm{disjoint}\ S_1^\prime\ \&\ S_2^\prime]}{\vdash e_1\otimes e_2 : (S_1\cup S_2, S_1^\prime\cup S_2^\prime)}\qquad
		\frac{\forall\,i,\ \vdash e_i: (S,S^\prime)}{\vdash\sum_ie_i:(S,S^\prime)}
	\end{align*}
	Conversely, for any Dirac expression $e$, if there are $S, S^\prime$ such that $\vdash e : (S,S^\prime)$, we say $e$ is well-formed and write $\vdash \wf(e)$.
\end{definition}

\begin{definition}[simplification]
	We write $C\vdash e\ra e^\prime$ for simplification. That is, $e$ can be replaced by $e^\prime$ if the side condition $C$ holds (since we only consider well-formed expressions, the conditions $\wf(e)$ and $\wf(e^\prime)$ are always necessary and thus omitted from $C$). 
	Following are basic simplification rules:
\end{definition}
\begin{align*}
	\text{Associativity:}\quad
	&\vdash e_1 + (e_2 + e_3) \ra e_1 + e_2 + e_3 \quad
	\vdash e_1 \circ (e_2 \circ e_3) \ra e_1 \circ e_2 \circ e_3 \\
	&\vdash e_1 \cdot (e_2 \cdot e_3) \ra e_1 \cdot e_2 \cdot e_3 \quad
	\vdash e_1 \otimes (e_2 \otimes e_3) \ra e_1 \otimes e_2 \otimes e_3\\
	\text{Commutativity:}\quad
	&\vdash e_1 + e_2 \ra e_2 + e_1 \quad
	\vdash e_1 \otimes e_2 \ra e_2 \otimes e_1 \\
	\text{Distributivity:}\quad
	&\vdash e \circ (e_1 + e_2) \ra e \circ e_1 + e \circ e_2\quad
	\vdash (e_1 + e_2) \circ e \ra e_1 \circ e + e_2 \circ e\\
	&\vdash e \cdot (e_1 + e_2) \ra e \cdot e_1 + e \cdot e_2\quad
	\vdash (e_1 + e_2)\cdot e \ra e_1 \cdot e + e_2 \cdot e\\
	&\vdash e \otimes (e_1 + e_2) \ra e \otimes e_1 + e \otimes e_2\quad
	\vdash (e_1 + e_2) \otimes e \ra e_1 \otimes e + e_2 \otimes e\\
	\text{Identity:}\quad
	&\vdash 0\CtoQE + e \ra e\quad \vdash e + 0\CtoQE \ra e \quad
	\vdash {\bf 0}_{S,T} + e \ra e\quad \vdash e + {\bf 0}_{S,T} \ra e \\
	&\vdash I_S\circ e \ra e\quad \vdash e\circ I_S \ra e\\
	&\frac{\vdash e : (S,S^\prime)}{\vdash e \otimes {\bf 0}_{T,T^\prime} \ra 
		{\bf 0}_{S\cup T,S^\prime\cup T^\prime}}\quad
	\frac{\vdash e : (T,T^\prime)}{\vdash {\bf 0}_{S,S^\prime} \otimes e \ra 
		{\bf 0}_{S\cup T,S^\prime\cup T^\prime}}\\
	&\frac{\vdash e : (S,S^\prime)}{\vdash e \circ {\bf 0}_{T,S} \ra 
		{\bf 0}_{T,S^\prime}}\quad
	\frac{\vdash e : (S,S^\prime)}{\vdash {\bf 0}_{S^\prime,T}\circ e \ra 
		{\bf 0}_{S,T}}\\
	&\frac{\vdash e : (S,S^\prime)}{\vdash e \cdot {\bf 0}_{T,T^\prime} \ra 
		{\bf 0}_{S\cup(T-S^\prime), T^\prime\cup(S^\prime-T)}}\quad
	\frac{\vdash e : (T,T^\prime)}{\vdash {\bf 0}_{S,S^\prime}\cdot e \ra 
		{\bf 0}_{S\cup(T-S^\prime), T^\prime\cup(S^\prime-T)}}\\
	\text{Scalar:}\quad
	&\frac{\vdash e : (S,S^\prime)}{\vdash 0\CtoQE \star e \ra {\bf 0}_{S,S^\prime}} \quad \vdash 1\CtoQE \star e \ra e \quad 
	\vdash I_{\emptyset} \ra 1\CtoQE
	\\ 
	&\vdash c\CtoQE \circ e \ra c\CtoQE \star e \quad \vdash c\CtoQE \cdot e \ra c\CtoQE \star e \quad \vdash c\CtoQE \otimes e \ra c\CtoQE \star e\\
	&\vdash c\CtoQE^\dag \ra \overline{c}\CtoQE \quad
	\vdash c\CtoQE^\ast \ra \overline{c}\CtoQE \quad
	\vdash c\CtoQE^T \ra c\CtoQE \\
	&c_1\CtoQE \star e + c_2\CtoQE \star e \ra (c_1+c_2)\CtoQE \star e \quad
	c_1\CtoQE \star (c_2\CtoQE \star e) \ra (c_1c_2)\CtoQE \star e\\
	&c\CtoQE \star (e_1 + e_2) \ra c\CtoQE \star e_1 + c\CtoQE \star e_2\\
	&(c_1\CtoQE \star e_1)\circ e_2 \ra c_1\CtoQE \star(e_1\circ e_2)\quad 
	e_1\circ (c_2\CtoQE \star e_2)\ra c_2\CtoQE \star(e_1\circ e_2)\\ 
	&(c_1\CtoQE \star e_1)\cdot e_2 \ra c_1\CtoQE \star(e_1\cdot e_2)\quad 
	e_1\cdot (c_2\CtoQE \star e_2)\ra c_2\CtoQE \star(e_1\cdot e_2)\\ 
	&(c_1\CtoQE \star e_1)\otimes e_2 \ra c_1\CtoQE \star(e_1\otimes e_2)\quad 
	e_1\otimes (c_2\CtoQE \star e_2)\ra c_2\CtoQE \star(e_1\otimes e_2)\\
	\text{Inner/Outer product:}\quad
	&{}_S\<u|\circ |v\>_S \ra \<u|v\>\CtoQE \quad 
	{}_S\<u|\cdot |v\>_S \ra \<u|v\>\CtoQE \quad
	\<\mt_1|\circ |\mt_2\> \ra \delta_{\mt_1\mt_2}\CtoQE\\
	&\mx \neq \my\vdash(|u\>\<v|)[\mx,\my]\ra |u\>_\mx\circ{}_\my\<v| \quad 
	|u\>_\mx\circ{}_\mx\<v|\ra |u\>_\mx\<v| \\
	&{}_\mx\<u|\circ (|v\>_\mx\<w|) \ra \<u|v\>\CtoQE \star{}_\mx\<w|\quad
	(|v\>_\mx\<w|) \circ |u\>_\mx \ra \<w|u\>\CtoQE \star|v\>_\mx\quad
	\\
	\text{Conjugate, Transpose: }\quad
	&\vdash e^{\dag\dag} \ra e \quad \vdash e^{TT} \ra e \quad 
	\vdash e^{\ast\ast} \ra e \quad \vdash e^{T} \ra e^{\dag\ast} 
	\quad \vdash e^{\ast\dag} \ra e^{\dag\ast} \\
	&\vdash (|v\>_S)^\dag \ra {}_S\<v| \quad
	\vdash (|v\>_S)^\ast \ra |v^\ast\>_S \quad
	\vdash ({}_S\<v|)^\dag \ra |v\>_S \quad 
	\vdash ({}_S\<v|)^\ast \ra {}_S\<v^\ast| \cdots\\
	\text{General composition:}\quad
	&\vdash e_1\cdot e_2 \ra e_1\circ e_2\quad e_1\cdot e_2 \ra e_1\otimes e_2\quad
	\vdash (e_1\otimes e_3)\circ(e_2\otimes e_4) \ra (e_1\circ e_2)\otimes (e_3\circ e_4)\\
	&\frac{\vdash e_1 : (S_1,S_1^\prime)\quad \vdash e_2 : (S_2,S_2^\prime)}{\vdash e_1\cdot e_2 : (e_1\otimes I_{S_2^\prime - S_1})\circ(e_2\otimes I_{S_1-S_2^\prime})}\\
	&\frac{\vdash e_1 : (S_1,S_1^\prime)\quad \vdash e_2 : (S_2,S_2^\prime) }{S_1\subseteq S_2^\prime\vdash e_1\cdot(e_2\otimes e_3)\ra (e_1\cdot e_2)\otimes e_3}\\
	&\frac{\vdash e_1 : (S_1,S_1^\prime)\quad \vdash e_2 : (S_2,S_2^\prime) }{S_1^\prime\subseteq S_2\vdash (e_2\otimes e_3)\cdot e_1\ra (e_2\cdot e_1)\otimes e_3}\\
	&\frac{\vdash e_1 : (S_1,S_1^\prime)\quad \vdash e_3 : (S_3,S_3^\prime) }{S_1\subseteq S_3^\prime\vdash e_1\cdot(e_2\otimes e_3)\ra e_2 \otimes (e_1\cdot e_3)}\\
	&\frac{\vdash e_1 : (S_1,S_1^\prime)\quad \vdash e_3 : (S_3,S_3^\prime) }{S_1^\prime\subseteq S_3\vdash (e_2\otimes e_3)\cdot e_1 \ra e_2 \otimes (e_3\cdot e_1)}\\
	\text{Structural:}\quad
	&\frac{C\vdash e\ra e^\prime}{C\vdash c \star e \ra c \star e^\prime}\quad \cdots\ \text{forall constructs}\\
	\text{Summation:}\quad
	&\vdash \sum_{i : P(i)} e_i \ra \sum_i \idfun{P(i)}\star e_i \quad
	\vdash\sum_{i}\delta_{ij}e_i = e_j \quad \vdash\sum_{j}\delta_{ij}e_j = e_i \\
	&\vdash c \star \Big(\sum_i e_i\Big) \ra \sum_i (c \star e_i)\quad\cdots\quad
	\vdash \sum_i \sum_j e_{ij} \ra \sum_j\sum_i e_{ij}
	\\
\end{align*}

\begin{definition}[subject reduction]
	$\vdash e: (S,S^\prime)\ \&\ C\ \&\ C\vdash e\ra e^\prime \Rightarrow\ \vdash e^\prime : (S,S^\prime)$. 
\end{definition}

\begin{definition}[Canonical form]
	For any well-formed Dirac expression $e$ such that $\vdash e : (S, S^\prime)$, we decompose $S - S^\prime = \pset{\mx_1} \cup \pset{\mx_2}\cup \cdots \pset{\mx_n}$, $S^\prime - S = \pset{\my_1} \cup \pset{\my_2}\cup \cdots \pset{\my_m}$ and $S \cap S^\prime = \pset{\mz_1} \cup \pset{\mz_2}\cup \cdots \pset{\mz_l}$ (with some default order of $\coqm{qvar}$).
	Then, $e$ can always be written as: 
	$$\sum_{i,j,k,\cdots} c_{i,j,k,\cdots} ({}_{\mx_1}\<i_1|\otimes\cdots\otimes {}_{\mx_n}\<i_n|)\otimes (|k_1\>_{\my_1}\otimes\cdots\otimes|k_m\>_{\my_m})\otimes (|j_1\>_{\mz_1}\<j_1^\prime|\otimes\cdots |j_l\>_{\mz_l}\<j_l^\prime|).$$
	
	Simplification includes above rules, together with the use of delta function ($\delta_{ij}$); the simplification rules of inner, outer product, etc.
	
	Related to path-sum but more general.
\end{definition}

$$|t_1\>_\mx = \sum_i \delta_{it_1}|i\>_\mx$$

\lz{Questions: How to deal with quantum register? (i.e., composition of quantum variables).}
%\begin
%Definition general_composition {S1 S1' S2 S2': {set L}} (qe1 : qexpr S1 S1') (qe2 : qexpr S2 S2') (sd1 : (S1 :\: S2') :&: S2 = set0) (sd2 : S1' :&: (S2' :\: S1) = set0) : qexpr ((S1 :\: S2') :|: S2) (S1' :|: (S2' :\: S1)) 
%:= (qe1 $\otimes$ id_(S2' :\: S1)) \o (id_(S1 :\: S2') $\otimes$ qe2). 
%(*cast needed: (S1 :\: S2') :|: S2' = S1 :|: (S2' :\: S1)*)


\iffalse

\noindent\textbf{Types}. 
We use $\type(e)$ to denote the type of expression $e$, i.e., the codomain and domain of $e$; $\type(e) = \{\codom{e}, \dom{e}\}$. Here, codomain and domain are subsets of labels.
Two types are equivalent if their codomains and domains are equivalent. We also use $\terr$ to denote the type of an invalid expression, and $\scalar\triangleq\{\emptyset,\ \emptyset\}$ to denote the type of scalar.

The reasons we identify the types are:
\begin{itemize}
    \item[] check the validity of a formula, for example, both $|\phi\>_q\cdot|\phi\>_q$ and $|\phi\>_p + |\phi\>_q$ are invalid.
    \item[] give the concrete function of $+$ and general composition $\cdot$. This seems impossible to be done without identifying types, for example, how to define $\cdot$ in ${}_{q_1q_3}\<\phi_1|\cdot|\phi_2\>_{q_1q_2}$?
\end{itemize}

\begin{definition}
    Formally, the type of an quantum expression $e$ is inductively defined by:
    \begin{itemize}
        \item $e\equiv z\in \complexnumber$, $\type(e) = \{\emptyset,\ \emptyset\}$. We use \scalar to denote this special type.
        \item $e\equiv |v\>_q$, $\type(e) = \{\{q\},\ \emptyset\}$
        \item $e\equiv |v\>_{\qbar}$, $\type(e) = \{\{\qbar\},\ \emptyset\}$
        \item $e\equiv {}_q\<v|$, $\type(e) = \{\emptyset,\  \{q\}\}$
        \item $e\equiv {}_{\qbar}\<v|$, $\type(e) = \{\emptyset,\ \{\qbar\}\}$
        \item $e\equiv M[q]$, $\type(e) = \{\{q\},\  \{q\}\}$
        \item $e\equiv M[\qbar]$, $\type(e) = \{\{\qbar\},\ \{\qbar\}\}$
        \item $e\equiv e_1+e_2$, 
        \begin{itemize}
            \item if $\type(e_1) = \terr$ or $\type(e_2) = \terr$ or $\type(e_1) \neq \type(e_2)$, then $\type(e) = \terr$;
            \item otherwise, then $\type(e) = \type(e_1)$;
        \end{itemize}
        \item $e\equiv e_1\cdot e_2$, 
        \begin{itemize}
            \item if $\type(e_1) = \terr$ or $\type(e_2) = \terr$, then $\type(e) = \terr$;
            \item if $\codom{e_1}\cap(\codom{e_2}-\dom{e_1}) = \emptyset$ and $(\dom{e_1}-\codom{e_2})\cap \dom{e_2} = \emptyset$, then 
                $$\type(e) = \{\codom{e_1}\cup(\codom{e_2}-\dom{e_1}),\  (\dom{e_1}-\codom{e_2})\cup \dom{e_2}\}$$
            \item otherwise, $\type(e) = \terr$;
        \end{itemize}
        ** inner product yields a scalar! E.g., ${}_q\<\phi|\cdot|\psi\>_{q}$ gives the inner product of $|\phi\>$ and $|\psi\>$.
        \item $e\equiv e_1\otimes e_2$, 
        \begin{itemize}
            \item if $\type(e_1) = \terr$ or $\type(e_2) = \terr$, then $\type(e) = \terr$;
            \item if $\codom{e_1}\cap \codom{e_2} = \emptyset$ and $\dom{e_1}\cap \dom{e_2} = \emptyset$, then 
            $$\type(e) = \{\codom{e_1}\cup \codom{e_2},\  \dom{e_1}\cup \dom{e_2}\}$$
            \item otherwise, $\type(e) = \terr$;
        \end{itemize}
        \item $e\equiv\sum_{i\in T} e_i$,  type is inductive defined by $+$. Formally,
        \begin{itemize}
            \item $T = \emptyset$, $\type(e) = \terr$;
            \item $T = \{k\}$, $\type(e) = \type(e_k)$;
            \item $T = T^\prime\cup\{k\}$, $\type(e) = \type((\sum_{i\in T^\prime}e_i) + e_k)$;
        \end{itemize}
        \item $e\equiv\prod_{i\in T} e_i$,  type is inductive defined by $\cdot$. Formally,
        \begin{itemize}
            \item $T = \emptyset$, $\type(e) = \terr$;
            \item $T = \{k\}$, $\type(e) = \type(e_k)$;
            \item $T = T^\prime\cup\{k\}$, $\type(e) = \type((\prod_{i\in T^\prime}e_i) \cdot e_k)$;
        \end{itemize}
        \item $e\equiv\bigotimes_{i\in T} e_i$,  type is inductive defined by $\otimes$. Formally,
        \begin{itemize}
            \item $T = \emptyset$, $\type(e) = \terr$;
            \item $T = \{k\}$, $\type(e) = \type(e_k)$;
            \item $T = T^\prime\cup\{k\}$, $\type(e) = \type((\bigotimes_{i\in T^\prime}e_i) \otimes e_k)$;
        \end{itemize}
        Two types $t_1=\{S_1,S_1^\prime\}$ and $t_2=\{S_2,S_2^\prime\}$, we write $t_1 = t_2$ if $S_1 = S_2$ and $S_1^\prime = S_2^\prime$.
    \end{itemize}
    
\end{definition}
    


\section{Abstractive Definitions}
\label{sec abs def}

Remark: indexes start from 0, we define $[n] = \{0,1,\cdots,n-1\}$.

\begin{itemize}
    \item $\cH$: Hilbert space (over field $\complexnumber$). With two operators:
    \begin{itemize}
        \item vector addition $+$ : $\cH\times\cH\rightarrow\cH$;
        \item scalar multiplication $\cdot$ : $\complexnumber\times\cH\rightarrow\cH$
    \end{itemize}
    satisfying the following conditions:
    \begin{enumerate}
        \item $+$ is commutative: $\forall\,|\phi\>,|\psi\>\in\cH,\ |\phi\>+|\psi\>=|\psi\>+|\phi\>$
        \item $+$ is associative: $\forall\,|\phi\>,|\psi\>,|\xi\>\in\cH,\ |\phi\>+(|\psi\>+|\xi\>)=(|\psi\>+|\phi\>)+|\xi\>$
        \item $+$ has the identity element $\vzero{\cH}$, called the zero vector, such that $\forall\,|\phi\>\in\cH,\ \vzero{\cH} + |\phi\> = |\phi\>$
        \item each $|\phi\>\in\cH$ has its inverse vector $-|\phi\>\in\cH$ such that $|\phi\> + (-|\phi\>) = \vzero{\cH}$
        \item $\cdot$ has the identity element 1: $\forall\,|\phi\>\in\cH,\ 1\cdot|\phi\> = |\phi\>$
        \item Compatibility of $\cdot$ with field multiplication: $\forall\,|\phi\>\in\cH,\ \lambda,\mu\in\complexnumber,\ \lambda(\mu|\phi\>) = \lambda\mu|\phi\>$
        \item Distributivity of $\cdot$ w.r.t. field addition: $\forall\,|\phi\>\in\cH,\ \lambda,\mu\in\complexnumber,\ (\lambda + \mu)|\phi\> = \lambda|\phi\> + \mu|\phi\>$
        \item Distributivity of $\cdot$ w.r.t. vector addition: $\forall\,|\phi\>,|\psi\>\in\cH,\ \lambda\in\complexnumber,\ \lambda(|\phi\>+|\psi\>) = \lambda|\phi\> + \lambda|\psi\>$
    \end{enumerate}

    \item $\dim(\cH)$: the dimension of $\cH$. Intrinsic property of $\cH$.
    \item Notations of states: $|\phi\>\in\cH$. 
    
    \item $\cH^\dag$: dual of $\cH$, isomorphic to $\cH$, i.e., there exists one-to-one correspondence $\dag$ that: $(|\phi\>)^\dag = \<\phi|$ and 
    $(\<\phi|)^\dag = |\phi\>$. 
    
    Notation of dual state: $\<\phi|\in\cH^\dag$.
    
    \item Inner product: $\op{inner\_prod}: \cH^\dag\rightarrow\cH\rightarrow\complexnumber$
    
    Notation: $\<\phi|\psi\> := \op{inner\_prod}(\<\phi|,|\psi\>)$.
    
    With properties: \begin{enumerate}
        \item $\forall\ |\phi\>\in\cH$, $\<\phi|\phi\>\ge 0$;
        \item $\forall\ |\phi\>\in\cH$, $\<\phi|\phi\> =  0$ iff $|\phi\> = \vzero{\cH}$;
        \item $\forall\ |\phi\>,|\psi\>\in\cH$, $\<\phi|\psi\> = \<\psi|\phi\>^\ast$ (conjugate for complex number);
        \item $\forall\ |\phi\>,|\psi_1\>,|\psi_2\>\in\cH$, $\lambda_1,\lambda_2\in\complexnumber$, $\<\phi|(\lambda_1|\psi_1\>+\lambda_2|\psi_2\>) = \lambda_1\<\phi|\psi_1\> + \lambda_2\<\phi|\psi_2\>$.
    \end{enumerate}
    
    \item Norm $\op{norm}: \cH\rightarrow\real$: $\op{norm}(|\phi\>) = \sqrt{\<\phi|\phi\>}$. 
    
    Notation: $\| |\phi\> \| := \op{norm}(|\phi\>)$.
    
    \item Pure state (unit state) $|\phi\>$ iff $\||\phi\>\| = 1$.
    \item Notation $\{|\phi\>\}_{[n]} := [|\phi_0\>,|\phi_1\>,\cdots,|\phi_{n-1}\>]$. List of states with $n$ elements.
    \item Orthonormal set: list of states $\{|\phi\>\}_{[n]}$ satisfies: \begin{enumerate}
        \item $\forall i\in[n]$, $\<\phi_i|\phi_i\> = 1$;
        \item $\forall i,j\in[n]$, $i\neq j \rightarrow \<\phi_i|\phi_j\> = 0$.
    \end{enumerate}
    
    (to define partial operators.)
    \item Orthonormal basis (ONB): orthonormal set with $\dim(\cH)$ elements. Write $\op{ONB}\ \{|\phi\>\}$.
    
    Lemma: $\forall\ |\psi\>\in\cH,\ \op{ONB} \{|\phi\>\},\ |\psi\> = \sum_{i\in[\dim(\cH)]} \<\phi_i|\psi\>|\phi_i\>.$
    
    \item Linear operator: $A:\cH\rightarrow\cH$ that satisfies:
    \begin{enumerate}
        \item $\forall\ |\phi\>,|\psi\>\in\cH$, $A(|\phi\>+|\psi\>) = A|\phi\>+A|\psi\>$;
        \item $\forall\ |\phi\>\in\cH, \lambda\in\complexnumber$, $A(\lambda|\phi\>) = \lambda A|\phi\>$.
    \end{enumerate}
    
    Notation: $\cL(\cH)$: set of linear operators on $\cH$.
    
    In particular, zeor operator $\ozero{\cH}{\cH}$, identity operator $I$: $\forall\ |\phi\>\in\cH$, $\ozero{\cH}{\cH}|\phi\> = \vzero{\cH}$, $I|\phi\> = |\phi\>$.
    
    Definition: $+$ and $\cdot$ for $\cL(\cH)$. $\forall\,A,B\in\cL(\cH),\lambda\in\complexnumber$, linear operators $\lambda A, A+B,A\cdot B$ are defined by:
    \begin{itemize}
        \item $(\lambda A)|\phi\> \triangleq \lambda (A|\phi\>)$
        \item $(A+B)|\phi\> := A|\phi\>+B|\phi\>$
        \item $(A\cdot B)|\phi\> := A(B|\phi\>)$
    \end{itemize}
    Lemma: $\forall\,A,B,C\in\cL(\cH),\lambda,\mu\in\complexnumber$,
    \begin{itemize}
        \item $\lambda(A+B)$ = $\lambda A + \lambda B$
        \item $\lambda(\mu A) = (\lambda \mu)A$
        \item $(A+B)\cdot C = A\cdot C + B\cdot C$
        \item $A\cdot (B+C) = A\cdot B + A\cdot C$
    \end{itemize}
    
    \item outer product (Kronecker product): outer\_prod : $\cH\rightarrow\cH^\dag\rightarrow(\cH\rightarrow\cH)$
    
    Notation: $|\phi\>\<\psi|$ := outer\_prod($|\phi\>,\<\psi|$).
    
    Definition: $\forall\ |\varphi\>\in\cH$, $(|\phi\>\<\psi|)|\varphi\> := \<\psi|\varphi\>\cdot |\phi\>.$
    
    \item Equivalence of linear operators: $A = B$ iff $\forall |\phi\>\in\cH$, $A|\phi\> = B|\phi\>$. 
    
    Lemma: checking one arbitrary ONB $\{|\phi\>\}$ is enough.
    
    Lemma: $\forall$ ONB $\{|\phi\>\}$, put $\{|\psi\>\}\triangleq\{|\psi_i\> \triangleq A|\phi_i\>\}$, then $A = \sum_{i\in[\dim(\cH)]}|\psi_i\>\<\phi_i|$.
    
    \item Adjoint: $\op{adjoint} : \cL(\cH)\rightarrow\cL(\cH)$ with property
    
    $\forall |\phi\>,|\psi\>\in\cH$, $(|\phi\>,A|\psi\>) = (\op{adjoint}(A)|\phi\>,|\psi\>)$.
    
    Notation: $A^\dag := \op{adjoint}(A)$.
    
    Lemma: existence and uniqueness of $A^\dag = \sum_i|\phi_i\>\<\psi_i|$ if $A = \sum_i|\psi_i\>\<\phi_i|$.
    
    %Representation: mapping ONB $\{|\phi\>\}$ to $\{|\psi\>\}_{[\dim(\cH)]}$. Explicit form: $A = \sum_{i = 1}^{\dim(\cH)}|\psi_i\>\<\phi_i|$
    
    \item Trace of linear operators $\tr:\cL(\cH)\rightarrow\complexnumber$: $\tr(A) := \sum_{i\in[\dim(\cH)]}\<\phi_i|A|\phi_i\>$ for some ONB $\{|\phi\>\}$. 
    
    Lemma: trace is independent of the choice of ONB; i.e., 
    
    $$\forall\ \op{ONB}\ \{|\phi\>\}, \{|\psi\>\}, \sum_{i\in[\dim(\cH)]}\<\phi_i|A|\phi_i\> = \sum_{i\in[\dim(\cH)]}\<\psi_i|A|\psi_i\>.$$
    
    
    \item Hermitian operator: $A = A^\dag$.
    
    Lemma: diagonal decomposition: $$\forall\ A\in\cL(\cH),\ \op{Hermitian}\ A \rightarrow \exists\ \op{ONB}\ \{|\phi\>\},\ \lambda\in (\nat\rightarrow\real),\ (\forall i\in[n],\ A|\phi_i\> = \lambda(i) |\phi_i\>).$$
    
    Lemma: trace: $$\forall\ A\in\cL(\cH),\ \op{ONB}\ \{|\phi\>\},\ \lambda\in (\nat\rightarrow\real),\ \op{Hermitian}\ A \rightarrow (\forall i\in[n],\ A|\phi_i\> = (\lambda\ i) |\phi_i\>) \rightarrow \tr(A) = \sum_{i\in[\dim(\cH)]}(\lambda\ i).$$
    
    \item Positive (semi-difinite) operator: $\forall\ |\phi\>\in\cH,\ \<\phi|A|\phi\> \ge 0$.
    
    Lemma: $\forall A\in\cL(\cH),\ \op{Positive}\ A\rightarrow \op{Hermitian}\ A.$
    
    Lemma: eigenvalues are non-negative: $$\forall A\in\cL(\cH),\ |\phi\>\in\cH, \ \lambda\in\real,\ \op{Positive}\ A \rightarrow A|\phi\> = \lambda|\phi\> \rightarrow \lambda\ge 0.$$
    
     Lemma: diagonal decomposition: $$\forall\ A\in\cL(\cH),\ \op{Positive}\ A \rightarrow \exists\ \op{ONB}\ \{|\phi\>\},\ \lambda\in (\nat\rightarrow\real),\ (\forall i\in[n],\ A|\phi_i\> = \lambda(i) |\phi_i\> \wedge \lambda(i) \ge 0).$$
    
    \item Unitary operator: $A^\dag A = I$ (identity operator).
    
    Lemma: $\forall\,A\in\cL(\cH),\ \op{Unitary} A \rightarrow \op{Unitary} A^\dag$.
    
    Lemma: $\forall$ ONB $\{|\phi\>\}$, $\{|\psi\>\}\triangleq \{|\psi_i\>\triangleq A|\phi_i\>\}$ is also ONB. So, $A = \sum_{i\in[\dim(\cH)]}|\psi_i\>\<\phi_i|$.
    
    Lemma: $\forall$ ONB $\{|\phi\>\}, \{|\psi\>\}$, $\op{Unitary}\ \sum_{i\in[\dim(\cH)]}|\psi_i\>\<\phi_i|$.
    
    Lemma: $\forall\,|\psi\>\in\cH, A\in\cL(\cH),\ \op{Unitary}\ A \rightarrow \||\psi\>\| = \|A|\psi\>\|.$     
    
    Lemma: diagonal decomposition: $$\forall\ A\in\cL(\cH),\ \op{Unitary}\ A \rightarrow \exists\ \op{ONB}\ \{|\phi\>\},\ \lambda\in (\nat\rightarrow\complexnumber),\ (\forall i\in[n],\ A|\phi_i\> = \lambda(i) |\phi_i\> \wedge |\lambda(i)| = 1).$$
    
    \item Density operator: positive \& $\tr(A) = 1$.
    
    \item Partial density operator: positive \& $\tr(A)\le 1$.
    \item Observable: positive \& $\forall\ |\phi\>\in\cH,\ \|A|\phi\>\|\le\||\phi\>\|$.
    
    Lemma: eigenvalues are in [0,1]: $$\forall A\in\cL(\cH),\ |\phi\>\in\cH, \ \lambda\in\real,\ \op{observable}\ A \rightarrow A|\phi\> = \lambda|\phi\> \rightarrow \lambda\ge 0 \wedge \lambda\le 1.$$
    
\end{itemize}

\section{Concrete Definition: Vectors, Matrices}

Some of the concepts are the same as in the last section. In particular, $\cH$ can be realized as the space of column vector, $\cH^\dag$ as the space of row vector, $\cL(\cH)$ as the space of $\dim(\cH)\times\dim(\cH)$ matrix, and all $+,\cdot$ as the addition and multiplication of matrices. 
\begin{itemize}
    \item Matrix (n m : $\nat$) : $\nat\rightarrow\nat\rightarrow\complexnumber$. 
    
    Column vector: Matrix (n 1); Row vector: Matrix (1 m).
    \item transpose (M: Matrix (n m)) : Matrix (m n) := (fun i j:  $\nat$ $\Rightarrow$ M j i).
    
    conjugate (M: Matrix (n m)) : Matrix (n m) := (fun i j:  $\nat$ $\Rightarrow$ M j i).
    
    \item $n$-dimensional computational basis (CB): $\{|i\>\}_{i\in[n]}:=\{|0\>,|1\>,\cdots,|n-1\>\}$, each of them is an column vector defined by:
    $$|i\> := \left[\begin{array}{c}0\\\vdots\\1\\\vdots\\0\end{array}\right]\begin{array}{c}0\text{th-component}\\\vdots\\i\text{th-component}\\\vdots\\(n-1)\text{th-component}\end{array}$$
    \item $n$-dimensional Hilbert space: vector space spanned by $\{|i\>\}_{i\in[n]}$, i.e., $\{|\phi\>: |\phi\> = \sum_{i\in[n]}\alpha_i|i\>,\ \alpha_i\in\complexnumber\}$.
    \item State (ket) $|\phi\>$ is the column vector while dual state (bra) $\<\phi|$ is the row vector. 
    
    $\<\phi|$ is the transpose conjugate of $|\phi\>$ and vice versa.
    
    Lemma: decomposition to CB: $\forall\, |\phi\>,\ \exists\, \alpha: \nat\rightarrow\complexnumber,\ |\phi\> = \sum_{i\in[n]}(\alpha\ i)|i\>.$
    \item Inner product: $\<\phi|\psi\> := (\<\phi|) \ast (|\psi\>)$ matrix multiplication.
    \item Linear operator: Matrix (n n).
    \item Trace of linear operator: $\op{trace}$ ($M$:Matrix (n n)) : $\complexnumber$ := $\sum_{i\in[n]} M\ i\ i$.
\end{itemize}

\section{Dirac notations with labels}

    \subsection{Basic notations}
    \begin{itemize}
        % \item bool: boolean.
        % \item nat:  natural numbers $\nat$
        % \item R: real numbers $\real$
        \item C: complex numbers $\complexnumber$
        \begin{coq}
        R[i]
        \end{coq}
        \vspace{-.7cm}
        \item $L$: set of labels. 
        \begin{coq}
        L : finType
        \end{coq}
        \vspace{-.7cm}
        \item $E : L \rightarrow \cH$. Map each label to its Hilbert space.
        \begin{coq}
        E : L -> vectType R[i]
        \end{coq}
        \vspace{-.7cm}
        \item $S\subseteq E$: then the state is represented by: 
        \begin{coq}
        Let index (S : {set L}) := mvector (fun i : S => 'I\_(Vector.dim (E i))).
        Let state (S : {set L}) := {ffun (index S) -> C}.
        Definition emptyset := [set x : L | false].
        \end{coq}
        \vspace{-.7cm}
        \item $\qbar$ : register, i.e., ordered non-duplicate sequence of labels.
        \begin{coq}
        Record register := Register {
            base : finType.mixin_of L;
            reg : seq L;
            _ : axiom reg := forall x : L, count_mem x reg <= 1
        }.
        \end{coq}
        \vspace{-.7cm}
        \item $\{\qbar\}$ : set of labels of register $\qbar$, $\{\qbar\}\triangleq\{x\in L \ |\ x\in \qbar\}$.
        
        \item $\cH_q$ : labeled Hilbert space of $q\in L$.
        
        \item $\cH_\qbar$ : labeled Hilbert space of $\{\qbar\}\subseteq L$.
        
        \item $v$ : vector; $M$ : matrix.
        
        \item $|v\>_q$ : inject vector $v$ to labeled Hilbert space $\cH_q$. The dimension should be consistent, i.e., $\dim v = \dim \cH_q$.
        
        \item $|v\>_\qbar$ : inject vector $v$ to labeled Hilbert space $\cH_\qbar$. Note: it is sensitive to the order of $\qbar$. Concretely:
        \begin{coq}
        Fixpoint inj_index (s : register L) (e : index {s}) : nat := inj_index_p (reg s)
            with inj_index_p (s' : seq L) : nat :=
                match s' with
                | x :: s'' => e x + (Vector.dim (E x)) * (inj_index_p s'')
                | nil => 0
                end.
        $|v\>_\qbar$ := fun e : index {$\qbar$} => v (inj_index rev($\qbar$) e).
        \end{coq}
        \vspace{-.7cm}
        
        \item ${}_q\<v|\triangleq(|v\>_q)^\dag$; \quad ${}_{\qbar}\<v| \triangleq (|v\>_\qbar)^\dag$.
        
        \item $M[q]$ : inject matrix $M$ to $\cL(\cH_q)$. The dimension should be consistent, i.e., $\dim M = \dim \cH_q$.
        
        \item $M[\qbar]$ : inject matrix $M$ to $\cL(\cH_\qbar)$. Note: it is sensitive to the order of $\qbar$. Concretely:
        \begin{coq}
        $M[\qbar]$ := fun ij : index {$\qbar$} * index {$\qbar$} => M (inj_index rev($\qbar$) ij.1) (inj_index rev($\qbar$) ij.2).
        \end{coq}
        \vspace{-.7cm}
        \item For simplicity, we further introduce a special injection: 
        \begin{coq}
        $|i\>_q$ := fun e : index {q} => if (e q = i) then 1 else 0.
        $|i\>_\qbar$ := fun e : index {$\qbar$} => if (inj_index rev($\qbar$) e = i) then 1 else 0.
        \end{coq}
        \vspace{-.7cm}
        
        \item In particular, we make convention that $\cH_{\emptyset} = \cH_{\emptyset}^\dag = \complexnumber$.
    \end{itemize}
    
    Remark: properties of Hilbert space should be adopted, listed in Section \ref{sec abs def}.
    
    \subsection{Quantum Expressions}
    \label{sec qexpr}
    \begin{definition}
        Quantum expressions are inductively defined by:
        $$e ::= \qerr\ \Big|\ \complexnumber\ \Big|\ \textrm{linear operator}\ \Big|\ |v\>_q\ \Big|\ |v\>_{\qbar}\ \Big|\ M[q]\ \Big|\ M[\qbar]\ \Big|\ e^\dag\ \Big|\ e^T\ \Big|\ e^\ast\ \Big|\ e + e\ \Big|\ e \cdot e\ \Big|\ e\otimes e$$
        $$e ::= \qerr\ \Big|\ \complexnumber\ \Big|\ \textrm{linear operator}\ \Big|\ |v\>_q\ \Big|\ {}_q\<v|\ \Big|\ |v\>_{\qbar}\ \Big|\ {}_{\qbar}\<v|\ \Big|\ M[q]\ \Big|\ M[\qbar]\ \Big|\ e^\dag\ \Big|\ e + e\ \Big|\ e \cdot e\ \Big|\ e\otimes e\ \Big|\ \sum_i e_i\ \Big|\ \prod_i e_i\ \Big|\ \bigotimes_i e_i$$
        Whenever the subscripts of bra and ket are the same, e.g., $|v\>_\qbar \cdot {}_\qbar\<u|$, we simply write $|v\>_\qbar\<u|$.
    \end{definition} 
    
    \noindent\textbf{Types}. 
    We use $\type(e)$ to denote the type of expression $e$, i.e., the codomain and domain of $e$; $\type(e) = \{\codom{e}, \dom{e}\}$. Here, codomain and domain are subsets of labels.
    Two types are equivalent if their codomains and domains are equivalent. We also use $\terr$ to denote the type of an invalid expression, and $\scalar\triangleq\{\emptyset,\ \emptyset\}$ to denote the type of scalar.
    
    The reasons we identify the types are:
    \begin{itemize}
        \item[] check the validity of a formula, for example, both $|\phi\>_q\cdot|\phi\>_q$ and $|\phi\>_p + |\phi\>_q$ are invalid.
        \item[] give the concrete function of $+$ and general composition $\cdot$. This seems impossible to be done without identifying types, for example, how to define $\cdot$ in ${}_{q_1q_3}\<\phi_1|\cdot|\phi_2\>_{q_1q_2}$?
    \end{itemize}
    
    \begin{definition}
        Formally, the type of an quantum expression $e$ is inductively defined by:
        \begin{itemize}
            \item $e\equiv z\in \complexnumber$, $\type(e) = \{\emptyset,\ \emptyset\}$. We use \scalar to denote this special type.
            \item $e\equiv |v\>_q$, $\type(e) = \{\{q\},\ \emptyset\}$
            \item $e\equiv |v\>_{\qbar}$, $\type(e) = \{\{\qbar\},\ \emptyset\}$
            \item $e\equiv {}_q\<v|$, $\type(e) = \{\emptyset,\  \{q\}\}$
            \item $e\equiv {}_{\qbar}\<v|$, $\type(e) = \{\emptyset,\ \{\qbar\}\}$
            \item $e\equiv M[q]$, $\type(e) = \{\{q\},\  \{q\}\}$
            \item $e\equiv M[\qbar]$, $\type(e) = \{\{\qbar\},\ \{\qbar\}\}$
            \item $e\equiv e_1+e_2$, 
            \begin{itemize}
                \item if $\type(e_1) = \terr$ or $\type(e_2) = \terr$ or $\type(e_1) \neq \type(e_2)$, then $\type(e) = \terr$;
                \item otherwise, then $\type(e) = \type(e_1)$;
            \end{itemize}
            \item $e\equiv e_1\cdot e_2$, 
            \begin{itemize}
                \item if $\type(e_1) = \terr$ or $\type(e_2) = \terr$, then $\type(e) = \terr$;
                \item if $\codom{e_1}\cap(\codom{e_2}-\dom{e_1}) = \emptyset$ and $(\dom{e_1}-\codom{e_2})\cap \dom{e_2} = \emptyset$, then 
                    $$\type(e) = \{\codom{e_1}\cup(\codom{e_2}-\dom{e_1}),\  (\dom{e_1}-\codom{e_2})\cup \dom{e_2}\}$$
                \item otherwise, $\type(e) = \terr$;
            \end{itemize}
            ** inner product yields a scalar! E.g., ${}_q\<\phi|\cdot|\psi\>_{q}$ gives the inner product of $|\phi\>$ and $|\psi\>$.
            \item $e\equiv e_1\otimes e_2$, 
            \begin{itemize}
                \item if $\type(e_1) = \terr$ or $\type(e_2) = \terr$, then $\type(e) = \terr$;
                \item if $\codom{e_1}\cap \codom{e_2} = \emptyset$ and $\dom{e_1}\cap \dom{e_2} = \emptyset$, then 
                $$\type(e) = \{\codom{e_1}\cup \codom{e_2},\  \dom{e_1}\cup \dom{e_2}\}$$
                \item otherwise, $\type(e) = \terr$;
            \end{itemize}
            \item $e\equiv\sum_{i\in T} e_i$,  type is inductive defined by $+$. Formally,
            \begin{itemize}
                \item $T = \emptyset$, $\type(e) = \terr$;
                \item $T = \{k\}$, $\type(e) = \type(e_k)$;
                \item $T = T^\prime\cup\{k\}$, $\type(e) = \type((\sum_{i\in T^\prime}e_i) + e_k)$;
            \end{itemize}
            \item $e\equiv\prod_{i\in T} e_i$,  type is inductive defined by $\cdot$. Formally,
            \begin{itemize}
                \item $T = \emptyset$, $\type(e) = \terr$;
                \item $T = \{k\}$, $\type(e) = \type(e_k)$;
                \item $T = T^\prime\cup\{k\}$, $\type(e) = \type((\prod_{i\in T^\prime}e_i) \cdot e_k)$;
            \end{itemize}
            \item $e\equiv\bigotimes_{i\in T} e_i$,  type is inductive defined by $\otimes$. Formally,
            \begin{itemize}
                \item $T = \emptyset$, $\type(e) = \terr$;
                \item $T = \{k\}$, $\type(e) = \type(e_k)$;
                \item $T = T^\prime\cup\{k\}$, $\type(e) = \type((\bigotimes_{i\in T^\prime}e_i) \otimes e_k)$;
            \end{itemize}
            Two types $t_1=\{S_1,S_1^\prime\}$ and $t_2=\{S_2,S_2^\prime\}$, we write $t_1 = t_2$ if $S_1 = S_2$ and $S_1^\prime = S_2^\prime$.
        \end{itemize}
        
    \end{definition}
    
    \begin{definition}[Linear operator]
        Given two sets $S_1,S_2\subseteq L$, a operator $A: \cH_{S_1}\rightarrow\cH_{S_2}$ is linear if
        $$\forall\,|x\>,|y\>\in\cH_{S_1}, \alpha,\beta\in\complexnumber,\ A(\alpha|x\>+\beta|y\>) = \alpha A|x\>+\beta A|y\>.$$
        \begin{itemize}
            \item The identity operator on $S$, $I_S:\cH_S\rightarrow\cH_S$ is defined by $$\forall\,|x\>\in\cH_S,\ I_S|x\> = |x\>.$$
            \item The zero operator $\ozero{S_1}{S_2}$: $$\forall\,|x\>\in\cH_{S_1},\ \ozero{S_1}{S_2}|x\> = \vzero{S_2}.$$
            \item Note that we've made the convention that $\cH_\emptyset = \complexnumber$, so for example, if $S_1 = S_2 = \emptyset$, the operator reduce to a scalar, i.e., $A$ is just a complex number; e.g., $I_{\emptyset} = 1$, $\ozero{\emptyset}{\emptyset} = 0$. 
        \end{itemize}
    \end{definition}
    
    \begin{definition}
        We define the addition, multiplication (composition), Kronecker product and general multiplication of linear operators:
        \begin{itemize}
            \item Given two linear operator $A,B:\cH_{S_1}\rightarrow\cH_{S_2}$, the addition $A+B:\cH_{S_1}\rightarrow\cH_{S_2}$ is defined by:
            $$\forall\,|x\>\in\cH_{S_1},\ (A+B)|x\> = A|x\>+B|x\>.$$
            \item Given two linear operators $A:\cH_{S_1}\rightarrow\cH_{S_2}$ and $B:\cH_{S_2}\rightarrow\cH_{S_3}$, the multiplication (composition) $(A\circ B):\cH_{S_1}\rightarrow\cH_{S_3}$ is defined by:
            $$\forall\,|x\>\in\cH_{S_1},\ (A\circ B)|x\> = A(B|x\>).$$
            \item Given two linear operators $A:\cH_{S_1}\rightarrow\cH_{S_1^\prime}$ and $B:\cH_{S_2}\rightarrow\cH_{S_2^\prime}$, and assume $S_1\cap S_2 = S_1^\prime\cap S_2^\prime = \emptyset$, then the Kronecker product $(A\otimes B):\cH_{S_1\cup S_2}\rightarrow\cH_{S_1^\prime\cup S_2^\prime}$ is defined by:
            $$\forall\,|x\>\in\cH_{S_1},|y\>\in\cH_{S_2},\ (A\otimes B)(|x\>\otimes|y\>) = (A|x\>)\otimes(B|y\>),$$
            together with linearity.
            \item Given two linear operators $A:\cH_{S_1}\rightarrow\cH_{S_1^\prime}$ and $B:\cH_{S_2}\rightarrow\cH_{S_2^\prime}$, and assume $(S_1-S_2^\prime)\cap S_2 = S_1^\prime\cap(S_2^\prime-S_1) = \emptyset$ the general multiplication $A\cdot B: \cH_{(S_1-S_2^\prime)\cup S_2}\rightarrow\cH_{S_1^\prime\cup(S_2^\prime-S_1)}$ defined by:
            $$A\cdot B = (A\otimes I_{S_2^\prime-S_1})\circ(I_{S_1-S_2^\prime}\otimes B).$$
            Following is an illustration how this works, in particular, notice that $(S_1-S_2^\prime)\cup S_2^\prime = S_1\cup S_2^\prime = S_1\cup(S_2^\prime-S_1)$ for rearranging the intermediate space:
            \begin{align*}
                \begin{array}{lccc}
                    \text{Input Space} & S_1-S_2^\prime &  & S_2 \\[0.2cm]
                    \text{First linear mapping} & {\color{red}I_{S_1-S_2^\prime}} & {\color{red}\downarrow} & {\color{red}B}  \\[0.2cm]
                    \text{intermediate Space}& S_1-S_2^\prime &  & S_2^\prime  \\
                    \text{Rearrange Spaces}& S_1 &  & S_2^\prime-S_1  \\[0.2cm]
                    \text{Second linear mapping}& {\color{red}A} & {\color{red}\downarrow} & {\color{red}I_{S_2^\prime-S_1}} \\[0.2cm]
                    \text{Output Space}& S_1^\prime & & S_2^\prime-S_1
                \end{array}
            \end{align*}
        \end{itemize}
    \end{definition}
    
    \begin{definition}[Semantics of Quantum Expression]
        For a quantum expression $e$ of type $\type(e) = \{\codom{e},\ \dom{e}\}$, its semantics $\sem{e}$ is a linear operator $\cH_{\dom{e}}\rightarrow\cH_{\codom{e}}$ which is inductively defined:
        \begin{itemize}
            \item $e\equiv z\in\complexnumber$, $\sem{e} = z$
            \item $e\equiv |\phi\>_q$, $\sem{e}$ is defined by the mapping: $\forall\,x\in\complexnumber,\ \sem{e}(x) = x|\phi\>_q$.
            \item $e\equiv |\phi\>_{\qbar}$, $\sem{e}$ is defined by the mapping: $\forall\,x\in\complexnumber,\ \sem{e}(x) = x|\phi\>_{\qbar}$.
            \item $e\equiv {}_q\<\phi|$, $\sem{e}$ is defined by the mapping: $\forall\,|\psi\>\in\cH_{q},\ \sem{e}(|\psi\>) = \<\phi|\psi\>$.
            \item $e\equiv {}_{\qbar}\<\phi|$, $\sem{e}$ is defined by the mapping: $\forall\,|\psi\>\in\cH_{\qbar},\ \sem{e}(|\psi\>) = \<\phi|\psi\>$.
            \item $e\equiv e_1+e_2$, $\sem{e} = \sem{e_1}+\sem{e_2}$
            \item $e\equiv e_1\cdot e_2$, $\sem{e} = \sem{e_1}\cdot\sem{e_2}$
            \item $e\equiv e_1\otimes e_2$, $\sem{e} = \sem{e_1}\otimes\sem{e_2}$
            \item $e\equiv\sum_{i\in T} e_i$,  $\sem{e}$ is inductive defined by:
            \begin{itemize}
                \item $T = \{k\}$, $\sem{e} = \sem{e_k}$;
                \item $T = T^\prime\cup\{k\}$, $\sem{e} = \sem{\sum_{i\in T^\prime}e_i} + \sem{e_k}$;
            \end{itemize}
            \item $e\equiv\sum_{i\in T} e_i$,  $\sem{e}$ is inductive defined by:
            \begin{itemize}
                \item $T = \{k\}$, $\sem{e} = \sem{e_k}$;
                \item $T = T^\prime\cup\{k\}$, $\sem{e} = \sem{\prod_{i\in T^\prime}e_i} \cdot \sem{e_k}$;
            \end{itemize}
            \item $e\equiv\otimes_{i\in T} e_i$,  $\sem{e}$ is inductive defined by:
            \begin{itemize}
                \item $T = \{k\}$, $\sem{e} = \sem{e_k}$;
                \item $T = T^\prime\cup\{k\}$, $\sem{e} = \sem{\bigotimes_{i\in T^\prime}e_i} \otimes \sem{e_k}$;
            \end{itemize}
        \end{itemize}
    \end{definition}
    In other words, the semantics of quantum expression might be defined as 
    \begin{coq}
        Definition qexpr (S S' : {set L}) := QExpr of {ffun ij : index S' * index S => C}.
        Definition qe_val e := let: QExpr t := e in t.
        Notation "''QE_' ( S , S' )" := qexpr S S'.
        Notation "''QE_' S " := qexpr S S.
    \end{coq}
    \vspace{-0.7cm}
    
    \subsection{Define quantum expressions as linear operator}.
    
    Recall the notation: 
    \begin{coq}
        Let index (S : {set L}) := mvector (fun i : S => 'I_(Vector.dim (E i))).
        Let state (S : {set L}) := {ffun (index S) -> C}.
        Definition conj {S : {set L}} (phi : state S) := [ffun e : index S => (phi e)^* ].
        Notation " phi ^* " := conj phi.
    \end{coq}
    \vspace{-0.5cm}
    Define quantum register:
    \begin{coq}
        Section QRegDef.
        Variables (n : nat).
        Inductive qreg := QReg (qr : {ffun 'I_n -> L} of (injectiveb qr).
        Definition qreg_val qr := let: QReg t _ := qr in t.
        Definition fun_of_qreg qr i := qreg_val qr i.
        Coercion fun_of_qreg : qreg >-> Funclass.
        Definition set_of_qreg qr : {set L} := [set x | exists i, qr i = x]. (* get set from qreg *)
        Notation "{ qr }" := set_of_qreg qr.
        Definition qreg_of_seq ... (* build qreg from a sequence *)
        Definition dimqr qr := \prod_i Vector.dim( (E i)).
        Notation "\dim qr" := dimqr qr.
        Lemma card_index_dim : forall qr, #|index {qr}| = \dim qr.
        End QRegDef.
        (* we need a simple notation to build qreg from discrete labels *)
        Definition qreg1 q : qreg 1 := @QReg [ffun i : 'I_1 => q] _.
        Definition qreg_add {n : nat} (qr : qreg n) (q : L) (disc : q \notin {qr}) :=
            @QReg [ffun i : 'I_n.+1 => if i < n as b return L then qr i else q] _.
        Notation "[| q ]" := qreg1 q.
        Notation "[| q1 ; q2 ; .. ; qn ]" := (qreg_add (.. (qreg_add (qreg1 q1) q2) ..) qn). 
        Definition qreg_ext {n m: nat} (qr1 : qreg n) (qr2 : qreg m) (disc : {qr1} :&: {qr2} = set0) :=
            @QReg [ffun i : 'I_(n+m) => match split i with inl i1 => qr1 i1 | inr i2 => qr2 i2] _.
        Notation "qr1 ++ qr2" := qreg_ext qr1 qr2.
    \end{coq}
    \vspace{-0.5cm}
    A quantum expression is defined as (following notations do not work in coq). Question: you mentioned to defined it as linear mapping, so I try to do it as follows. But then we should keep the "linear" when construct it? Also defining its dagger and transpose is not convenient?
    \begin{coq}
        (* formal definition is needed, *: the scale operator *)
        Structure qexpr (S S' : {set L}) := QExpr {op: (state S) -> (state S'); _ : linear_for *: op;}.
        Definition qexpr_val qe := let: QExpr t _ := qe in t.
        Definition qexpr_of_fun F (lin : linear_for *: F) := QExpr (fun phi : state S => F phi) lin.
        Notation "''QE_' ( S , S' )" := qexpr S S'.
        Notation "''QE_' S " := qexpr S S.
        Notation "'\qexpr_' ( phi ) F " := qexpr_of_fun (fun phi => F).
        Definition id_qexpr (S: {set L}) : qexpr S S := QExpr (linear_idfun *: idfun).
        Notation "'Id_' S" := id_qexpr S.
        Notation "'Id'" := id_qexpr _.
    \end{coq}
    \vspace{-0.5cm}
    Next, we define the operations of quantum expression. Question: I believe that dependent parameters S and S' changes everywhere, so do we need to encode the cast directly in its definition?
\begin{itemize}
\item scale:
    \begin{coq}
    Definition cscale (c : C) (e : qexpr S S') : qexpr S S' := \qexpr_(phi) c *: (e phi).
    Infix "*:" := cscale.
    \end{coq}
    \vspace{-0.7cm}
\item Injection of vectors and matrices (shall we leave the simple case that qr is a single label?)
    % Definition injv {n : nat} (v : 'cV_n) (q : L) (eq: n = Vector.dim (E q)) : qexpr set0 [set q] 
    %     := ...
    % Notation " | v >_ q " := injv v q _.
    % Definition injm {n : nat} (M : 'M_n) (q : L) (eq: n = Vector.dim (E q)) : qexpr [set q] [set q] 
    %     := ...
    % Notation " M _ q  " := injm M q _.
    \begin{coq}
    Definition injvm {n m: nat} (v : 'cV_n) (qr : qreg m) (eq: n = \dim qr) 
        :=...
    Notation " | v >_ qr" := injvm v qr _.
    Definition injvm {n m : nat} (M : 'M_n) (qr : qreg m) (eq: n = \dim qr) 
        := ...
    Notation " M _ qr " := injmm M qr _.
    \end{coq}
    \vspace{-0.7cm}
\item Dagger, Transpose and Conjugate. (Note that dagger and transpose are not convenient.  
    % Notation " q _< v | " := (|v>_q)^A.  
    \begin{coq}
    Definition conjugate {S S': {set L}} (qe : qexpr S S') : qexpr S S' 
        := QExpr (conj_linear (fun phi => (qe phi)^*) ).
    Notation " qe ^* " := conjugate qe.
    Definition transpose {S S': {set L}} (qe : qexpr S S') : qexpr S' S
        := QExpr (linear_for *: (fun u : state S' => \sum_(b : index S) 
            (let: v := $\otimes$ \mvector_(i : S) r2v (delta_mx 0 (b i j) in [<u ; qe v>] *: v)).
    Notation " qe ^T " := transpose qe.
    Definition dagger {S S': {set L}} (qe : qexpr S S') : qexpr S' S := qe ^T ^*.
    Notation " qe ^A " := dagger qe.
    Notation " qr _< v | " := (|v>_qr)^A.
    \end{coq}
    \vspace{-0.7cm}
\item Addition, tensor product, composition and general composition.
    % Notation " | v >_ q _< u | " := (|v>_q) \o (q_<v|).
    \begin{coq}
    Definition addition {S S': {set L}} (qe qe' : qexpr S S') : qexpr S S'
        := QExpr (add_linear qe qe').
    Infix " + " := addition.
    Definition tensor_prod {S1 S1' S2 S2': {set L}} (qe1 : qexpr S1 S1') (qe2 : qexpr S2 S2') (sd1 : S1 :&: S2 = set0) (sd2 : S1' :&: S2' = set0) : qexpr (S1 :|: S2) (S1' :|: S2') 
        := ...
    Infix " $\otimes$ " := tensor_prod.
    Definition composition {S1 S2 S3: {set L}} (qe1 : qexpr S1 S2) (qe2 : qexpr S2 S3) : qexpr S1 S3
        := QExpr (linear_comp qe1 qe2). (* qe1 (qe2 ) *)
    Infix " \o " := composition.
    Notation " | v >_ qr _< u | " := (|v>_qr) \o (qr_<v|).
    Definition general_composition {S1 S1' S2 S2': {set L}} (qe1 : qexpr S1 S1') (qe2 : qexpr S2 S2') (sd1 : (S1 :\: S2') :&: S2 = set0) (sd2 : S1' :&: (S2' :\: S1) = set0) : qexpr ((S1 :\: S2') :|: S2) (S1' :|: (S2' :\: S1)) 
        := (qe1 $\otimes$ id_(S2' :\: S1)) \o (id_(S1 :\: S2') $\otimes$ qe2). 
        (*cast needed: (S1 :\: S2') :|: S2' = S1 :|: (S2' :\: S1)*)
    Infix " $\cdot$ " := general_composition.
    \end{coq}
    \end{itemize}
    
    \noindent\textbf{Properties}. Two quantum expressions are equivalent in the sense that their semantics are the same linear operator. Question: How to deal with cast? 
    \begin{enumerate}
        \item Convention: \coqe{E set0} is defined as one-dimensional Hermitian space. For example, \coqe{qexpr set0 set0} is a one-dimensional quantum expression, it then equivalence to scalar. In particular, \coqe{id set0} is just 1.
        \item \coqe{forall S S' : $\{$set L$\}$, ((qexpr S S') 0 +)} is a commutative monoid and also a group with inverse element \coqe{(-e)} for every \coqe{e}.
        \item \coqe{\forall S S' : $\{$set L$\}$, ((qexpr S S') id \o)} is a monoid.
        \item \coqe{(qexpr (id set0) $\otimes$)} is a commutative monoid (whenever it is defined).
        \item \coqe{(qexpr (id set0) $\cdot$)} is a monoid (whenever it is defined).
        \item \scalar (or \coqe{qexpr set0 set0}) is commutative over $\otimes$ and $\cdot$.
        \item $\otimes$ and $\cdot$ are both distributive over $+$: 
        
        $\forall\,e_1,e_2,e_3,\ (e_1+e_2)\cdot e_3 = (e_1\cdot e_3)+(e_2\cdot e_3)$ and $e_1\cdot(e_2+ e_3) = (e_1\cdot e_2)+(e_1\cdot e_3)$ if they are defined.
        
        $\forall\,e_1,e_2,e_3,\ (e_1+e_2)\otimes e_3 = (e_1\otimes e_3)+(e_2\otimes e_3)$ and $e_1\otimes(e_2+ e_3) = (e_1\otimes e_2)+(e_1\otimes e_3)$ if they are defined.
        \item \coqe{forall (S1 S1' S2 S2': $\{$set L$\}$) (qe1 : qexpr S1 S1') (qe2 : qexpr S2 S2')}, whenever LHS and RHS are defined, then
        
        \coqe{qe1 \o qe2 = qe1 $\cdot$ qe2}. 
        
        if \coqe{S1 :&: S2' = set0}, then \coqe{qe1 $\otimes$ qe2 = qe1 $\cdot$ qe2}. 
        
        if \coqe{S1 :&: S2' = set0} and \coqe{S1' :&: S2 = set0}, then \coqe{qe1 $\cdot$ qe2 = qe2 $\cdot$ qe1}. 
        \item Property of injection/matrix calculation, whenever LHS and RHS are defined: (together with above properties we have more deductive cases)
        
        \coqe{ |v1>_p $\otimes$ |v2>_q = |v1 $\otimes$ v2>_(p++q) }.
        
        \coqe{ M1_p $\otimes$ M2_q = (M1 $\otimes$ M2)_(p++q) }.
        
        \coqe{ M_p \o |v>_p = |M *m v>_p }.
        
        \coqe{ M1_p \o M2_p = (M1 *m M2)_p }.
        
        \coqe{ p_<v1| \o |v2>_q = [<v1; v2>] = \tr (v1^A *m v2) }.
        
        \coqe{ |v1>_q_<v2| = (v1 *m v2)_q }.
        
        \coqe{ |v1>_p + |v2>_p = |v1 + v2>_p}
        
        \coqe{ M1_p + M2_p = (M1 + M2)_p}
        
        \coqe{ (e1 $\otimes$ e2) \o (e3 $\otimes$ e4) = (e1 \o e3) $\otimes$ (e2 \o e4) }.
        
        \coqe{ (e1 $\triangle$ e2)^* = (e1^*) $\triangle$ (e2^*)} where \coqe{$\triangle$ \in $\{$ +, $\otimes$, $\circ$, $\cdot$ $\}$}.
        
        \coqe{ (e1 $\triangle$ e2)^$\square$ = (e2^$\square$) $\triangle$ (e1^$\square$)} where \coqe{$\triangle$ \in $\{$ +, $\otimes$, $\circ$, $\cdot$ $\}$} and \coqe{$\square$ \in $\{$ T, A $\}$}.
        \item Properties of Hermitian Type, i.e., inner product, bases, decomposition..., should be generalized to quantum expression.
        
    \end{enumerate}

\subsection{Proof soundness without dependent type (cast)}



\begin{coq}
    Context {L: finType} (E: L -> hermitianType).
    Let idx (S : {fset L}) := mvector (fun i : S => 'I\_(Vector.dim (E (val i)))).
    Let Hf (S : {fset L}) := (fun i : S => E (val i)).
    Let Hs (S: {fset L}) := tensor_hermitianType (@Hf S).
    Let Ha := tensor_hermitianType E.
    
    Structure foov := Foov {dv : {fset L}; fv : Ha}.
    Structure foof := Foof {df : {fset L} * {fset L}; ff : 'Hom(Ha, Ha)}.
    
    Definition liftv {S: {fset L}} (v: Hs S) : foov :=
        foov S v$\cdot$|0>_(S^c).
    Definition redv (fv: foov) : Hs fv.dv:= 
        (fv.dv)^c_<0|$\cdot$ fv.fv.
    Lemma lift_redvK {S: {fset L}} (v: Hs S) :=
        redv (liftv v) = v.
        
    Definition liftf {S S': {fset L}} (f: 'Hom(S, S')) : foof :=
        foof (S,S') I_((S$\cup$S')^c)$\cdot$ |0>_(S-S')$\cdot$ f$\cdot$ (S'-S)_<0|.
    Definition redf (lf: foof) : 'Hom(fl.df.1, fl.df.2) :=
        (fl.df.2^c)_<0| $\cdot$ fl.ff $\cdot$ |0>_(fl.df.1^c).
    Lemma lift_redfK {S S': {fset L}} (f: 'Hom(S, S')) :
        redf (liftf f) = f.
    
    Definition applyf (lf: foof) (v: foov) : foov :=
        foov lf.df.2 (lf.ff v.fv).
    Lemma applyf_correct: {S S': {fset L}} (f: 'Hom(S, S')) (v: Hs S) :
        liftv (f v) = applyf (liftf f) (liftv v).
    
    (* note that tensor is defined for every case, but only correct for well-formed case *)
    Definition tensf (lf lg: foof) : foof :=
        liftf ((redf lf)$\otimes$(redf lg)).
    Lemma tensf_correct {S1 S1' S2 S2'} (f: 'Hom(S1,S1')) (g: 'Hom(S2,S2')) : 
        [disjoint S1 & S2] -> [disjoint S1' & S2'] -> liftf (f$\otimes$ g) = tensf (liftf f) (liftf g).
    
    Definition compf (lf lg: foof) : foof := 
        Foof (lg.df.1$\cup$(lf.df.1-lg.df.2), (lg.df.2-lf.df.1)$\cup$lf.df.2)
        (let A := (lg.df.2$\cup$lf.df.1)-(lg.df.1$\cup$lf.df.2) in \sum_i |i>_A_<0| \o lf.ff \o lg.ff \o |0>_A_<i|).
    Lemma compf_correct_mul {S1 S2 S3} (f: 'Hom(S2,S3)) (g: 'Hom(S1,S2)) : liftf (f \o g) = compf (liftf f) (liftf g).
    Lemma compf_correct {S1 S1' S2 S2' : {fset L}} (f: 'Hom(S2,S2')) (g: 'Hom(S1,S1')) : 
        [disjoint (S1-S2') & S2] -> [disjoint S1' & S2'-S1] -> liftf (f $\cdot$ g) = compf (liftf f) (liftf g).
    
\end{coq}

    With the help of liftv and liftf above, we are able to :
    \begin{enumerate}
        \item lift state and linfun to the global space;
        \item prove the correctness (equivalence) of lifted formulas over global space;
        \item since lift and red yields idfun, then we know that the red of state/linfun are also equivalent.
        \item side-condition of fsets are now extract out, which is used to ensure the correctness, but not as the dependent parameters.
    \end{enumerate}







    \subsection{Towards simple automation of real/complex analysis}
    
    A frequently used technique is to decompose things to an orthonormal bases (states), then we can sum up/multiply the coefficient and reduce to a simpler quantum expression.
    
    Frequently used real/complex forms include: trigonometric function (constant pi), exponent/logarithm (constant e), polynomial, square root.
    
    First level simplification: using properties of these functions. I'll give a list later.
    
    Second level simplification, based on concrete numbers (we've discussed about the decidablity. Generally theories on complex field is not decidable). We consider following expressions:
    \begin{itemize}
        \item Rational numbers $S_1$: generated by $\mathbb{Q}$ with $+, -, \times$.
        \item Exponent $S_2$ : $e^{i\pi x}$ where $x\in S_1$.
        \item Trigonometry $S_3$ : $\sin(\pi x), \cos(\pi x), \tan(\pi x)$ where $x\in S_1$.
        \item First-order logic of polynomial with above sets $S_1\cup S_2\cup S_3$ as coefficients.
    \end{itemize}
    Since we make constraint on Exponent and Trigonometry, then they are in fact algebraic numbers. Then, the numbers generated above are still algebraic numbers (so does this lead to the decidablility?)

\section{Examples of quantum expressions}

\noindent\textbf{Example 1 (A simple example of calculations in Quantum information theory)}.
	For any operator $A$ and maximally entangled state $|\Phi\> = \sum_i|\phi_i\>_{q_1}|\phi_i\>_{q_2}$, we prove that $A[q_1]|\Phi\> = A^T[q_2]|\Phi\>$.
	\begin{align*}
		A[q_1]|\Phi\> &= \sum_{mn}A_{mn}|\phi_m\>_{q_1}{\color{red}\<\phi_n|}\sum_i{\color{red}|\phi_i\>_{q_1}}|\phi_i\>_{q_2} \\
		&= \sum_{mni}A_{mn}{\color{red}\<\phi_n|\phi_i\>}|\phi_m\>_{q_1}|\phi_i\>_{q_2} \\
		&= \sum_{mi}A_{mi}|\phi_m\>_{q_1}|\phi_i\>_{q_2} \\
		&= \sum_{mij}A_{ji}{\color{red}\<\phi_j|\phi_m\>}|\phi_m\>_{q_1}|\phi_i\>_{q_2} \\
		&= \sum_{mij}A_{ji}|\phi_i\>_{q_2}\<\phi_j|\cdot|\phi_m\>_{q_1}|\phi_m\>_{q_2} \\
		&= \sum_{ij}A_{ji}|\phi_i\>_{q_2}\<\phi_j|\sum_m|\phi_m\>_{q_1}|\phi_m\>_{q_2} \\
		&= A^T[q_2]|\Phi\>
	\end{align*}

\vspace{0.4cm}

\noindent\textbf{Example 2 (Measurement)}.
Quantum measurement with $n$ outcomes can be represented by
\begin{coq}
Definition measurement {m n: nat} := 
        [qualify a M : [ffun 'I_n -> 'M[C]_m] | \sum_i (M i)^A *m (M i) = 1%:M)].
\end{coq}
Now, for any state $|\phi\>_\qbar$ and if we apply $M$ on $q\in\qbar$, we obtain output $i$ with probability
\begin{coq}
Definition p (i : 'I_n) := \tr ((M i)[q] $\cdot$ $|\phi\>_\qbar\<\phi|$ $\cdot$ ((M i)[q])${}^\dag)$.
Lemma alter_prob1 (i : 'I_n) : p i = ${}_\qbar\<\phi|$ ((M i)[q])${}^\dag$ $\cdot$ (M i)[q]) $|\phi\>_\qbar$.
Lemma alter_prob2 (i : 'I_n) : p i = ${}_\qbar\<\phi|$ ((M i)${}^\dag$ *m (M i))[q] $|\phi\>_\qbar$.
\end{coq}
and the post-measure state is
\begin{coq}
Definition post_state (i : 'I_n) := ((M i)[q] $\cdot$ $|\phi\>_\qbar$ / (\sqrt (p i)) (* state *)
Definition post_density_operator (i : 'I_n) := (M i)[q] $\cdot$ $|\phi\>_\qbar\<\phi|$ $\cdot$ ((M i)[q])${}^\dag$ / p i (* state *)
\end{coq}

\vspace{0.4cm}

\noindent\textbf{Example 3 (Quantum gates)}.
Define following matrices:
\begin{align*}
    &I = \left[\begin{array}{cc}1 & 0 \\ 0 & 1\end{array}\right]\quad
    S = \left[\begin{array}{cc}1 & 0 \\ 0 & \i\end{array}\right]\quad
    T = \left[\begin{array}{cc}1 & 0 \\ 0 & e^{\i\pi/4}\end{array}\right]\quad
    X = \left[\begin{array}{cc}0 & 1 \\ 1 & 0\end{array}\right]\quad
    Y = \left[\begin{array}{cc}0 & -\i \\ \i & 0\end{array}\right]\\
    &Z = \left[\begin{array}{cc}1 & 0 \\ 0 & -1\end{array}\right] \quad
    H = \frac{1}{\sqrt{2}}\left[\begin{array}{cc}1 & 1 \\ 1 & -1\end{array}\right]\quad
    {\rm CNOT} = \left[\begin{array}{cc}I & 0 \\ 0 & X\end{array}\right]\quad
    C(U) = \left[\begin{array}{cc}I & 0 \\ 0 & U\end{array}\right].
\end{align*}
We have the following properties:
\begin{align*}
    & C[p,q] = H[q]C(Z)[p,q]H[q] && C(Z)[p,q] = C(Z)[q,p] \\
    & H[p]H[q]C[p,q]H[p]H[q] = C[q,p] && C[p,q]X[p]C[p,q] = X[p]X[q] \\
    & C[p, q]Y[p]C[p, q] = Y[p]X[q] && C[p, q]Z[p]C[p, q] = Z[p] \\
    & C[p, q]X[q]C[p, q] = X[q] && C[p, q]Y[q]C[p, q] = Z[p]Y[q] \\
    & C[p, q]Z[q]C[p, q] = Z[p]Z[q] && C[p, q]T[p] = T[p]C[p, q]
\end{align*}
To prove them, we can first map quantum expression to its matrix form (but not generally exists), then inject the matrix back; we need some lifting here. (Also possible to introduce symbolic reasoning.)

\vspace{0.4cm}

\noindent\textbf{Example 4 (Quantum Operations)}.
Density operators and partial density operators:
\begin{coq}
Definition positivemx {m: nat} := 
        [qualify a M : 'M[C]_m | \forall v : 'rV_m, v *m M *m v^A >= 0].
Definition observablemx {m: nat} := 
        [qualify a M : 'M[C]_m | M \is a positivemx && \forall v : 'rV_m, \tr (v *m M *m v^A) <= dotp v v].
Definition density_operator {m: nat} := 
        [qualify a M : 'M[C]_m | M \is a positivemx && \tr M = 1].
Definition parital_density_operator {m: nat} := 
        [qualify a M : 'M[C]_m | M \is a positivemx && \tr M <= 1].
\end{coq}

A linear operator $\cE : \cL(\cH)\rightarrow\cL(\cH)$ is called quantum operation if:
\begin{itemize}
    \item (Trace non-increasing) $\tr(\cE(\rho))\le\tr(\rho)$ for each density operator $\rho$ in $\cH$;
    \item (Complete Positive) For any extra Hilbert space $\cH_R$ and its identity operator $\cI_R$ (i.e., $\cI_R(A) = A$ for all $A\in\cL(\cH_R)$), $(\cI_R\otimes\cE)(A)$ is positive provided $A\in\cL(\cH_R\otimes\cH)$ positive. 
\end{itemize}
It can be proved that this definition is equivalent to:
\begin{itemize}
    \item There exists a finite or countably infinite (it can be proved that there exists a set with at most the square of the dimensions $\cH$ elements) set of linear operators (matrices) $\{E_i\}$ in $\cH$ (i.e., $E_i\in\cL(\cH)$) such that $\sum_iE_i^\dag E_i\sqsubseteq I$ and 
    $$\cE(\rho) = \sum_i E_i\rho E_i^\dag$$
    for all linear operators (matrices) $\rho$ in $\cH$.
\end{itemize}
Formalizing quantum operations and proving it is a CPO are key steps to establish quantum Hoare logic. The semantics of QHL is quantum operation. The rest part are relatively straightforward.

\vspace{0.4cm}

\noindent\textbf{Example 5 (Qualify of Quantum expression)}. First, we define following function to drop labels of a quantum expression: 
\begin{itemize}
    \item Function qe\us abs to drop labels of a quantum expression, i.e., return the matrix form:
    
    Quantum expression $e$ with $\dom{e} = S$ and $\codom{e} = S'$
    \begin{coq}
        Fixpoint index_inj_p n (s : Seq L) (x0 : L) :=
            match s with
            | x :: s' => if (x = x0) then n %% (Vector.dim (E x)) else 
                                        index_inj_p (n %/ (Vector.dim (E x))) s' x0
            | nil => 0
            end
        Definition index_inj n S : B S := fun x : S => index_inj_p n (rev (enum S)).
        Definition qe_abs e : 'M_(\dim S', \dim S) := fun ij => (qe_val e) (index_inj ij.1 S') (index_inj ij.2 S).
    \end{coq}
    
    \item With above definition, we can then generalize the property of matrix to quantum expressions, for example:
    \begin{coq}
    Definition positive_qe {S} := 
        [qualify a M : 'QE_S | (qe_abs M) \is a positivemx].
    Definition observable_qe {S} := 
        [qualify a M : 'QE_S | (qe_abs M) \is a observablemx].
    Definition density_operator_qe {S} := 
        [qualify a M : 'QE_S | (qe_abs M) \is a density_operator].
    Definition parital_density_operator_qe {S} := 
        [qualify a M : 'QE_S | (qe_abs M) \is a partial_density_operator].
    \end{coq}    
\end{itemize}



\vspace{0.4cm}

\noindent\textbf{Example 6 (Denotational semantics of quantum programs)}.
Quantum programs are generated by the syntax:
\begin{align*}
    S ::= \iskip \ &|\ \iinit{q} \ |\ \iunit{\qbar}{U} \ |\ S_1;S_2 \\
    & |\ \icond{m}{M}{\qbar}{S} \\
    & |\ \iwhile{M}{\qbar}{S}.
\end{align*}
\begin{coq}
Inductive program {L : finType} := skip | init q : L | seqn (S_1 S_2 : program) 
    | utrans ($\qbar$ : {set L}) (U : 'M_(\dim $\qbar$))
    | cond ($\qbar$ : {set L}) (n : nat) (M : measurement (\dim $\qbar$) n) (S : [ffun 'I_n -> program])
    | while ($\qbar$ : {set L}) (M : measurement (\dim $\qbar$) 2) (S : [ffun 'I_2 -> program])
\end{coq}
Fix the global set $L$ of variables (labels), and 
use $\iconf{S}{\rho}$ to denote the configuration, where $S$ is a quantum program and $\rho$ : partial\us density\us operator\us qe $L$. The operational semantics of quantum programs are defined by following transitions:
\begin{align*}
    & \rname{SK} \quad \frac{}{\iconf{\iinit{q}}{\rho}\rightarrow\iconf{E}{\sum_i|0\>_q\<i|\rho|i\>_q\<0|}} \\
    & \rname{UT} \quad \frac{}{\iconf{\iunit{\qbar}{U}}{\rho}\rightarrow\iconf{E}{U[\qbar]\rho (U[\qbar])^\dag}} \\
    & \rname{SC} \quad \frac{\iconf{S_1}{\rho}\rightarrow\iconf{S_1^\prime}{\rho^\prime}}{\iconf{S_1;S_2}{\rho}\rightarrow\iconf{S_1^\prime;S_2}{\rho^\prime}} \quad \textrm{convention:}\ E;S_2 = S_2\\
    & \rname{IF} \quad \frac{\forall\, n\in \{0,1,\cdots,k\} \ \text{if}\ M = \{M_0,\cdots, M_k\}}{\iconf{\icond{m}{M}{\qbar}{S}}{\rho}\rightarrow\iconf{S_n}{M_n[\qbar]\rho (M_n[\qbar])^\dag}} \\
    & \rname{L0} \quad \frac{}{\iconf{\iwhile{M}{\qbar}{S}}{\rho}\rightarrow\iconf{E}{M_0[\qbar]\rho(M_0[\qbar])^\dag}} \\
    & \rname{L1} \quad \frac{}{\iconf{\iwhile{M}{\qbar}{S}}{\rho}\rightarrow\iconf{S;\iwhile{M}{\qbar}{S}}{M_1[\qbar]\rho(M_1[\qbar])^\dag}}
\end{align*}
Denotational semantics is a linear mapping from quantum expression (of partial\us density\us operator\us qe $L$) to quantum expression (of partial\us density\us operator\us qe $L$):
$$\sem{S}(\rho) = \sum\{\!|\rho^\prime: \iconf{S}{\rho}\rightarrow^\ast\iconf{E}{\rho^\prime}|\!\}.$$
\begin{coq}
    Fixpoint dsemantics {L} (S : program L) (\rho : partial_density_operator_qe L) :     
            partial_density_operator_qe L.
\end{coq}
The structural representation of the denotational semantics:
\begin{itemize}
    \item $\sem{\iskip}(\rho) = \rho$
    \item $\sem{\iinit{q}}(\rho) = \sum_i|0\>_q\<i|\rho|i\>_q\<0|$
    \item $\sem{\iunit{\qbar}{U}}(\rho) = U[\qbar]\rho (U[\qbar])^\dag$
    \item $\sem{S_1;S_2}(\rho) = \sem{S_2}(\sem{S_1}(\rho))$
    \item $\sem{\icond{m}{M}{\qbar}{S}}(\rho) = \sum_nM_n[\qbar]\rho (M_n[\qbar])^\dag$
    \item $\sem{\iwhile{M}{\qbar}{S}}(\rho) = \bigsqcup_n(\sem{(\kwhile)^n}(\rho))$, where $\sem{(\kwhile)^0}(\rho) = 0$ and for any $n\ge 0$, 
    $$\sem{(\kwhile)^{n+1}}(\rho) = M_0[\qbar]\rho (M_0[\qbar])^\dag + \sem{(\kwhile)^n}(M_1[\qbar]\rho (M_1[\qbar])^\dag)$$
\end{itemize}



\vspace{0.4cm}

\noindent\textbf{Example 7 (Soundness of quantum Hoare logic, partial correctness)}.
Fix the global set $L$ of variables (labels). Predicates $P, Q, \cdots$ are quantum expressions (of observable\us qe $L$). Then the partial correctness is defined as follows:
\begin{coq}
Definition par_correct_formula {L} (S : qprogram) (P Q : observable_qe L) := 
    \forall \rho : partial_density_operator_qe L, 
        \tr (P \rho) <= \tr (Q (dsemantics S \rho)) + \tr (\rho) - \tr (dsemantics S \rho).
Notation "\models { P } S { Q }" := par_correct_formula S P Q.
\end{coq}
The proof system of partial correctness:
\begin{align*}
    & \rname{Ax-Sk} \quad \cf{\iskip}{P}{P} \\
    & \rname{Ax-In} \quad \cf{\iinit{q}}{\sum_i|i\>_q\<0|P|0\>_q\<i|}{P} \\
    & \rname{Ax-Ut} \quad \cf{\iunit{\qbar}{U}}{U[\qbar]P(U[\qbar])^\dag}{P} \\
    & \rname{R-SC} \quad \frac{\cf{S_1}{P}{Q}\quad\cf{S_2}{Q}{R}}{\cf{S_1;S_2}{P}{R}} \\
    & \rname{R-IF} \quad \frac{\forall\,m,\ \cf{S_m}{P_m}{Q}}{\cf{\icond{m}{M}{\qbar}{S}}{\sum_m(M_m[\qbar])^\dag P_m M_m[\qbar]}{Q}} \\
    & \rname{R-LP} \quad \frac{\cf{S}{Q}{(M_0[\qbar])^\dag P M_0[\qbar] + (M_1[\qbar])^\dag Q M_1}}{\cf{\iwhile{M}{\qbar}{S}}{(M_0[\qbar])^\dag P M_0[\qbar] + (M_1[\qbar])^\dag Q M_1}{P}} \\
    & \rname{R-Or} \quad \frac{P\sqsubseteq P^\prime\quad \cf{S}{P^\prime}{Q^\prime}\quad Q^\prime\subseteq Q}{\cf{S}{P}{Q}}
\end{align*}
Proof of soundness, see Page 125, Foundations of Quantum Programming.
\vspace{0.4cm}

\noindent\textbf{Example 8 (Partial correctness of HHL algorithm)}.

Solving linear systems of equations is a fundamental problem in almost all fields of science: given a matrix $A$ and a vector $\vec{b}$, find a vector $\vec{x}$ such that $A\vec{x} = \vec{b}$. The quantum algorithm for linear systems of equations, also known as HHL algorithm, named after Harrow, Hassidim, and Lloyd, was proposed in 2008 for solving linear systems \cite{HHL08} by providing a state $\ket{x}$ corresponding to $\vec{x}$ rather than give a classical characterization of $\vec{x}$.
When $A$ is sparse and has a low condition number $\kappa$, then algorithm has a runtime of $O(\log(N)\kappa^2)$ where $N$ is the number of linear equations, which offers an exponential speedup over the fastest classical algorithm.

To simplify the problem and algorithm, let us assume $A$ is Hermitian and full-rank with dimension $N = 2^m$ and therefore it is possible to apply the transform $e^{\imath A t_0}$ for a given time $t_0$. $A$ is diagonalizable with the form
$$A = \sum_{j = 1}^N\lambda_j|u_j\>\<u_j|,$$ where $\lambda_j$ and $|u_j\>$ are the corresponding eigenvalues and eigenvectors. To make the algorithm to be exact, we presume that, for all $0\le j\le N$, $\lambda_jt_0$ is multiple of $2\pi$: $$\delta_j = \frac{\lambda_jt_0}{2\pi}\in \mathbb{N}^+.$$

We also assume that the input vector $\vec{b}$ can be prepared efficiently; that is, there is a unitary operator $U_b$ which can efficiently transform $|0\>$ into $|b\> = \sum_{i = 1}^Nb_i|i\>$. The scale of $\vec{b}$ is not essential as we only care about the solution $\vec{x}$ up to some unimportant scale factor, we assume $\sum_{i = 1}^N|b_i|^2 = 1$, and therefore $|b\>$ is just a unit vector. Moreover, $|b\>$ can always be written as a linear combination of $|u_j\>$:
$$|b\> = \sum_{j = 1}^N\beta_j|u_j\>.$$

The phase estimation algorithm is employed and a control system is needed. We chose a proper dimension $T$ of the control system, $T = 2^n$ where $n = \lceil \max_j \delta_j \rceil$, which ensures that the phase estimation succeed with probability 1 if the initial state of control system is $|0\>^{\otimes n}$. Actually, the original HHL algorithm uses a more complex initial state of control system, which minimize a certain quadratic loss function. But as we only want to show the key ideas of the algorithm and our proof of correctness, a simpler state $|0\>^{\otimes n}$ is used as it can make the algorithm output an exact solution state with the assumption of $A$ and $t_0$ above.

Given the forms of $A$ and $|b\>$ above, it is easy to calculate the solution for the linear equation $A|x\> = |b\>$:
$$|x\> = c\sum_{j = 1}^N \frac{\beta_j}{\lambda_j}|u_j\>,$$
up to some unimportant scale factor where $c$ is only used to normalize $|x\>$.

The HHL algorithm can be written as a quantum program in the while-language defined in Section 3; see Figure \ref{fig 5}. The register $p$ is an $n$-qubit system with $2^n = T$ which used as a control system in the phase estimation step, while $q$ is an $m$-qubit system which stores the vector $b$, in the sense of a corresponding quantum state $|b\> = \sum_ib_i|i\>$. The last register $r$ is an one qubit system and it is the indicator of the while loop. The measurement $M = \{M_0,M_1\}$ in the loop is the simplest ``yes-no" measurement: $M_0 = |1\>_r\<1|$ and $M_1 = |0\>_r\<0|$.


\begin{figure}[h]
\centering
\begin{align*}
&p := |0\>^{\otimes n};\\
&q := |0\>^{\otimes m};\\
&r := |0\>;\\
&{\rm\bf while\ }M[r] = 1 {\ \rm\bf do\ } D {\ \rm\bf od\ };\\
\end{align*}
\caption{HHL algorithm -- the quantum algorithm for linear systems of equations }\label{fig 5}
\end{figure}


\begin{figure}\centering
\begin{align*}
&q := |0\>^{\otimes m}; \\
&q := U_b[q];   \\
&p := H^{\otimes n}[p]; \\
&p,q := U_f[p,q];   \\
&p := {\rm QFT}^{-1}[p];  \\
&p,r := U_c[p,r];   \\
&p := {\rm QFT}[p];  \\
&p,q := U_f^{\dag}[p,q];    \\
&p := H^{\otimes n}[p]; \\
\end{align*}
\caption{Loop body D}\label{fig 6}
\end{figure}


The loop body is displayed in Figure \ref{fig 6}. The unitary operator $U_b$ is a given operator which generate the input vector $b$; that is, $$U_b|0\>^{\otimes m} = |b\> = \sum_{i=1}^Nb_i|i\>.$$
$U_f$ is a controlled unitary operator whose control system is $p$ and target system is $q$; more precisely,
$$U_f = \sum_{\tau = 0}^{T-1} |\tau\>_p\<\tau|\otimes e^{\imath A\tau t_0/T}.$$
$\rm QFT$ and $\rm QFT^{-1}$ are the quantum Fourier transform and the inverse quantum Fourier transform applied to the control register $p$. Their formulas are well-known:
\begin{align*}
&{\rm QFT}: |k\>\mapsto \frac{1}{\sqrt{T}}\sum_{\tau = 0}^{T-1}e^{2\pi\imath \tau k/T}|\tau\>,\quad k = 0,1,\cdots,T-1,\\
&{\rm QFT}^{-1}: |k\>\mapsto \frac{1}{\sqrt{T}}\sum_{\tau = 0}^{T-1}e^{-2\pi\imath \tau k/T}|\tau\>,\quad k = 0,1,\cdots,T-1.
\end{align*}
$U_c$ is a controlled unitary which operates on the control register $p$ and target register $r$. Formally, $U_c$ is the transform with some proper parameter $C$:
\begin{align*}
U_c: &|0\>_p|0\>_r \mapsto |0\>_p|0\>_r \\
&|i\>_p|0\>_r \mapsto |i\>_p(\sqrt{1-\frac{C^2}{i^2}}|0\>_r + \frac{C}{i}|1\>_r) \quad i = 1,2,\cdots,T-1
\end{align*}

The partial correctness of the program HHL can be stated as
\begin{equation}
\label{HHLcorrectformular}
\models_{\rm par}\{I_p\otimes I_q\otimes I_r\}{\rm HHL}\{|0\>_p\<0|\otimes |x\>_q\<x|\otimes|1\>_r\<1|\},
\end{equation}
in the sense that for any possible input states, the output of the program is always $|0\>_p|x\>_q|1\>_r$, where the state of register $q$ is the desired solution and not entangled with other registers.

Before to derive the correctness of whole program, let us first check the validity of the formula $$\vdash_{qPD}\{|0\>_p\<0|\otimes I_q\otimes |0\>_r\<0|\}D\{|0\>_p\<0|\otimes (|x\>_q\<x|\otimes|1\>_r\<1| + I_q\otimes |0\>_r\<0|)\},$$
for the loop body $D$. For simplicity, we use following symbols:
\begin{align*}
&P = |0\>_p\<0|\otimes I_q\otimes |0\>_r\<0|; \\
&Q = |0\>_p\<0|\otimes |x\>_q\<x|\otimes|1\>_r\<1|; \\
&R = |0\>_p\<0|\otimes (|x\>_q\<x|\otimes|1\>_r\<1| + I_q\otimes |0\>_r\<0|); \\
&|v_j\>_r = \sqrt{1-\frac{C^2}{\delta_j^2}}|0\>_r + \frac{C}{\delta_j}|1\>_r,\quad{\rm for}~1\le j\le N
\end{align*}

Using the (Axion Initialization) and (Axiom Unitary Transformation), we have a sequence of correctness formulas as follows:

\begin{align}
&\Bigg\{\frac{1}{T}\sum_{j,j^\prime = 1}^N\sum_{\tau,\tau^\prime = 0}^{T-1}(\beta_j|\tau\>_p|u_j\>_q|v_j\>_r)
(\bar{\beta}_{j^\prime}{}_p\<\tau^\prime|_q\<u_{j^\prime}|_r\<v_{j^\prime}|) \Bigg\} \notag\\
&\quad\quad p := H^{\otimes n}[p]
\Bigg\{|0\>_p\<0|\otimes\bigg[\sum_{j,j^\prime = 1}^N(\beta_j|u_j\>_q|v_j\>_r)
(\bar{\beta}_{j^\prime}{}_q\<u_{j^\prime}|_r\<v_{j^\prime}|)\bigg] \Bigg\}\label{HHL1}
\\
&\Bigg\{\frac{1}{T}\sum_{j,j^\prime = 1}^N\sum_{\tau,\tau^\prime = 0}^{T-1}(\beta_je^{\imath 2\pi \delta_j\tau/T}|\tau\>_p|u_j\>_q|v_j\>_r)
(\bar{\beta}_{j^\prime}e^{-\imath 2\pi \delta_{j^\prime}\tau^\prime/T}{}_p\<\tau^\prime|_q\<u_{j^\prime}|_r\<v_{j^\prime}|) \Bigg\} \notag\\
&\quad\quad p,q := U_f^{\dag}[p,q]
\Bigg\{\frac{1}{T}\sum_{j,j^\prime = 1}^N\sum_{\tau,\tau^\prime = 0}^{T-1}(\beta_j|\tau\>_p|u_j\>_q|v_j\>_r)
(\bar{\beta}_{j^\prime}{}_p\<\tau^\prime|_q\<u_{j^\prime}|_r\<v_{j^\prime}|) \Bigg\}\label{HHL2}
\\
&\Bigg\{ \sum_{j,j^\prime = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|v_j\>_r)(\bar{\beta}_{j^\prime}{}_p\<\delta_{j^\prime}|_q\<u_{j^\prime}|_r\<v_{j^\prime}|)   \Bigg\} p := {\rm QFT}[p] \notag\\
&\quad\quad \Bigg\{\frac{1}{T}\sum_{j,j^\prime = 1}^N\sum_{\tau,\tau^\prime = 0}^{T-1}(\beta_je^{\imath 2\pi \delta_j\tau/T}|\tau\>_p|u_j\>_q|v_j\>_r)
(\bar{\beta}_{j^\prime}e^{-\imath 2\pi \delta_{j^\prime}\tau^\prime/T}{}_p\<\tau^\prime|_q\<u_{j^\prime}|_r\<v_{j^\prime}|) \Bigg\}\label{HHL3}
\end{align}
\begin{align}
&\Bigg\{ \sum_{j,j^\prime = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|0\>_r)(\bar{\beta}_{j^\prime}{}_p\<\delta_{j^\prime}|_q\<u_{j^\prime}|_r\<0|)   \Bigg\}
p,r := U_c[p,r] \notag\\
&\quad\quad \Bigg\{ \sum_{j,j^\prime = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|v_j\>_r)(\bar{\beta}_{j^\prime}{}_p\<\delta_{j^\prime}|_q\<u_{j^\prime}|_r\<v_{j^\prime}|)   \Bigg\}\label{HHL4}
\\
&\Bigg\{\frac{1}{T}\sum_{j,j^\prime = 1}^N\sum_{\tau,\tau^\prime = 0}^{T-1}(\beta_je^{\imath \tau\lambda_jt_0/T}|\tau\>_p|u_j\>_q|0\>_r)
(\bar{\beta}_{j^\prime}e^{-\imath \tau^\prime\lambda_{j^\prime}t_0/T}{}_p\<\tau^\prime|_q\<u_{j^\prime}|_r\<0|) \Bigg\} \notag\\
&\quad\quad p := {\rm QFT}^{-1}[p]\Bigg\{ \sum_{j,j^\prime = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|0\>_r)(\bar{\beta}_{j^\prime}{}_p\<\delta_{j^\prime}|_q\<u_{j^\prime}|_r\<0|)   \Bigg\} \label{HHL5}
\\
&\Bigg\{\frac{1}{T}\sum_{\tau,\tau^\prime = 0}^{T-1}|\tau\>_p\<\tau^\prime|\otimes|b\>_q\<b|\otimes |0\>_r\<0|\Bigg\}
p,q := U_f[p,q] \notag\\
&\quad\quad\Bigg\{\frac{1}{T}\sum_{j,j^\prime = 1}^N\sum_{\tau,\tau^\prime = 0}^{T-1}(\beta_je^{\imath \tau\lambda_jt_0/T}|\tau\>_p|u_j\>_q|0\>_r)
(\bar{\beta}_{j^\prime}e^{-\imath \tau^\prime\lambda_{j^\prime}t_0/T}{}_p\<\tau^\prime|_q\<u_{j^\prime}|_r\<0|) \Bigg\} \label{HHL6}
\\
&\Big\{|0\>_p\<0|\otimes |b\>_q\<b|\otimes |0\>_r\<0|\Big\}p := H^{\otimes n}[p]\Bigg\{\frac{1}{T}\sum_{\tau,\tau^\prime = 0}^{T-1}|\tau\>_p\<\tau^\prime|\otimes|b\>_q\<b|\otimes |0\>_r\<0|\Bigg\} \label{HHL7}\\
&\big\{|0\>_p\<0|\otimes |0\>_q\<0|\otimes |0\>_r\<0|\big\}q := U_b[q]\big\{|0\>_p\<0|\otimes |b\>_q\<b|\otimes |0\>_r\<0|\big\} \label{HHL8}\\
&\big\{P\big\}q := |0\>^{\otimes m}\big\{|0\>_p\<0|\otimes |0\>_q\<0|\otimes |0\>_r\<0|\big\} \label{HHL9}
\end{align}



Formula (\ref{HHL1}) is trivial using (Axiom Unitary Transformation) as
$$H^{\dag\otimes n}|0\>^{\otimes n} = \frac{1}{\sqrt{T}}\sum_{\tau = 0}^{T-1}|\tau\>.$$

Due to the fact that $e^{\imath A}|u_j\> = e^{\imath \lambda_j }|u_j\>$ when $\lambda_j$ and $|u_j\>$ are corresponding eigenvalues and eigenvectors of $A$, Formula (\ref{HHL2}) is straightforward followed from the calculation:
\begin{align*}
&U_f[p,q]\frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_j|\tau\>_p|u_j\>_q|v_j\>_r) \\
=\ &\sum_{\nu = 0}^{T-1}|\nu\>_p\<\nu|\otimes e^{\imath A\nu t_0/T}\frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_j|\tau\>_p|u_j\>_q|v_j\>_r) \\
=\ & \frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_j|\tau\>_pe^{\imath A\tau t_0/T}|u_j\>_q|v_j\>_r) \\
=\ &\frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_je^{\imath 2\pi \delta_j\tau/T}|\tau\>_p|u_j\>_q|v_j\>_r)
\end{align*}

Formula (\ref{HHL3}) is also easy to obtain with notation $\mathbb{I}$ being the indicator function:
\begin{align*}
&{\rm QFT}^\dag[p]\frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_je^{\imath 2\pi \delta_j\tau/T}|\tau\>_p|u_j\>_q|v_j\>_r)\\
=\ &\frac{1}{T}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}\sum_{\nu = 0}^{T-1}(\beta_je^{\imath 2\pi \delta_j\tau/T} e^{-\imath2\pi\tau\nu/T}|\nu\>_p|u_j\>_q|v_j\>_r) \\
=\ &\frac{1}{T}\sum_{j = 1}^N\sum_{\nu = 0}^{T-1}\bigg[\sum_{\tau = 0}^{T-1}e^{\imath 2\pi (\delta_j-\nu)\tau/T}\bigg](\beta_j|\nu\>_p|u_j\>_q|v_j\>_r) \\
=\ &\frac{1}{T}\sum_{j = 1}^N\sum_{\nu = 0}^{T-1}T\cdot \mathbb{I}(\nu = \delta_j)(\beta_j|\nu\>_p|u_j\>_q|v_j\>_r) \\
=\ &\sum_{j = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|v_j\>_r)
\end{align*}

Formula (\ref{HHL4}) is according to:
\begin{align*}
&U_c^\dag[p,r]\sum_{j = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|v_j\>_r) \\
=\ &\sum_{j = 1}^N \Bigg(\beta_j|u_j\>_qU_c^\dag[p,r]|\delta_j\>_p\bigg(\sqrt{1-\frac{C^2}{\delta_j^2}}|0\>_r + \frac{C}{\delta_j}|1\>_r\bigg)\Bigg) \\
=\ &\sum_{j = 1}^N (\beta_j|\delta_j\>_p|u_j\>_q|0\>_r)
\end{align*}

Formula (\ref{HHL5}) is trivial and Formula (\ref{HHL6}) is also straightforward:
\begin{align*}
&U_f^\dag[p,q]\frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_je^{\imath \tau\lambda_jt_0/T}|\tau\>_p|u_j\>_q|0\>_r) \\
=\ &\sum_{\nu = 0}^{T-1}|\nu\>_p\<\nu|\otimes e^{-\imath A\nu t_0/T}\frac{1}{\sqrt{T}}\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_je^{\imath \tau\lambda_jt_0/T}|\tau\>_p|u_j\>_q|0\>_r) \\
=\ &\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_je^{\imath \tau\lambda_jt_0/T}|\tau\>_pe^{-\imath A\tau t_0/T}|u_j\>_q|0\>_r) \\
=\ &\sum_{j = 1}^N\sum_{\tau = 0}^{T-1}(\beta_j|\tau\>_p|u_j\>_q|0\>_r)\\
=\ &\frac{1}{\sqrt{T}}\sum_{\tau = 0}^{T-1}|\tau\>_p|b\>_q|0\>_r
\end{align*}

The rest Formulas (\ref{HHL7}), (\ref{HHL8}) and (\ref{HHL9}) can be obtained using the proof rules directly.
Now, let us focus on Formulas (\ref{HHL1}) again as we need to relate the post predicate to $R$. To do this, we first write the explicit form of the state
\begin{align*}
\sum_{j = 1}^N\beta_j|u_j\>_q|v_j\>_r &= \sum_{j = 1}^N\beta_j|u_j\>_q\bigg(\sqrt{1-\frac{C^2}{\delta_j^2}}|0\>_r + \frac{C}{\delta_j}|1\>_r\bigg) \\
&= \sum_{j = 1}^Nc_1 |x\>_q|1\>_r + \sum_{j = 1}^N\beta_j\sqrt{1-\frac{C^2}{\delta_j^2}}|u_j\>_q|0\>_r
\end{align*}
where $c_1$ is some constant. Then, note that $|x\>_q|1\>_r$ is in the subspace of $|x\>_q\<x|\otimes|1\>_r\<1|$ and $\sum_{j = 1}^N\beta_j\sqrt{1-\frac{C^2}{\delta_j^2}}|u_j\>_q|0\>_r$ is in the subspace of
$I_q\otimes |0\>_r\<0|$, and moreover, these two subspace are orthogonal, therefore, $\sum_{j = 1}^N\beta_j|u_j\>_q|v_j\>_r$ is in the subspace of $|x\>_q\<x|\otimes|1\>_r\<1| + I_q\otimes |0\>_r\<0|$. So we have the following fact:
\begin{align}
&|0\>_p\<0|\otimes\bigg[\sum_{j,j^\prime = 1}^N(\beta_j|u_j\>_q|v_j\>_r)
(\bar{\beta}_{j^\prime}{}_q\<u_{j^\prime}|_r\<v_{j^\prime}|)\bigg] \notag\\
\sqsubseteq\ &
|0\>_p\<0|\otimes(|x\>_q\<x|\otimes|1\>_r\<1| + I_q\otimes |0\>_r\<0|) \notag\\
=\ & R \label{RR}
\end{align}
Combine all above formulas using rule (Rule Sequential Composition) and (Rule Order), we obtain:
$$
\vdash_{qPD} \{P\}D\{R\}
$$
for loop body. Actually, we may notice the relation between $P,Q$ and $R$:
$$R = M_0^\dag Q M_0 + M_1^\dag P M_1.$$
Therefore, we can apply (Rule Loop Partial) directly to conclude:
$$
\vdash_{qPD} \{R\}{\rm\bf while\ }M[r] = 1 {\ \rm\bf do\ } D {\ \rm\bf od\ }\{Q\}
$$
The following formula is trivial if we use (Axiom Initialization) and (Rule Sequential Composition):
$$
\vdash_{qPD} \{I_p\otimes I_q\otimes I_r\}p := |0\>^{\otimes n};
q := |0\>^{\otimes m};
r := |0\>;\{|0\>_p\<0|\otimes |0\>_q\<0|\otimes|0\>_r\<0|\},
$$
and therefore (Rule Order) ensures that:
$$
\vdash_{qPD} \{I_p\otimes I_q\otimes I_r\}p := |0\>^{\otimes n};
q := |0\>^{\otimes m};
r := |0\>;\{R\},
$$
as $|0\>_p\<0|\otimes |0\>_q\<0|\otimes|0\>_r\<0|\sqsubseteq R$.

Now, we are able to conclude
$$
\vdash_{qPD}\{I_p\otimes I_q\otimes I_r\}{\rm HHL}\{Q\},
$$
which directly show the correctness of HHL using
$$
\models_{\rm par}\{I_p\otimes I_q\otimes I_r\}{\rm HHL}\{|0\>_p\<0|\otimes |x\>_q\<x|\otimes|1\>_r\<1|\}
$$
followed from the soundness of the proof system qPD.

\textbf{Remark}: In above calculation, we use some extra assumptions: 1. $\delta_j\in \mathbb{N}^+$, 2. initial state of register $p$ is $|0\>$. Actually, without these two assumptions, the qHL system can still verify the correctness of HHL algorithm though the calculation is very tedious, in the sense that, the algorithm always terminate and the output of register $q$ is close to $|x\>$.






\iffalse    
\section{More on implementation, using mathcomp}
    
    (I feel so frustrated that I'm not able to use mathcomp in a right way, any tutorial to use it? For example, I import the related libraries and write following code,
    \begin{coq}
      Definition inner_prod {m n:nat} (phi: 'M[Z]_(m,n)) (psi: 'M[Z]_(n,m)) :=  mulmx psi phi.
    \end{coq}
    I get the error message 
    \begin{coq}
      The term "psi" has type "'M_(n, m)" while it is expected to have type "'M_(?m, ?n)".
    \end{coq}
    So, in this section, I'd like to write some high level implementations, rather than real implementation.)
    
    \subsection{Hilbert space and its dual}
\begin{coq}
(*Hilbert space of dimension d*)
Notation "'Hs' d" := 'M[C]_(d,1). 
          
(*Dual Hilbert space of dimension d*)
Notation "'Hs_d' d" := 'M[C]_(1,d). 
          
(* inner product of a dual vector and vector, yields a scalar in C*)
Definition inner_prod {d:nat} (phi: Hs d) (psi: Hs_d d) : C := \tr (psi *m phi).
          
(* outer product of a dual vector and vector, yields a scalar in C*)
Definition outer_prod {d:nat} (phi: Hs_d d) (psi: Hs d) : 'M[C]_(d,d) := phi *m psi.
          
(* tensor product (Kronecker product) of two matrices, the result matrix $M_{pr+v,qs+w}=M1_{rs}M2_{vw}$.*)
(* outer_prod is a special case of kron_prod, i.e., with m1=n2=d, n1=m2=1.*)
Definition kron_prod {m1 n1 m2 n2:nat} (M1:'M[C]_(m1,n1)) (M2:'M[C]_(m2,n2)) : 'M[C]_(m1*m2,n1*n2).

(*in particular, we kron_prod applied to vectors and dual vectors*)
Definition Hs_kron_prod {d:nat} (phi:Hs d) (psi:Hs d) : Hs (d*d) := kron_prod phi psi.
Definition Hs_d_kron_prod {d:nat} (phi:Hs_d d) (psi:Hs_d d) : Hs_d (d*d) := kron_prod phi psi.

Definition ketp {d:nat} (phi:Hs d) := phi.
Definition brap {d:nat} (phi:Hs_d d) := phi.
Notation "| phi >" := ketp phi.
Notation "< phi |" := brap phi.
Notation "< phi | psi >" := inner_prod phi psi.
Notation "| phi >< psi |" := outer_prod phi psi.
Notation "| phi >| psi >" := Hs_kron_prod phi psi.
Notation "< phi |< psi |" := Hs_d_kron_prod phi psi.
(*maybe unicode of < and > can be used $\<\ \>$*)
\end{coq}
We should be able to prove all the properties listed in Section \ref{sec abs def}.

\todo{properties of tensor product should be added.}



\subsection{labeled (dual) Hilbert space}
% \begin{coq}
% (*A finite set of labels, stands for quantum variables/systems*)
% Variable L : Set.

% (*A dimension function that gives the dimension of the quantum variables.*)
% Variable dim : L -> nat.

% (*Given a list of variables (no repeated element), calculate the dimension*)
% Fixpoint diml (l:list L) : nat := 
%     match l with
%     | nil => 1
%     | x::l' => (dim x) * (diml l')
%     end.

% (*Given a list of variables, its labeled Hilbert space*)
% Definition Hl (l:list L) := Hs (diml l).
% Definition Hl_d (l:list L) := Hs_d (diml l).
% Definition ketpl {l:list L} (phi: Hl l) := phi.
% Definition brapl {l:list L} (phi: Hl_d l) := phi.
% Notation "| phi >_ p" := ketpl p phi.
% Notation "p _< phi |" := brapl p phi.

% \end{coq}

% \begin{coq}
% (*Type of quantum expression, the first constructor is qe_err for invalid quantum expression, and the second constructor consists of a list l of variables for ket, a list l_d of variables for bra, a ket in Hs (diml l), and a bra in Hs_d (diml l)*)
% Inductive qexpr : Type := 
%     | qe_err
%     | qe_h (l:list L) (l_d:list L) (v:Hs (diml l)) (vd:Hs_d (diml l_d)).

% (*Check whether a list has duplication, true if no dup*)
% Fixpoint nodup_bool (l:list L) : bool := ....
% (*Check whether two list corresponds to the same set, true if the same set*)
% Fixpoint eqset_bool (l l':list L) : bool := ....
% (*Check whether two matrices are equivalent, true if equal*)
% Fixpoint eqmx {m1 n1 m2 n2:nat} {m1 n1 m2 n2:nat} (M1:'M[C]_(m1,n1)) (M2:'M[C]_(m2,n2)) : bool := ....


% (*Permute operator from a list to another list of variables*)
% Inductive perm_operator (l:list L) (l':list L) : 'M[C]_(diml l, diml l') := ....

% Lemma twoequal_tenequal: forall (m1 n1 m2 n2:nat) (M1 M1':'M[C]_(m1,n1)) (M2 M2':'M[C]_(m2,n2)),
%     eqmx (kron_prod M1 M1') (kron_prod M2 M2') = true <-> exists (a a': C), a*a' = 1 /\ eqmx a*M1 M1 && eqmx a'*M2 M2 = true.
    
% (*Here we need to define the equivalence of two quantum expressions*)
% Definition eqb_qexpr (e1 e2:qexpr) : bool :=
%     match e1, e2 with
%     | qe_err, _ => false    (*invalid expressions are not equal*)
%     | _, qe_err => false
%     | qe_h l1 l1_d v1 v1_d, qe_h l2 l2_d v2 v2_d =>
%         if (nodup_bool l1 && nodup_bool l1_d && nodup_bool l2 && nodup_bool l2_d 
%             && eqset_bool l1 l2 && eqset_bool l1_d l2_d
%             && eqmx (  (kron_prod ((perm_operator l1 l2) *m v1) v1_d) 
%               (kron_prod v1 (v1_d *m (perm_operator l1_d l2_d)))  )   )
%             then true else false
%     end

% (*Define +, $\cdot$ for two qexpr*)
% Definition ...

% \end{coq}
% Prove properties listed in Sec. \ref{sec qexpr}.
        
\begin{coq}

(*Hilbert space of dimension d*)
Notation "'Hs' d" := 'M[C]_(d,1). 
(*linear map: Hs d1 -> Hs d2*)
Notation "'lo' d1 d2" := 'M[C]_(d2,d1).

(*Conjugate transpose of matrix*)
Defintion conj_tran {m n: nat} (M: lin_op m n) : lin_op n m :=....
Notation "M '^d'" := conj_tran M.
(* inner product of two vectors, yields a scalar in C*)
Definition inner_prod {d:nat} (phi psi: Hs d) : C := \tr (phi^d *m psi).
          
(* tensor product (Kronecker product) of two matrices, the result matrix $M_{pr+v,qs+w}=M1_{rs}M2_{vw}$.*)
Definition kron_prod {m1 n1 m2 n2:nat} (M1:'M[C]_(m1,n1)) (M2:'M[C]_(m2,n2)) : 'M[C]_(m1*m2,n1*n2).

Notation "< phi ; psi >" := inner_prod phi psi.
Notation "M1 '*o' M2" := kron_prod M1 M2.

(*A finite set of labels, stands for quantum variables/systems*)
Variable L : Set.

(*A dimension function that gives the dimension of the quantum variables.*)
Variable dim : L -> nat.

(*Given a list of variables (no repeated element), calculate the dimension*)
Fixpoint diml (l:list L) : nat := 
    match l with
    | nil => 1
    | x::l' => (dim x) * (diml l')
    end.

(*Given a list of variables, its labeled Hilbert space*)
Definition Hl (l:list L) := Hs (diml l).
Definition lol (l1 l2:list L) := lo (diml l1) (diml l2).

Definition Hl (l:list L) := Hs (diml l).
Inductive qexpr :=
    | qerr
    | complex : Z -> qexpr
    | ket (q: L) : Hl (q::nil) -> qexpr
    | bra (q: L) : Hl (q::nil) -> qexpr
    | kets (l : list L) : Hl l -> qexpr
    | bras (l : list L) : Hl l -> qexpr
    | qe_add : qexpr -> qexpr -> qexpr
    | qe_mul : qexpr -> qexpr -> qexpr
(*     | qe_sum (T:finType) : (T -> qexpr) -> qexpr
    | qe_prod (T:finType) : (T -> qexpr) -> qexpr *).
Inductive qexpr_type := 
    | terr
    | qtype (l1 l2:list L).
(*equality of two lists that are treated as sets*)
Fixpoint set_in (x:L) (l:list L) : bool :=
  match l with
  | nil => false
  | x1::l' => if (x =? x1) then true
              else set_in x l'
  end.
Fixpoint set_add_end (x:L) (l:list L) : list L :=
  match l with
  | nil => x::nil
  | x1::l' => if (x =? x1) then l
              else x1::(set_add_end x l')
  end.
Fixpoint set_remove (x:L) (l:list L) : list L :=
  match l with
  | nil => nil
  | x1 :: l' => if (x =? x1) then set_remove x l'
                else x1::(set_remove x l')
  end.
Fixpoint set_eq (l1 l2:list L) : bool := 
  match l1 with
  | nil => match l2 with
           | nil => true
           | _ => false
           end
  | x::l => if (set_in x l2) then set_eq l (set_remove x l2)
            else false
  end.
Notation "l1 '=s' l2" := (set_eq l1 l2) (at level 3).
(*substraction of two sets, l1 - l2, delete all l2 elements from l1*)
Fixpoint set_sub (l1 l2: list L) : list L := 
  match l2 with
  | nil => l1
  | x::l2' => set_sub (set_remove x l1) l2'
  end.
Notation "l1 '-s' l2" := (set_sub l1 l2) (at level 3).
(*union of two sets*)
Fixpoint set_union (l1 l2: list L) : list L := 
  match l2 with
  | nil => l1
  | x::l2' => if (set_in x l1) then set_union l1 l2'
              else set_union (set_add_end x l1) l2'
  end.
Notation "l1 'us' l2" := (set_union l1 l2) (at level 3).
Fixpoint set_nodup (l:list L) : bool :=
  match l with
  | nil => true
  | x::l' => if (set_in x l') then false
            else set_nodup l'
  end.
(*intersection of two sets*)
Fixpoint set_intersection (l1 l2: list L) : list L := 
  match l1 with
  | nil => nil
  | x::l1' => if (set_in x l2) then x::(set_intersection l1' l2)
              else set_intersection l1' l2
  end.
Notation "l1 'ns' l2" := (set_intersection l1 l2) (at level 3).
(*set is empty*)
Definition set_emp (l: list L) : bool := 
    match l with
    | nil => true
    | x::l' => false
    end.
Notation "l '=emp'" := (set_emp l) (at level 4).
(* determine if two qexpr_types are 'equal' *)
Definition qtype_eq (t1 t2:qexpr_type) : bool :=
    match t1,t2 with
    | terr, terr => true
    | terr, qtype l1 l2 => false
    | qtype l1 l2, terr => false
    | qtype l1 l2, qtype l1' l2' => (l1 =s l1') && (l2 =s l2')
    end.
Notation "qt1 '=t' qt2" := (qtype_eq qt1 qt2) (at level 3).
(* Type of an expression $e$ is inductively defined by*)
Fixpoint get_qtype (e:qexpr) : qexpr_type :=
    match e with
    | qerr => terr
    | complex x => qtype nil nil
    | ket q _ => qtype (q::nil) nil
    | bra q _ => qtype nil (q::nil)
    | kets l _ => qtype l nil
    | bras l _ => qtype nil l
    | qe_add e1 e2 => if ( Bool.eqb ((get_qtype e1) =t (get_qtype e2)) true) then
                          get_qtype e1 else terr
    | qe_mul e1 e2 => match (get_qtype e1),(get_qtype e1) with
                          | terr, _ => terr
                          | _, terr => terr
                          | qtype l1 l1', qtype l2 l2' =>
                                if ( Bool.eqb (andb (l1 ns (l2 -s l1') =emp) ((l1' -s l2) ns l2' =emp)) true) then
                                qtype (l1 us (l2 -s l1')) ((l1' -s l2) us l2')
                                else terr
                          end
(*     | qe_sum T f => (* how to split T = T' U {x}? an induction on qe_add*)
                        (* T = emptyset, return terr. At least one element*)
                        (* T = {x}, return get_qtype (f x) *)
                        (* T = T' U {x}, return get_qtype (qe_add (qe_sum T' f) (f x)) *)
    | qe_prod T f => (* how to split T = T' U {x}? an induction on qe_mul*)
                        (* T = emptyset, return qtype [] []. Treated as 1%C*)
                        (* T = {x}, return get_qtype (f x) *)
                        (* T = T' U {x}, return get_qtype (qe_mul (qe_prod T' f) (f x)) *) *)
    end.
   
(*labeled linear operator*)     
Inductive lin_op :=
    | oerr
    | lin_map (l1 l2:list L) (M : lol l1 l2). 

(*Permute matrix*)
Fixpoint perm_mx (l1 l2:list L) : (M: lol l1 l2) :=
    if (l1 =s l2) then ....
    else oerr.

(*Permute the basis of preimage and image. The order of lists might be different.*)
(* change the preimage to l*)
Fixpoint perm_preimage (l:list L) (M: lin_op) : lin_op := 
    match M with
    | oerr => oerr
    | lin_map l1 l2 M => if (l =s l1) then 
                                lin_map l l2 (M *m perm_mx l l1)
                         else oerr
    end.
Fixpoint perm_image (l:list L) (M: lin_op) : lin_op := 
    match M with 
    | oerr => oerr
    | lin_map l1 l2 M => if (l2 =s l) then 
                                lin_map l1 l (perm_mx l2 l *m M)
                         else oerr
    end.
    
    


    \end{coq}
    
    % \subsection{Operations}
    % \begin{itemize}
    %     \item ordinary operations/functions on bool, nat, R and C.
    %     \item addq: $\forall$ t $\in$ diraceqn, t $\rightarrow$ t $\rightarrow$ t. Addition.
        
    %         Notation: $\us + \us$
    %     \item multq: $\forall\,t1,t2\in$diraceqn, t1 $\rightarrow$ t2 $\rightarrow$ (t1$\rightarrow$t2). Multiplication. 
        
    %         Notation: $\us \ast \us$
    %     \item Inner and Outer product are two special case of multq, as well as tensor product. ($|\phi\>_p|\psi\>_q$ can be interpreted by multq, of course it also represent $|\phi\>_p\otimes|\psi\>_q$. Since we specify the quantum variables, there is no need to add $\otimes$. For example,
        
    %     inner\_prod: $\forall\,q\in L$, ket $q$ $\rightarrow$ bra $q$ $\rightarrow$ C. Inner product. (same for $\qbar$)
        
    %         Notation: $\<\us|\us\>$
            
    %     outer\_prod: $\forall\,q\in L$, bra $q$ $\rightarrow$ ket $q$ $\rightarrow$ (bra $q$ $\rightarrow$ ket $q$). Outer product. (same for $\qbar$)
        
    %         Notation: $|\us\>_q\<\us|$
    %     \item Big operators. summation and product. For example,
    %         $$\sum_{i\in idx} \alpha_i|\phi_i\>_q,\quad \prod_{i\in idx} |\phi_i\>_{q_i}.$$
    %         As mentioned, tensor product can be seen as a multiplication here, we just use $\prod$ rather than $\bigotimes$.
            
    %         However, we should carefully distinguish the different meaning if we want to transform an expression of multq to concrete form:
    %         multq on the same label is the matrix multiplication, multq on different labels is the matrix tensor product.
    % \end{itemize}
\fi

\iffalse
\section{Theories}

In this section, I'll list the (necessary) theories.

\subsection{quantum}

\subsubsection{done}

\noindent Definition of HermitianSpace: vector space equipped with inner product \tt{dotp \us\ \us : C} (notation \tt{[< \tus\ ; \tus\ >]}) satisfies:
\begin{itemize}
\item \tt{forall u, 0 <= dotp u u}
\item \tt{forall u, dotp u u == 0) = (u == 0)}
\item \tt{forall u v, (dotp u v)\^{}* = dotp v u}
\item \tt{forall (a : C) u v w, dotp u (a *: v + w) = a * (dotp u v) + dotp u v}
\end{itemize}

\noindent Property of inner product \tt{[< \tus; \tus\ >]}: 
\begin{itemize}
\item \tt{E}: Hermitian space, \tt{u v w : E, a b : C}.
\item Lemma \tt{ge0\us dotp u : 0 <= [< u; u >]}
\item Lemma \tt{dotp\us eq0 u : ([< u; u >] == 0) = (u == 0)}
\item Lemma \tt{dotp00 : [< 0; 0 >] = 0}
\item Lemma \tt{conj\us dotp u v : [< u; v>]\^{}* = [< v; u >]}
\item Lemma \tt{linear\us dotp (a:C) u v w : [< u; a *: v + w >] = a * [< u; v >]+[< u; w >]}
\item Lemma \tt{dotp\us is\us antilinear (a:C) u v w: [< a *: u + v; w >] = a\^{}*[< u; w >] + [< v; w >]}
\item Lemma \tt{dotp\us is\us additive w : forall u v, [< u-v; w >] = [< u; w >] - [< v; w >]}
\item Lemma \tt{dotpNl w : forall x, [< -x; w >] = - [< x; w >]}
\item Lemma \tt{dotpDl w: forall x y, [< x + y; w >] = [< x; w >] + [< y; w >]}
\item Lemma \tt{dotpMnl w (n:nat): forall x, [< x *+ n; w >] = [< x; w >] *+ n} (\text{*+} n: add n times)
\item Lemma \tt{dotp\us suml (I : Type) (r : seq I) (P: I -> bool) (F : I -> E) u :	 
[< \bs sum\us(v <- r | P v) F v; u >] = \bs sum\us(v <- r | P v) [< F v; u >]}
\item Lemma \tt{dotpNr dotpDr dotpMnr dotp\us sumr}
\item Lemma \tt{dotpD u v: [< u + v; u + v >] = [< u; u >] + [< v; v >] + ([< u; v >] + [< u; v >]\^{}*)}
\item Lemma \tt{dot0p u : [< 0; u >] = 0}
\item Lemma \tt{dotp0 u : [< u; 0 >] = 0}
\item Lemma \tt{dotpZl (x:C) u v : [< x *: u; v >] = x\^{}* * [< u; v >]}
\item Lemma \tt{dotpZr (x:C) u v : [< u; x *: v >] = x * [< u; v >]}
\item Lemma \tt{real\us dotpp u : [< u; u >] \bs is Num.real }
\end{itemize}

\noindent CauchySchwartz inequality:
\begin{itemize}
\item length of \tt{u: \bs sqrtC [< u; u >]} (notation \tt{`<| u |>})
\item Lemma \tt{CauchySchwartz (u v) : E: `|[< u; v >]|\^{}+2 <= [< u; u >] * [< v; v >]}
\item Lemma \tt{CauchySchwartz\us sqrt (u v) : E : `|[< u; v >]| <= <| u |> * <| v |>}
\end{itemize}

\noindent Properties of norm:
\begin{itemize}
\item \tt{hermitian\us normedZmodMixin :} length \tt{\bs sqrtC [< u; u >]} is a norm.
\item Lemma \tt{hnormE u : `| u | = \bs sqrtC [< u; u >]}
\item Lemma \tt{normrZ (k:C) u : `|k *: u| = `|k| * `|u|}
\item Lemma \tt{dotp\us norm u: [< u; u >] = `|u|\^{}+2}
\end{itemize}

\noindent Matrices: conjugate, adjoint, normal matrix, unitary matrix
\begin{itemize}
\item Definition \tt{conjmx M}: conjugate of M. Notation \tt{M \^{}*m}
\item Lemma \tt{conjmx\us is\us additive: forall M N, (M - N)\^{}*m = M\^{}*m - N\^{}*m}
\item Lemma \tt{conjmx\us is\us multiplicative : forall (m:nat) (M N : 'M[C]\us(m.+1, m.+1)) (M * N)\^{}*m = M\^{}*m * N\^{}*m}
\item Lemma \tt{conjmxZ \{m n\} (c : C) (A : 'M[C]\us(m, n)) : (c *: A)\^{}*m = c\^{}* *: A\^{}*m}
\item Lemma \tt{conjmxK \{m n\} : forall M : 'M[C]\us(m,n), (M\^{}*m)\^{}*m = M}
\item Lemma \tt{det\us conj \{m\} (M : 'M[C]\us m) : \bs det M\^{}*m = (\bs det M)\^{}*} (determinant)
\item Definition \tt{adjmx \{m n : nat\} (M : 'M[C]\us(m, n)) := (M\^{}*m)\^{}T}. Notation \tt{\us\^{}A}
\item Lemma \tt{adjmxE \{m n : nat\} (M : 'M[C]\us (m, n)) : M\^{}A = M\^{}*m\^{}T}
\item Lemma \tt{adjmxEr \{m n : nat\} (M : 'M[C]\us (m, n)) : M\^{}A = M\^{}T\^{}*m}
\item Lemma \tt{adjmxK \{m n : nat\} : forall M:'M[C]\us(m, n), (M\^{}A)\^{}A = M}
\item Lemma \tt{det\us adj \{m : nat\} (M : 'M[C]\us m) : \bs det M\^{}A = (\bs det M)\^{}*}
\item Definition: adjoint of linear mapping \tt{adj\us lfun (E : hermitianType) (f : hom E E)} \\
		First map f to matrix, then adj of the matrix, finally map back to hom E E. \\
		Notation \tt{f \^{}A}
\item Definition \tt{normalmx \{m : nat\} :=
  [qualify a M : 'M[C]\us m | M *m M\^{}A == M\^{}A *m M]}. 
  	(normal matrices: $M^\dag M = MM^\dag$).
\item Lemma \tt{normalmxP \{m : nat\} (M : 'M[C]\us m) :
  reflect (M *m M\^{}A = M\^{}A *m M) (M \bs is a normalmx)}
\item Definition \tt{unitarymx \{m : nat\} :=
  [qualify a M : 'M[C]\us m | (M *m M\^{}A == 1\%:M) \&\& (M\^{}A *m M == 1\%:M)]} \\
  (\tt{1\%:M} identity matrix)
\item Lemma \tt{unitarymxP \{m : nat\} (M : 'M[C]\us m) :
  reflect (M *m M\^{}A = 1\%:M /\bs M\^{}A *m M = 1\%:M) (M \bs is a unitarymx)}
\item Lemma \tt{normal\us unitary \{m : nat\} (M : 'M[C]\us m) :
  M \bs is a unitarymx -> M \bs is a normalmx.}
\item Lemma \tt{det\us unitary \{m : nat\} (M : 'M[C]\us m.+1) :
  M \bs is a unitarymx -> `|\bs det M| = 1.}
\end{itemize}

\noindent Orthonormal and basis.
\begin{itemize}
\item \tt{E : hermitianType}.
\item Definition \tt{orthonormal (vs : seq E) :=
  [forall i : 'I\us (size vs),
    [forall j : 'I\us (size vs),
      [< vs`\us i; vs`\us j >] == (i == j)\%:R]].}
\item Lemma \tt{orthonormalP (vs : seq E) :
  reflect
    (forall i j, (i < size vs)\%N -> (j < size vs)\%N ->
       [< vs`\us i; vs`\us j >] = (i == j)\%:R)
    (orthonormal vs).}
\item Lemma \tt{orthonormal\us nil : orthonormal [::]}
\item Lemma \tt{orthonormal\us cons v vs :
     orthonormal vs
  -> \{in vs, forall u, [< u; v >] = 0\}
  -> [< v; v >] = 1
  -> orthonormal (v :: vs)}
\item Lemma \tt{orthonormal\us perm us vs :
     perm\us eq us vs
  -> orthonormal us
  -> orthonormal vs} (\tt{perm\us eq}: equal up to permutation)
\item Lemma \tt{orthonormal\us nz v vs : orthonormal vs -> v \bs in vs -> v != 0.} \\
	(basis is not 0).
\item Lemma \tt{orthonormal\us uniq vs : orthonormal vs -> uniq vs.} \\
	(element in a basis is unique, i.e., no duplicate).
\item Lemma \tt{orthonormal\us dotp vs w1 w2 :
  orthonormal vs -> w1 \bs in vs -> w2 \bs in vs -> [< w1; w2 >] = (w1 == w2)\%:R.} 
\item Definition \tt{onbasis\us of (A : \{vspace E\}) (vs : seq E) :=
  basis\us of A vs \&\& orthonormal vs.} \\
  (\tt{vs} is an orthonormal basis of vector space \tt{A}).
\end{itemize}

\noindent GramSchmidt normalization
\begin{itemize}
\item \tt{E : hermitianType}.
\item Definition \tt{normd (u : E) := `|u|\^{}-1 *: u.} \\
	normalize a vector.
\item Lemma \tt{normd0 : normd 0 = 0.}
\item Lemma \tt{norm\us normd (u : E) : `|normd u| = (u != 0)\%:R.}
\item Lemma \tt{dotp\us norml (u v : E) :
  [< normd u; v >] = `|u|\^{}-1 * [< u; v >].}
\item Lemma \tt{dotp\us normr (u v : E) :
  [< u; normd v >] = `|v|\^{}-1 * [< u; v >].}
\item Lemma \tt{span\us normd (x : E) : (<[normd x]> = <[x]>)\%VS.} \\
	normalization doesn't effect the space of span.
\item Definition \tt{GramSchmidt (vs : seq E) :=
  foldr (fun v us => normd (v - \bs sum\us (u <- us) [< u; v >] *: u) :: us) [::] vs.} \\
  GramSchmidt normalization
\item Lemma \tt{GramSchmidt\us nil : GramSchmidt [::] = [::].}
\item Lemma \tt{GramSchmidt\us cons v vs : GramSchmidt (v :: vs) =
  normd (v - \bs sum\us (u <- GramSchmidt vs) [< u; v >] *: u) :: GramSchmidt vs.}
\item Lemma \tt{span\us consD (u v : E) (vs : seq E) :
  v \bs in << vs >>\%VS -> << (u + v)\%R :: vs >>\%VS = << u :: vs >>\%VS.}
\item Lemma \tt{GramSchmidt\us size (vs : seq E) : size (GramSchmidt vs) = size vs.}
\item Lemma \tt{GramSchmidt\us span (vs : seq E) : << GramSchmidt vs >>\%VS = << vs >>\%VS.} \\
	GramSchmidt normalization doesn't change the span space.
\item Lemma \tt{GramSchmidt\us free (vs : seq E) : free (GramSchmidt vs) = free vs.} \\
	\tt{free vs := \bs dim <<vs>> == size vs}, i.e., \tt{vs} is a set of linearly independent vectors.
\item Lemma \tt{GramSchmidt\us basis (A : \{vspace E\}) (vs : seq E) :
  basis\us of A (GramSchmidt vs) = basis\us of A vs.}
\item Lemma \tt{GramSchmidt\us orthonormal (vs : seq E) :
  free vs -> orthonormal (GramSchmidt vs).}	\\
  \tt{vs} is linearly independent, then GramSchmidt normalization gives an orthonormal sets. (no 0 occurs)
\item Lemma \tt{vonbasis\us proof (A : \{vspace E\}) :
  \{ vs : (\bs dim A).-tuple E | onbasis\us of A vs \}.} \\
  existence of \tt{vs}.
\item Definition \tt{vonbasis (A : \{vspace E\}) : (\bs dim A).-tuple E :=
  nosimpl (projT1 (vonbasis\us proof A)).} \\
  get one vonbasis from the set \tt{\{ vs : (\bs dim A).-tuple E | onbasis\us of A vs \}.}
\item Lemma \tt{vonbasisP (A : \{vspace E\}) : onbasis\us of A (vonbasis A).}
\end{itemize}


\noindent DotP\us ONB, dotp u v can be calculated by their component of arbitrary ONB.
\begin{itemize}
\item \tt{E : hermitianType}.
\item \tt{Lemma dotp\us onb \{n\} (A : \{vspace E\}) (u v : E) (vs : n.-tuple E) :
  u \bs in A -> v \bs in A -> onbasis\us of A vs ->
    [< u; v >] = \bs sum\us i (coord vs i u)\^{}* * coord vs i v.} \\
\item Lemma \tt{coord\us basis :
    forall [K : fieldType] [vT : vectType K]
      [U : {vspace vT}] [n : nat] [X : n.-tuple vT]
      [v : vT],
    basis\us of U X ->
    v \bs in U -> v = \bs sum\us i coord X i v *: X`\us i}
\end{itemize}


\tt{section of matrix and linear mapping should be generalized to $\cL(H,H^\prime)$}
\tt{conjmx\us is\us multiplicative} should apply to more general case, i.e., \tt{M : 'M[C]\us(m.+1, n.+1), N : 'M[C]\us(n.+1, p.+1)}
\fi
\fi
