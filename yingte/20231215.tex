\chapter{20231215}




Firstly let's review the simply typed lambda calculus with product type and projections. Product type is used to model the tensor of linear spaces.

\section{STLC with Tuples}

\subsection{STLC with tuple types and projections}

\begin{definition}
    A \textbf{simply typed lambda calculus} with (strict) tuple types and projections consists of types $\tau$ and terms $e$. The syntax is:
    \begin{align*}
        \tau ::=&\ T\ |\ \tau \to \tau\\
          &\ |\ \{ \tau * \tau * \cdots * \tau \} \\
        e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
          &\ |\ \{ e, e, \dots, e \}\ |\ \pi_i\ e
    \end{align*}
    Here $T \in B$ is a basic type, $x$ is a variable and $c$ is a constant.
    $\tau * \tau * \cdots * \tau$ and $e, e, \dots, e$ are finite sequences. $i$ is a constant positive number.
\end{definition}

\textbf{Remark:} Unit is modelled by the empty tuple $\{*\}$, which has the only term $\{\}$.

\begin{definition}[typing rules]
    \label{def:STLC_tuple_typing_3}
    A typing assumption has the form $x : \tau$, meaning variable $x$ has the type $\tau$. A typing context $\Gamma$ consists of typing assumptions and each variable appears only once at most.

    A typing judgement $\Gamma \vdash e : \sigma$ indicates that $e$ is a term of type $\sigma$ in context $\Gamma$. The well-typed lambda terms are defined by the following rules:
    \begin{gather*}
        \frac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}
        \qquad \frac{c\ \textrm{is a constant of}\ T}{\Gamma \vdash c : T}\\
        \ \\
        \frac{\Gamma::(x : \tau) \vdash e : \sigma \qquad x \notin \Gamma}{\Gamma \vdash (\lambda x : \tau.e) : (\tau \to \sigma)}
        \qquad \frac{\Gamma \vdash e_1 : \tau \to \sigma \qquad \Gamma \vdash e_2 : \tau}{\Gamma \vdash e_1\ e_2 : \sigma}\\
        \ \\
        \frac{\forall i, \Gamma \vdash e_i : \tau_i}{\Gamma \vdash \{e_1, \dots, e_n \} : \{ \tau_1 * \cdots * \tau_n\}}
        \qquad 
        \frac{\Gamma \vdash e : \{ \tau_1 * \cdots * \tau_n \} \qquad i \leq n}{\Gamma \vdash \pi_i\ e : \tau_i}
    \end{gather*}
\end{definition}

\begin{definition}[equational theory]
  \label{def: STLC_eq_theory_3}
  $$
      \textbf{$\alpha$-conversion} \qquad\lambda x.t = \lambda y.t[y/x]\qquad \text{($y$ is not free in $t$)}
  $$
\end{definition}

\begin{definition}[reduction rules]
    \label{def:STLC_tuple_red_3}
    The reduction rules for terms are:
    \begin{gather*}
        \frac{\Gamma::(x:\tau)\vdash t:\sigma\qquad \Gamma\vdash u:\tau}{\Gamma \vdash (\lambda x : \tau.t)\ u \ \triangleright_\beta\ t[x/u]}
        \qquad 
        \frac{\Gamma \vdash t : \tau \to \sigma\qquad x\ \textrm{is free in}\ t}{\Gamma \vdash \lambda x : \tau. t\ x\ \triangleright_\eta\ t}\\
        \ \\
        \frac{\Gamma \vdash \{e_1, \dots, e_n \} : \{ \tau_1 * \cdots \tau_n\}\qquad i \leq n}{\Gamma \vdash \pi_i\ \{e_1, \dots, e_n \}\ \triangleright_\pi\ e_i}
        \qquad
        \frac{\Gamma \vdash u : \{ \tau_1 * \cdots * \tau_n\}}{\Gamma \vdash \{\pi_1\ u, \dots, \pi_n\ u \}\ \triangleright_\pi\ u}
        \qquad
        \frac{\Gamma \vdash t : \{*\}}{\Gamma \vdash t\ \triangleright_\pi\ \{\}}
    \end{gather*}

    Two terms $s$ and $t$ are $\beta\eta\pi$-equivalent in context $\Gamma$, written as $\Gamma \vdash s =_{\beta\eta\pi} t$, if they have the same normal form after $\beta\eta\pi$-reduction.
\end{definition}

\yx{The congruence of the reductions needs to be clarified. This should have been well studied already.}


\subsection{STLC with flexible tuples}

Types of flexible tuple are needed to facilitate the reasoning of Dirac notations in the mathematical style, where the equivalence is considered much more casually. For example:
$$
\ket{[0,[1,0]]} = \ket{0} \otimes (\ket{1} \otimes \ket{0}) = \ket{0} \otimes \ket{1} \otimes \ket{0} = \ket{[[0, 1], 0]} = \ket{[0, 1, 0]}.
$$

\begin{definition}[STLC with flexible tuples]
  A \textbf{simply typed lambda calculus} with flexible tuples consists of types $\tau$ and terms $e$. The syntax is:
  \begin{align*}
      \tau ::=&\ T\ |\ \tau \to \tau\\
        &\ |\ \{ \tau * \tau * \cdots * \tau \} \\
        &\ |\ [ \tau * \tau * \cdots * \tau ] \\
      e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
        &\ |\ \{ e, e, \dots, e \}\ |\ \pi_i\ e \\
        &\ |\ [ e, e, \dots, e ]
  \end{align*}
  Here $T \in B$ is a basic type, $x$ is a variable and $c$ is a constant.
  $\tau * \tau * \cdots * \tau$ and $e, e, \dots, e$ are finite sequences. $i$ is a constant positive number.
\end{definition}

\textbf{Remark: }We don't consider projections for sequence $[ e, e, \dots, e ]$ because they don't have a fixed length after we incorporate the isomorphism into the equational theory.



\begin{definition}[typing rules]
  \label{def:STLC_flexible_tuple_typing_3}
  The typing rules include those in Def.\ref{def:STLC_tuple_typing_3} and the following rules:
  \begin{gather*}
      \frac{\forall i, \Gamma \vdash e_i : \tau_i}{\Gamma \vdash [e_1, \dots, e_n ] : [ \tau_1 * \cdots * \tau_n ]}
  \end{gather*}
\end{definition}

Due to the product and unit types, we need to extend the $\beta\eta\pi$-equivalence to contain the isomorphism as well. This is necessary because of the isomorphism between linear spaces.

\begin{definition}[equational theory]
  \label{def: STLC_flexible_eq_theory_3}
  The equational theory for STLC with flexible tuple include those rules in Def.\ref{def: STLC_eq_theory_3} and the following equations for linear space isomorphisms:
  \begin{gather*}
    [\tau_1 * \cdots * \tau_i * [\sigma_1 * \cdots * \sigma_m] * \tau_{i+1} * \cdots * \tau_n] = [\tau_1 * \cdots * \tau_i * \sigma_1 * \cdots * \sigma_m * \tau_{i+1} * \cdots * \tau_n]\\
    \ \\      
    [e_1, \dots, e_i, [s_1, \dots, s_m], e_{i+1}, \dots, e_n] = [e_1, \dots, e_i, s_1, \dots, s_m, e_{i+1}, \dots, e_n]
  \end{gather*}

\end{definition}

\begin{definition}[reduction rules for flexible tuple]
  \label{def:STLC_flexible_tuple_red_3}
   The reduction rules for flexible tuples are:
  \begin{gather*}
      \frac{\Gamma \vdash t : [*]}{\Gamma \vdash t\ \triangleright_\phi\ []}
  \end{gather*}
\end{definition}

\textbf{Remark:} Note that no projectors are considered because flexible tuples do not have a fixed length.

In short, the flexible tuple $[\cdots]$ is flattened and the unit types inside are removed. It is used to encode the Dirac notations in the mathematics style.

\yx{Congruence for $\beta\eta\pi\phi$-reduction?}

\section{Dirac Lambda Calculus}

\yx{It can be considered as a computational definition for Dirac notation.}


\subsection{Motivating Examples}
We investigate several examples that motivates the adoption of a lambda calculus.

\begin{example}[variable and big-op]
  Assume $S, T$ are two disjoint subsystems with orthonormal basis $\{\ket{v_i}_S\}_{i \in J}$ and $\{\ket{u_i}_T\}_{i \in J}$.
  $$
  \sum_{mn}A(m, n) \ket{v_m}_S\bra{v_n} \sum_i \ket{v_i}_S \ket{u_i}_T.
  $$
\end{example}
We have big-op of sum, and the indices appear in the vector (not the quantum register). This makes sense because the summation requires every labelled dirac notation to have the same type. It's also appropriate to assume that indices $m, n$ and $i$ are variables following some space type $T$. And the scope of summation is implicitly designated as a set. We also need functions: they appear directly as $A : T \times T \to \mathbb{C}$, and play the important role in big-op:
$$
\frac{\Gamma \vdash v : T \to \texttt{Unit} \multimap \tau \qquad \Gamma \vdash m : T}{\Gamma \vdash v_m : \texttt{Unit} \multimap \tau}.
$$
Here $\texttt{Unit} \multimap \tau$ represents the type of linear operators with domain \texttt{Unit} and codomain $\tau$. Obviously we will need some typed lambda calculus for it. And actually the big-op of sum can be modelled by:
$$
\sum : (T\ \tau\ \sigma : \texttt{Type}) \to \mathcal{P}(T) \to (T \to \tau \multimap \sigma) \to (\tau \multimap \sigma).
$$

Here $\texttt{Type}$ is the sort for types. The first argument $T$ corresponds to the type of indices, the next two parameters $\tau$ and $\sigma$ correspond to the type of Dirac notations, the fourth argument is the set of index values and the last argument is the term expression.

\begin{example}[definitions]
  Consider this notation (of labelled Dirac notations):
  $$
  \left [\ket{+} := \lambda x:\texttt{qvar(bool)}.\frac{\ket{0}_x + \ket{1}_x}{\sqrt{2}} \right ][y : \texttt{qvar(bool)}] \vdash \bra{+}_y * \ket{+}_y = 1
  $$
\end{example}
In other words, it's reasonable to have definitions for Dirac notations. Typed lambda calculus also solves this problem.

\begin{example}[super operator]
  Consider the super operator 
  $$
  \mathcal{P}_0 (\rho) = \ket{0}\bra{0} \rho \ket{0}\bra{0} + \ket{0}\bra{1} \rho \ket{1}\bra{0}.
  $$
  It can be expressed by the Dirac notation
  $$
  \mathcal{P}_0 : (\texttt{bool} \multimap \texttt{bool}) \multimap (\texttt{bool} \multimap \texttt{bool}) := \ket{\ket{0}\bra{0}}\bra{\ket{0}\bra{0}} + \ket{\ket{0}\bra{0}}\bra{\ket{1}\bra{1}}
  $$
\end{example}

And we will need the operator to transform between an operator and its Choi representation:

\begin{definition}[choi and unchoi]
  \begin{align*}
    \alpha : (T \multimap U) \to ([*] \multimap [T \multimap U]) =\ & \lambda t : (T \multimap U). \sum_{i : U} \sum_{j : T} \bra{i} \cdot t \cdot \ket{j} \otimes \ket{\ket{i}\bra{j}}\\
    \beta : ([*] \multimap [T \multimap U]) \to (T \multimap U) =\ & \lambda t : ([*] \multimap [T \multimap U]). \sum_{i : U} \sum_{j : T} \ket{i}\bra{j} \otimes \bra{\ket{i}\bra{j}} \cdot t
  \end{align*}
  
\end{definition}


\subsection{Syntax and Typing}

Now we extend the simply typed lambda calculus with Dirac notations.

\begin{postulate}[complex number]
  $\mathbb{C}$ is an algebra for complex numbers. It has the symbols $(0, 1, +, *, \textrm{conj})$.
\end{postulate}
It means that somehow we can express and decide complex number terms, but the theory should not be considered here.

\begin{definition}[atomic type and term]
  The atomic types are $\mathbf{Z}_n$.
  The constants of the type $\mathbf{Z}_n$ is $\{i \in \mathbb{N} : i<n\}$
  Here $n$ and $i$ are natural numbers.
\end{definition}

% \textbf{Remark:} We define atomic types separatedly because they describe the types of atomic quantum subsystems.

\begin{definition}[Dirac lambda calculus]
  \textbf{Dirac lambda calculus} is an extension of STLC with tuple types and Dirac notations. The syntax for types and terms is:
  \begin{align*}
    \tau ::=&\ T\ |\ \tau \to \tau\\
      &\ |\ [ \tau *\tau*\cdots * \tau ] \\
      &\ |\ \tau \multimap \tau\\
    e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
      % &\ |\ 0\ |\ 1\ |\ \mathrm{add}(e, e)\ |\ \mathrm{mul}(e, e)\ |\ \mathrm{conj}(e)\\
      &\ |\ [e, e, \dots, e] \\
      &\ |\ \mathbf{0}_{\tau, \tau}\ |\ \delta_{e, e}\ |\ \ket{e}\ |\ \bra{e}\ |\ e^*\ |\ e^T\ |\ e + e\ |\ e \cdot e\ |\ e \otimes e
  \end{align*}
  Here $T \in \{\mathbf{Z}_n, \mathbb{C}\}$ is a basic type, $x$ is a variable and $c$ is a constant. $\tau *\tau*\cdots * \tau$ and $e, e, \dots, e$ are finite sequences.
  In this article, the operators $\to$, $\multimap$, $*$ are right associative, and $+$, $\cdot$, $\otimes$ are left associative. Application $e\ e$ is left associative.
\end{definition}

\textbf{Remark: } Note that strict tuple $\{\cdots\}$ are not considered here. The essential reason is that only the order of tensor is considered in the structure of Hilbert space.

\yx{If we have big-operator, it seems that transpose and conjugate can be encoded by big-op:
\begin{align*}
  e^T & = \sum_i\sum_j \bra{i} \cdot  e \cdot \ket{j} \otimes \ket{j} \otimes \bra{i}  \\
  e^* & = \sum_i\sum_j \mathrm{conj}(\bra{i} \cdot  e \cdot \ket{j}) \otimes \ket{i} \otimes \bra{j}
\end{align*}
}

\begin{definition}[typing rules]
  \label{def:Dirac_typing_3}
  The concept of typing assumption, context and typing judgement is defined the same as in Def.\ref{def:STLC_flexible_tuple_typing_3}. The typing rules for Dirac lambda calculus include those in Def.\ref{def:STLC_flexible_tuple_typing_3} as well as the following ones:
  \begin{gather*}
    \frac{}{\Gamma \vdash \mathbf{0}_{\tau, \sigma} : [\tau] \multimap [\sigma]}
    \qquad
    \frac{\Gamma \vdash e : \mathbb{C}}{\Gamma \vdash e : [*] \multimap [*]}
    \qquad
    \frac{\Gamma \vdash s : \tau \qquad \Gamma \vdash t : \tau}{\Gamma \vdash \delta_{s, t} : [*] \multimap [*]}\\
    \ \\
    \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \ket{t} : [*] \multimap [\tau]}
    \qquad 
    \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \bra{t} : [\tau] \multimap [*]}\\
    \ \\
    \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash e^* : \sigma \multimap \tau}
    \qquad
    \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash e^T : \sigma \multimap \tau}\\
    \ \\
    \frac{\Gamma \vdash e_1 : \tau \multimap \sigma \qquad \Gamma \vdash e_2 : \tau \multimap \sigma }{\Gamma \vdash e_1 + e_2 : \tau \multimap \sigma }
    \qquad 
    \frac{\Gamma \vdash e_1 : \tau \multimap \rho\qquad \Gamma \vdash e_2 : \rho \multimap \sigma}{\Gamma \vdash e_2 \cdot e_1 : \tau \multimap \sigma}\\
    \ \\
    \frac{\Gamma \vdash e_1 : \tau \multimap \sigma \qquad \Gamma \vdash e_2 : \tau' \multimap \sigma'}{\Gamma \vdash e_1 \otimes e_2 : [\tau * \tau'] \multimap [\sigma * \sigma']}
  \end{gather*}
  
\end{definition}

\begin{claim}
  For any term $e$ of Dirac lambda calculus in any context $\Gamma$, there exists at most one type $\tau$ (w.r.t. $=_\phi$) that satisfies $\Gamma \vdash e : \tau$. The types of all terms are computable (if exist).
\end{claim}


\subsection{Equational Theory}

The equational theory for Dirac notation includes those in Def.\ref{def: STLC_flexible_eq_theory_3} and the following ones:

\subsubsection*{Delta Operator}
$$
    \delta_{t, s} = \delta_{s, t}
$$

\subsubsection*{AC functions}

Associative functions include: $\cdot$, $\otimes$. 
Associative commutative functions include: $+$.

\begin{align*}
    A + B = & B + A \\
    A + (B + C) = & A + B + C \\
    A \cdot (B \cdot C) = & A \cdot B \cdot C \\
    A \otimes (B \otimes C) = & A \otimes B \otimes C
\end{align*}



\subsection{Reduction in Dirac lambda calculus}
\label{subsec:Dirac reduction_3}
The reduction rules for terms in Dirac lambda calculus include those in Def.\ref{def:STLC_tuple_red_3}, Def.\ref{def:STLC_flexible_tuple_red_3} and the ones presented below.
We call these rules \textbf{Dirac reduction}.


\subsubsection*{Zero Operator}
\begin{align*}
  & \Gamma \vdash \mathbf{0}_{[*], [*]} \ \triangleright\ 0
\end{align*}


\subsubsection*{Delta Operator}
\begin{align*}
  & \Gamma \vdash \delta_{s, s}\ \triangleright\ 1
  \qquad
  \frac{s =? t\ \textrm{has no unifier in}\ \Gamma}{\Gamma \vdash \delta_{s, t} \ \triangleright\ 0}
\end{align*}

\subsubsection*{Ket}
\begin{align*}
  & \Gamma \vdash \ket{[]} \ \triangleright\ 1 \\
  & \Gamma \vdash \ket{[s_1, s_2, \dots, s_n]} \ \triangleright\ \ket{s_1} \otimes \ket{s_2} \otimes \cdots \otimes \ket{s_n}
\end{align*}

\subsubsection*{Bra}
\begin{align*}
  & \Gamma \vdash \bra{[]} \ \triangleright\ 1 \\
  & \Gamma \vdash \bra{[s_1, s_2, \dots, s_n]} \ \triangleright\ \bra{s_1} \otimes \bra{s_2} \otimes \cdots \otimes \bra{s_n}
\end{align*}

\textbf{Remark: } The flexible tuple $[\cdots]$ is mainly to couple with the equivalence of tensor product. For example, we require $\ket{s} \otimes (\ket{t} \otimes \ket{v}) = (\ket{s} \otimes \ket{t}) \otimes \ket{v}$, therefore $[s, [t, v]] = [[s, t], v]$, which means the tuple should be ``flattened'' when considering equivalence.

\subsubsection*{Conjugate}
\begin{align*}
  & \Gamma \vdash \textbf{0}_{\tau, \sigma}^* \ \triangleright\ \textbf{0}_{\tau, \sigma}
  \qquad 
  \frac{\Gamma \vdash c : \mathbb{C}}{\Gamma \vdash c^* \ \triangleright\ \mathrm{conj}(c)}
  \qquad 
  \Gamma \vdash \delta_{s,t}^* \ \triangleright\ \delta_{s,t}\\
  &\ \\
  & \Gamma \vdash \ket{v}^* \ \triangleright\ \ket{v}
  \qquad 
  \Gamma \vdash \bra{v}^* \ \triangleright\ \bra{v} \\
  & \Gamma \vdash (e^*)^*\ \triangleright\ e
  \qquad 
  \Gamma \vdash (e^T)^* \ \triangleright\ (e^*)^T\\
  & \Gamma \vdash (e_1 + e_2)^* \ \triangleright\ e_1^* + e_2^* 
  \qquad \Gamma \vdash (e_1 \cdot e_2)^* \ \triangleright\ e_1^* \cdot e_2^* 
  \qquad \Gamma \vdash (e_1 \otimes e_2)^* \ \triangleright\ e_1^* \otimes e_2^*
\end{align*}

\subsubsection*{Transpose}
\begin{align*}
  & \Gamma \vdash \textbf{0}_{\tau, \sigma}^T \ \triangleright\ \textbf{0}_{\sigma, \tau} 
  \qquad \frac{\Gamma \vdash c : \mathbb{C}}{\Gamma \vdash c^T \ \triangleright\ c}
  \qquad \Gamma \vdash \delta_{s,t}^T \ \triangleright\ \delta_{s,t} \\
  & \ \\
  & \Gamma \vdash \ket{v}^T \ \triangleright\ \bra{v} 
  \qquad \Gamma \vdash \bra{v}^T \ \triangleright\ \ket{v} \\
  & \Gamma \vdash (e^T)^T \ \triangleright\ e\\
  & \Gamma \vdash (e_1 + e_2)^T \ \triangleright\ e_1^T + e_2^T 
  \qquad \Gamma \vdash (e_1 \cdot e_2)^T \ \triangleright\ e_2^T \cdot e_1^T 
  \qquad \Gamma \vdash (e_1 \otimes e_2)^T \ \triangleright\ e_1^T \otimes e_2^T
\end{align*}


\subsubsection*{Addition}
\begin{align*}
  &
  \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash e + \textbf{0}_{\tau, \sigma}\to e}\\
  &\ \\
  & 
  \textcolor{red}{
  \frac{\Gamma \vdash c_1 : \mathbb{C} \qquad \Gamma \vdash c_2 : \mathbb{C}}
  {\Gamma \vdash c_1 \otimes e + c_2 \otimes e \ \triangleright\ \mathrm{add}(c_1, c_2) \otimes e}
  \quad 
  \frac{\Gamma \vdash c : \mathbb{C}}{\Gamma \vdash c \otimes e + e \ \triangleright\ \mathrm{add}(c, 1) \otimes e}
  \quad 
  \Gamma \vdash e + e \ \triangleright\ \mathrm{add}(1, 1) \otimes e}
\end{align*}

\subsubsection*{Multiplication}
\begin{align*}
  & \frac{\Gamma \vdash e : \tau \multimap \rho}{\Gamma \vdash \textbf{0}_{\rho, \sigma} \cdot e \ \triangleright\ \textbf{0}_{\tau, \sigma}}
  \qquad 
  \frac{\Gamma \vdash e : \rho \multimap \sigma}{\Gamma \vdash e \cdot \textbf{0}_{\tau, \rho} \ \triangleright\ \textbf{0}_{\tau, \sigma}}\\
  &\ \\
  & \Gamma \vdash \bra{s} \cdot \ket{t} \ \triangleright\ \delta_{s, t}\\ 
  & \Gamma \vdash e_1 \cdot (e_2 + e_3) \ \triangleright\ e_1 \cdot e_2 + e_1 \cdot e_3
  \qquad \Gamma \vdash (e_1 + e_2) \cdot e_3 \ \triangleright\ e_1 \cdot e_3 + e_2 \cdot e_3 \\
  &\ \\
  & \frac{\Gamma \vdash a : [*] \multimap \tau\qquad \Gamma \vdash b : \sigma \multimap [*]}{\Gamma \vdash a \cdot b \ \triangleright\ a \otimes b}\\
  &\ \\
  & \frac{\Gamma \vdash b_2 : \rho \multimap [*]}{\Gamma \vdash a \cdot (b_1 \otimes b_2) \ \triangleright\ (a \cdot b_1) \otimes b_2}
  \qquad
  \frac{\Gamma \vdash b_1 : \rho \multimap [*]}{\Gamma \vdash a \cdot (b_1 \otimes b_2) \ \triangleright\ b_1 \otimes (a \cdot b_2)}\\
  &\ \\
  & \frac{\Gamma \vdash a_2 : [*] \multimap \rho}{\Gamma \vdash (a_1 \otimes a_2) \cdot b \ \triangleright\ (a_1 \cdot b) \otimes a_2}
  \qquad
  \frac{\Gamma \vdash a_1 : [*] \multimap \rho}{\Gamma \vdash (a_1 \otimes a_2) \cdot b \ \triangleright\ a_1 \otimes (a_2 \cdot b)}\\
  &\ \\
  & \frac{\Gamma \vdash a_1 : \rho \multimap \tau \qquad \Gamma \vdash b_1 : \sigma \multimap \rho}{\Gamma \vdash (a_1 \otimes a_2) \cdot (b_1 \otimes b_2) \ \triangleright\ (a_1 \cdot b_1) \otimes (a_2 \cdot b_2)}
\end{align*}

\textbf{Remark: } The last several rules conduct \textbf{tensorization}. They have clear tensor network interpretations. And also, the procedure of tensorization is actually optimizing the contraction order of the tensor network.


\subsubsection*{Tensor}
\begin{align*}
  & \frac{\Gamma \vdash e : \tau \multimap \sigma}{e \otimes \textbf{0}_{\tau', \sigma'} \ \triangleright\ \textbf{0}_{[\tau * \tau'], [\sigma * \sigma']}}
  \qquad 
  \frac{\Gamma \vdash e : \tau \multimap \sigma}{\textbf{0}_{\tau', \sigma'} \otimes e \ \triangleright\ \textbf{0}_{[\tau' * \tau], [\sigma' * \sigma]}}\\
  & \ \\
  & \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash 0 \otimes e \ \triangleright\ \mathbf{0}_{\tau,\sigma}}
  \qquad
  \Gamma \vdash 1 \otimes e \ \triangleright\ e
  \qquad 
  \frac{\Gamma \vdash e_1 : [*] \to [*] \qquad \Gamma \vdash e_2 : [*] \to [*]}{\Gamma \vdash e_1 \otimes e_2 \ \triangleright\ \mathrm{mul}(e_1, e_2)}\\
  & \ \\
  & \Gamma \vdash e_1 \otimes (e_2 + e_3) \ \triangleright\ e_1 \otimes e_2 + e_1 \otimes e_3
  \qquad 
  \Gamma \vdash (e_1 + e_2) \otimes e_3 \ \triangleright\ e_1 \otimes e_3 + e_2 \otimes e_3\\
  & 
  \textcolor{red}{
  \frac{\Gamma \vdash e_1 : \tau_1 \multimap \sigma_1 \qquad \Gamma \vdash e_2 : \tau_2 \multimap \sigma_2 \qquad \tau_1 = [*] \vee \tau_2 = [*]\qquad \sigma_1 = [*] \vee \sigma_2 = [*] \qquad e_1 < e_2}{\Gamma \vdash e_1 \otimes e_2 \ \triangleright\ e_2 \otimes e_1}}
\end{align*}

\textbf{Remark: } Tensor is only commutative when one side of the domain and codomain is $[*]$, because the order of product matters when there is no labelling.





\subsection{Labelled Dirac Notation}


\begin{definition}[labelled Dirac lambda calculus]
  \textbf{Dirac lambda calculus with labels} is an extension of STLC with tuple types, Dirac notations and quantum variable labels. The syntax for types and terms is:
  \begin{align*}
    \tau ::=&\ T\ |\ \tau \to \tau\\
      &\ |\ [ \tau *\tau*\cdots * \tau ]\ |\ \{ \tau * \tau * \cdots * \tau \}\ |\ \< \tau * \tau * \cdots * \tau \> \\
      &\ |\ \tau \multimap \tau\ |\ S \rightsquigarrow S\\
    e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
      &\ |\ [e, e, \dots, e]\ |\ \{ e, e, \dots, e \}\ |\ \<e, e \dots, e \>\ |\ \pi_i\ e \\
      &\ |\ \mathbf{0}_{\tau, \tau}\ |\ \delta_{e, e}\ |\ \ket{e}\ |\ \bra{e}\ |\ e^*\ |\ e^T\ |\ e + e\ |\ e \cdot e\ |\ e \otimes e\ |\ e[e; e] 
  \end{align*}
  Here $S$ is a quantum subsystem, $T \in \{\mathbf{Z}_n, \mathbb{C}\}$ is a basic type, $x$ is a variable and $c$ is a constant. $\tau *\tau*\cdots * \tau$ and $e, e, \dots, e$ are finite sequences.
  In this article, the operators $\to$, $\multimap$, $*$ are right associative, and $+$, $\cdot$, $\otimes$ are left associative. Application $e\ e$ is left associative.
\end{definition}

\textbf{Remark:} Here the strict tuple type $\{ \tau * \tau * \cdots * \tau \}$ is the type for quantum registers, and the term $\{ e, e, \dots, e \}$ is the term for quantum registers. The projection $\pi_i\ e$ is the projection of quantum registers.
In other words, strict tuple brings the fixed structure of Hilbert spaces and quantum registers into the language.


\begin{definition}[quantum register typing rules]
  The typing rules for quantum register include those in Def.\ref{def:Dirac_typing_3} as well as the following ones:
  \begin{gather*}
    \frac{\forall i, \Gamma \vdash e_i : \tau_i}{\Gamma \vdash \{e_1, e_2, \dots, e_n\} : \{\tau_1 * \tau_2 * \cdots \tau_n \} }
    \qquad 
    \frac{\Gamma \vdash e : \{ \tau_1 * \cdots * \tau_n \} \qquad i \leq n}{\Gamma \vdash \pi_i\ e : \tau_i}\\
    \ \\
    \frac{\forall i, \Gamma \vdash r_i : \tau_i \qquad \Gamma \vdash r_i \| r_j\ \mathrm{for all}\ i \neq j}{\Gamma \vdash \<r_1, r_2, \dots, r_n\> : \<\tau_1 * \tau_2 * \cdots \tau_n \> }
    \qquad 
    \frac{\Gamma \vdash r : \< \tau_1 * \cdots * \tau_n \> \qquad i \leq n}{\Gamma \vdash \pi_i\ r : \tau_i}\\
    \ \\
    \frac{\Gamma \vdash e : [\{\tau_1 * \tau_2 * \cdots * \tau_n\}] \multimap [\{\sigma_1 * \sigma_2 * \cdots * \sigma_m\}] \qquad \Gamma \vdash r_1 : \<\tau_1 * \tau_2 * \cdots * \tau_n\> \qquad \Gamma \vdash r_2 : \<\sigma_1 * \sigma_2 * \cdots * \sigma_m\>}{\Gamma \vdash e[r_2 ; r_1] : \mathrm{set}(r_1)\rightsquigarrow \mathrm{set}(r_2)}
  \end{gather*}
  Note that $\Gamma \vdash r_1 \| r_2$ is defined below.
\end{definition}

\textbf{Remark:} Only Dirac notation with strict tuple types $[{\cdots}]$ can be labelled. This will prevent the ambiguity such as $\ket{[0, 1, 0]}[\<a, \<b, c\>\>; \<\>]$. The valid term should be $\ket{[\{0, \{1, 0\}\}]}[\<a, \<b, c\>\>; \<\>]$. Also, the syntax $(e_1 \otimes e_2)[r_1; r_2]$ will be valid only when $e_1$ and $e_2$ are vectors or scalars.

\yx{I believe the requirement of disjointness $r_1 \| r_2$ should be expressed using separation logic.}

\begin{definition}[atomic quantum register]
  We say a quantum register $r$ is atomic in context $\Gamma$ if we can prove
  $\Gamma \vdash r : \<\tau\>$, where $\tau$ is not a quantum register type $\<\dots\>$.
\end{definition}

\begin{definition}[quantum subsystem]
  A quantum subsystem $S$ is a set of quantum registers. 
  We say it's a well-formed quantum subsystem in context $\Gamma$ if all the elements are atomic quantum register in $\Gamma$. 
  For a quantum register $r$, $\mathrm{set}(\Gamma, r)$ represents the corresponding well-typed quantum subsystem in $\Gamma$.
  Two quantum registers are disjoint in $\Gamma$, written as $\Gamma \vdash r_1 \| r_2$, if the corresponding quantum subsystems are disjoint.
\end{definition}
% \textbf{Remark:} The description of quantum subsystem still need refinement.


\begin{definition}[labelled Dirac notation typing rules]
 The extra typing rules for labelled Dirac notation are the following ones.
  \begin{gather*}
    \frac{\Gamma \vdash e_1 : S_b \rightsquigarrow S_k \qquad \Gamma \vdash e_2 : S_b \rightsquigarrow S_k}{\Gamma \vdash e_1 + e_2 : S_b \rightsquigarrow S_k}\\
    \ \\
    \frac{\Gamma \vdash e_1 : S_b \rightsquigarrow S_k \qquad \Gamma \vdash e_2 : S_b' \rightsquigarrow S_k'
    \qquad S_k \cap (S_k' - S_b) = \emptyset
    \qquad (S_b - S_k') \cap S_b' = \emptyset}
    {\Gamma \vdash e_1 * e_2 : (S_b - S_k') \cup S_b' \rightsquigarrow S_k \cup (S_k' - S_b)}\\
    \ \\
    \frac{\Gamma \vdash e_1 : S_b \rightsquigarrow S_k \qquad \Gamma \vdash e_2 : S_b' \rightsquigarrow S_k'
    \qquad S_k \cap S_k' = \emptyset
    \qquad S_b \cap S_b' = \emptyset}
    {\Gamma \vdash e_1 \otimes e_2 : S_b \cup S_b' \rightsquigarrow S_k \cup S_k'}\\
    \ \\
    \frac{\Gamma \vdash e : S_b \rightsquigarrow S_k}{\Gamma \vdash e^* : S_b \rightsquigarrow S_k}
    \qquad
    \frac{\Gamma \vdash e : S_b \rightsquigarrow S_k}{\Gamma \vdash e^T : S_k \rightsquigarrow S_b}
  \end{gather*}
\end{definition}

\subsection{Equational Theory}
The extra equational theory for labelled Dirac notations include the following ones:

\subsubsection*{AC functions}
Associative commutative functions include: $+$, $\otimes$.

\subsection{Labelled Dirac notation reduction (Draft)}

  The reduction rules for labelled Dirac notation include those in Sec.\ref{subsec:Dirac reduction_3} as well as the following ones.

\subsubsection*{Strict Tuple}

\begin{align*}
  & \frac{\Gamma \vdash \{e_1, \dots, e_n \} : \{ \tau_1 * \cdots \tau_n\}\qquad i \leq n}{\Gamma \vdash \pi_i\ \{e_1, \dots, e_n \}\ \triangleright_\pi\ e_i}
  \qquad
  \frac{\Gamma \vdash u : \{ \tau_1 * \cdots * \tau_n\}}{\Gamma \vdash \{\pi_1\ u, \dots, \pi_n\ u \}\ \triangleright_\pi\ u}
  \qquad
  \frac{\Gamma \vdash t : \{*\}}{\Gamma \vdash t\ \triangleright_\pi\ \{\}}\\
  &\ \\
  & \frac{\Gamma \vdash \<r_1, \dots, r_n \> : \< \tau_1 * \cdots \tau_n\> \qquad i \leq n}{\Gamma \vdash \pi_i\ \<r_1, \dots, r_n \>\ \triangleright_\pi\ e_i}
  \qquad
  \frac{\Gamma \vdash r : \< \tau_1 * \cdots * \tau_n\>}{\Gamma \vdash \<\pi_1\ r, \dots, \pi_n\ r \>\ \triangleright_\pi\ r}
  \qquad
  \frac{\Gamma \vdash r : \<*\>}{\Gamma \vdash r\ \triangleright_\pi\ \<\>}
\end{align*}

\subsubsection*{Decomposition}

\begin{align*}
  & \Gamma \vdash \ket{[t]}[\<\> ; r]\ \triangleright\ \ket{[\{\pi_1\ t\}]}[\<\> ; \<\pi_1\ r\>] \otimes \ket{[\{\pi_2\ t\}]}[\<\> ; \<\pi_2\ r\>] \otimes \cdots \otimes \ket{[\{\pi_n\ t\}]}[\<\> ; \<\pi_n\ r\>]\\
  & \Gamma \vdash \bra{[t]}[\<\> ; r]\ \triangleright\ \bra{[\{\pi_1\ t\}]}[\<\> ; \<\pi_1\ r\>] \otimes \bra{[\{\pi_2\ t\}]}[\<\> ; \<\pi_2\ r\>] \otimes \cdots \otimes \bra{[\{\pi_n\ t\}]}[\<\> ; \<\pi_n\ r\>]\\
  &\ \\
  &\frac{\Gamma \vdash e_1 : [*] \multimap \tau}{\Gamma \vdash (e_1 \otimes e_2)[r_1; r_2]\ \triangleright\ e_1[r_1; \<\>] \otimes e_2[\<\>; r_2]}
\end{align*}

\subsection*{Factorization}

\begin{align*}
  & \Gamma \vdash e_1[r_1; r_2] + e_2[r_1; r_2] \ \triangleright\ (e_1 + e_2)[r_1; r_2] \\
  & \Gamma \vdash e_1[r_1; r_2] \cdot e_2[r_2; r_3] \ \triangleright\ (e_1 \cdot e_2)[r_1; r_3] \\
  & \Gamma \vdash e + e \ \triangleright\ (1 + 1)[\<\>; \<\>] \cdot e \\
  & \Gamma \vdash e + a \otimes e \ \triangleright\ (1[\<\>; \<\>] + a) \cdot e \\
  & \Gamma \vdash b \otimes e + a \otimes e \ \triangleright\ (a + b) \cdot e
\end{align*}

\subsection*{Tensorization}
\begin{align*}
  & \frac{\Gamma \vdash e_1 : S_b \rightsquigarrow S_k \qquad \Gamma \vdash e_2 : S_b' \rightsquigarrow S_k' \qquad S_b \cap S_k' = \emptyset }{\Gamma \vdash e_1 \cdot e_2 \ \triangleright\ e_1 \otimes e_2}\\
  &\ \\
  & \frac{\Gamma \vdash e_1 : S_b \rightsquigarrow S_k \qquad \Gamma \vdash e_3 : S_b' \rightsquigarrow S_k' \qquad S_b \cap S_k' = \emptyset }{\Gamma \vdash e_1 \cdot (e_2 \otimes e_3) \ \triangleright\ (e_1 \cdot e_2) \otimes e_3}\\
  &\ \\
  & \frac{\Gamma \vdash e_1 : S_b \rightsquigarrow S_k \qquad \Gamma \vdash e_4 : S_b' \rightsquigarrow S_k' \qquad S_b \cap S_k' = \emptyset }{\Gamma \vdash (e_1 \otimes e_2) \cdot (e_3 \otimes e_4) \ \triangleright\ (e_1 \cdot e_2) \otimes (e_3 \cdot e_4)}
\end{align*}

\yx{Important : we need to convert $\{a\}, [a], \<a\>$ to a (?), and $\{*\}$, $[*]$, $\<*\>$ to \texttt{unit}.}

\subsubsection*{Distributive Law}
\begin{align*}
  & \Gamma \vdash e_1 \cdot (e_2 + e_3) \ \triangleright\ e_1 \cdot e_2 + e_1 \cdot e_3 \\
  & \Gamma \vdash e_1 \otimes (e_2 + e_3) \ \triangleright\ e_1 \otimes e_2 + e_1 \otimes e_3
\end{align*}

\section{Termination and Confluence}

About termination: the untyped lambda calculus is not terminating. But here the simple type system prevents divergence.

About confluence: we can try to combine the confluence of simply typed lambda calculus and Dirac notation, because they are disjoint. So maybe I should move the flexible tuple part to Dirac notation?




\section{Dirac with Big-operator}
We extend the language of (labelled) Dirac notation with the sort $\mathcal{S}_\tau$ for sets of type $\tau$, and the following syntax for terms:
$$
t ::= \sum_{x \in S} t
$$

Here $\sum_{x : \tau} t$ can be considered as a special abstraction, where $x$ is the bound variable for index with type $S$.

\begin{definition}[typing rule]
  The typing rule for the big operator is similar to the one for abstraction.

  $$
  \frac{\Gamma \vdash S : \mathcal{S}_\tau\qquad \Gamma::(x : \tau) \vdash e : \sigma}{\Gamma \vdash \sum_{x \in S} e : \sigma}
  $$
  
\end{definition}

\begin{definition}[The system Sum]
    \begin{align*}
        & \Gamma \vdash \sum_{x \in S} \mathbf{0}_{\sigma, \rho} \ \triangleright\ \mathbf{0}_{\sigma, \rho} \\
        & \Gamma \vdash e \otimes \sum_{x \in S} u \ \triangleright\ \sum_{x \in S} e \otimes u \\
        &\Gamma \vdash e\cdot \sum_{x \in S} v \ \triangleright \sum_{x \in S} (e\cdot v)
        \qquad 
        \Gamma \vdash (\sum_{x \in S} v) \cdot e\ \triangleright \sum_{x \in S} (v \cdot e)\\        
        & \Gamma \vdash \sum_{x \in S} u + \sum_{x \in S} v  \ \triangleright\ \sum_{x \in S} (u + v) \\
        \tag{**}
        & \sum_{x \in S} \sum_{y \in S'} u = \sum_{y \in S'} \sum_{x \in S} u
    \end{align*}
(**)\ Requires that $\sigma$ is not dependent on $x$, which is always the case in the simply typed situation.

And sum is not considered as a base vector.
\end{definition}

\yx{A serious problem: How to deal with the summation over a set of index? And how can we decide
$$
\sum_{i \in \mathbb{B}} \ket{i} = \ket{0} + \ket{1}
$$}

\yx{Maybe we can consider the set to be expressed in the form of the enumeration by a list or array.
$$
\Gamma \vdash \sum_{i \in \{i_0, \dots, i_n\}} e \ \triangleright\ e[i_0/i] + \cdots + e[i_n/i]
$$
}









\section{Untyped Dirac Lambda Calculus}
Is it a good idea to consider untyped Dirac lambda calculus? I think it's not a good idea, because the untyped lambda calculus is not terminating.

\begin{definition}

    The language of is a described by the following term grammar:

    \begin{align*}
        t ::=\ & \ x\ |\ \lambda x.t\ |\ t\ t\ |\ c \\
              & |\ \ket{t}\ |\ \delta_{t, t} \ |\ \mathbf{0}\ |\ t + t\ |\ t \cdot t\ |\ t \otimes t\ |\ t^*\ |\ t^T\\
              & |\ t_{r, r}
    \end{align*}

\end{definition}

\textbf{Remark:} Intuitively, $\ket{t}$ is a constructor from classical information to quantum basis. The elimination rule for it is tensor dot, which reduce the quantum state to complex number and retrieve the classical information.


\subsection{Equational Theory}

\subsubsection*{$\alpha$-conversion}
$$
    \lambda x.t = \lambda y.t[y/x]\qquad \text{($y$ is not free in $t$)}
$$

\subsubsection*{Delta Operator}
$$
    \delta_{t, s} = \delta_{s, t}
$$

\subsubsection*{AC functions}

Associative functions include: $\cdot$, $\otimes$ for Dirac notations. 

Associative commutative functions include: $+$, $\otimes$ for labelled Dirac notations.

\begin{align*}
    A + B = & B + A \\
    A + (B + C) = & A + B + C \\
    A \cdot (B \cdot C) = & A \cdot B \cdot C \\
    A \otimes (B \otimes C) = & A \otimes B \otimes C \\
    A_{r_1, r_2} \otimes B_{r_1', r_2'} = & B_{r_1', r_2'} \otimes A_{r_1, r_2}
\end{align*}


\subsection{Reduction Rules (Dirac Notation)}

\subsubsection*{Beta Reduction}
\begin{align*}
    & (\lambda x.t) s \to t[s/x]
\end{align*}


\subsubsection*{Delta Operator}
\begin{align*}
  & \delta_{t, t} \to 1
  \qquad
  \frac{s =? t\ \textrm{has no unifier}}{\delta_{s, t} \to \mathbf{0}}
\end{align*}

\subsubsection*{Conjugate}
\begin{align*}
  & \textbf{0}^* \to \textbf{0}
  \qquad 
  c^* \to \mathrm{conj}(c)
  \qquad 
  \delta_{s,t}^* \to \delta_{s,t}\\
  & \ket{v}^* \to \ket{v} \\
  & (e^*)^* \to e
  \qquad 
  (e^T)^* \to (e^*)^T\\
  & (e_1 + e_2)^* \to e_1^* + e_2^* 
  \qquad (e_1 \cdot e_2)^* \to e_1^* \cdot e_2^* 
  \qquad (e_1 \otimes e_2)^* \to e_1^* \otimes e_2^*
\end{align*}

\subsubsection*{Transpose}
\begin{align*}
  & \textbf{0}^T \to \textbf{0}
  \qquad
  c^T \to c
  \qquad 
  \delta_{s,t}^T \to \delta_{s,t} \\
  & \ket{v}^T \to \ket{v} \\
  & (e^T)^T \to e\\
  & (e_1 + e_2)^T \to e_1^T + e_2^T
  \qquad (e_1 \cdot e_2)^T \to e_2^T \cdot e_1^T 
  \qquad (e_1 \otimes e_2)^T \to e_1^T \otimes e_2^T
\end{align*}


\subsubsection*{Addition}
\begin{align*}
  & e + \textbf{0}\to e\\
  & \textcolor{red}{c_1 \otimes e + c_2 \otimes e \to \ (c_1 + c_2) \otimes e 
  \qquad c \otimes e + e \to (c + 1) \otimes e
  \qquad e + e \to (1 + 1) \otimes e}
\end{align*}

\textbf{Remark:} Note that in the factorization rules, $(c_1 + c_2)$, $(c + 1)$ and $(1 + 1)$ are complex number additions.


\subsubsection*{Multiplication}
\begin{align*}
  & \textbf{0} \cdot e \to \textbf{0}
  \qquad 
  e \cdot \textbf{0} \to \textbf{0}\\
  & \ket{s}^T \cdot \ket{t} \to \delta_{s, t}\\
  & c \cdot e \to c \otimes e 
  \qquad \delta_{s, t} \cdot e \to \delta_{s, t} \otimes e\\
  & (c \otimes e_1) \cdot e_2 \to c \otimes (e_1 \cdot e_2)
  \qquad e_1 \cdot (c \otimes e_2) \to c \otimes (e_1 \cdot e_2) \\
  & (\delta_{s, t} \otimes e_1) \cdot e_2 \to \delta_{s, t} \otimes (e_1 \cdot e_2)
  \qquad e_1 \cdot (\delta_{s, t} \otimes e_2) \to \delta_{s, t} \otimes (e_1 \cdot e_2) \\
  & e_1 \cdot (e_2 + e_3) \to e_1 \cdot e_2 + e_1 \cdot e_3
  \qquad (e_1 + e_2) \cdot e_3 \to e_1 \cdot e_3 + e_2 \cdot e_3
\end{align*}

\textbf{Remark: } The last two rules conduct \textbf{tensorization}.


\subsubsection*{Tensor}
\begin{align*}
  & e \otimes \textbf{0} \to \textbf{0}
  \qquad \textbf{0} \otimes e \to \textbf{0} \\
  & e \otimes c \to c \otimes e
  \qquad e \otimes \delta_{s, t} \to \delta_{s, t} \otimes e \\
  & c_1 \otimes c_2 \to c_1 * c_2\ \mathrm{(complex multiplication)}\\
  & 1 \otimes e \to e \qquad 0 \otimes e \to \mathbf{0} \\
  & e_1 \otimes (e_2 + e_3) \to e_1 \otimes e_2 + e_1 \otimes e_3
  \qquad 
  (e_1 + e_2) \otimes e_3 \to e_1 \otimes e_3 + e_2 \otimes e_3
\end{align*}

\textbf{Remark: } Tensor is only commutative when one side of the domain and codomain is $[*]$, because the order of product matters when there is no labelling.



