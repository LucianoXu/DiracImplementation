  
% \input{yingte/20231117.tex}

First of all, I present here a simplest concrete example of the whole theory for labelled Dirac notations called \textbf{Dirac0}. It shows the main framework which works for more complicated cases we will consider later.

\section{Dirac0}

I believe that the decision procedure for linear algebra is necessary, but I didn't notice any serious work on this topic. It should be because decision procedure is considered and required in formal verification, but not was linear algebra until now we have quantum programs. 

The theory of linear algebra required here is special: it has rich types of linear spaces and tensor product. Later it will include big operators and some typed lambda calculus. We call such extensions \textbf{Dirac notations}. Afterwards, these Dirac notations are indexed by quantum registers to form \textbf{labelled Dirac notations}.

\subsection{Dirac Notation}

\begin{definition}[atomic type and term]
  The atomic types $A$ and terms $a$ are defined as
  \begin{align*}
    A & ::= \mathbf{Z}_n \\
    a & ::= i
  \end{align*}
  Here $n$ and $i$ are natural numbers. The well-typed terms are defined by:
  $$
  \frac{i < n}{\Vdash i : \mathbf{Z}_n}.
  $$
\end{definition}
\textbf{Remark:} We define atomic types separatedly because they describe the types of atomic quantum subsystems.

\begin{definition}[space Type] 
  $$
  T ::= \texttt{Unit}\ |\ A\ |\ T * T
  $$
  Here $A$ is an atomic type and $\texttt{Unit}$ is a terminal symbol.
\end{definition}

\begin{definition}[basis Term]
  $$
  t ::= ()\ |\ a\ |\ (t, t)
  $$
  Here $a$ is an atomic term.
\end{definition}

\yx{For variables, I plan to incorporate a STLC with product, projection and unit, which is already well studied. see \url{https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus}.}

\begin{definition}[well-typed basis]
  For space type $T$ and basis term $t$, the well-typed relation $\vdash t : T$ is defined by
  
  \begin{align*}
    \frac{}{\vdash () : \texttt{Unit}}
    \qquad
    \frac{\Vdash a : A}{\vdash a : A}
    \qquad
    \frac{\vdash t_1 : T_1 \qquad \vdash t_2 : T_2}{\vdash (t_1, t_2) : T_1 * T_2}
  \end{align*}
\end{definition}

\begin{postulate}[complex number]
  $\mathbb{C}$ is an algebra for complex numbers. It has the symbols $(0, 1, +, *, \textrm{conj})$.
\end{postulate}
It means that somehow we can express and decide complex number terms, but the theory should not be considered here.

\begin{definition}[Dirac notation]
  Dirac notation is a rephrase and extension of linear algebra.
  \begin{align*}
    e ::= \mathbf{0}_{T_k, T_b}\ |\ \mathbf{1}\ |\ \delta_{s, t}\ |\ \ket{t}\ |\ \bra{t}\ |\ e^*\ |\ e^T\ |\ c * e\ |\ e + e\ |\ e \cdot e\ |\ e \otimes e
  \end{align*}
  Here $T_k$ and $T_b$ are space Types, $s, t$ are basis terms and $c$ is a complex number term.
\end{definition}

\begin{definition}[notation typing]
  A typing of Dirac notation $e$ is written as $e : (T_k, T_b)$, where $T_k$ and $T_b$ are space types.
\end{definition}

\begin{definition}[well-typed Dirac notation] 
  For the typing of Dirac notation $e : (T_k, T_b)$, the well-typed proof is defined by
  \begin{gather*}
    \frac{}{\vdash \mathbf{0}_{T_k, T_b} : (T_k, T_b)}
    \qquad
    \frac{}{\vdash \mathbf{1} : (\texttt{Unit}, \texttt{Unit})}
    \qquad
    \frac{\vdash s : T \qquad \vdash t : T}{\vdash \delta_{s, t} : (\texttt{Unit}, \texttt{Unit})}\\
    \ \\
    \frac{\vdash t : T}{\vdash \ket{t} : (T, \texttt{Unit})}
    \qquad 
    \frac{\vdash t : T}{\vdash \bra{t} : (\texttt{Unit}, T)}\\
    \ \\
    \frac{\vdash e : (T_k, T_b)}{\vdash e^* : (T_k, T_b)}
    \qquad
    \frac{\vdash e : (T_k, T_b)}{\vdash e^T : (T_b, T_k)}
    \qquad
    \frac{\vdash e : (T_k, T_b)}{\vdash c * e : (T_k, T_b)}\\
    \ \\
    \frac{\vdash e_1 : (T_k, T_b)\qquad \vdash e_2 : (T_k, T_b)}{\vdash e_1 + e_2 : (T_k, T_b)}
    \qquad 
    \frac{\vdash e_1 : (T_k, R)\qquad \vdash e_2 : (R, T_b)}{\vdash e_1 \cdot e_2 : (T_k, T_b)}
    \qquad
    \frac{\vdash e_1 : (T_k, T_b)\qquad \vdash e_2 : (T_k', T_b')}{\vdash e_1 \otimes e_2 : (T_k * T_k', T_b * T_b')}
  \end{gather*}
\end{definition}


\begin{claim}
  For any Dirac notation $e$, there exists at most one pair $(T_k, T_b)$ which satisfies $\vdash e : (T_k, T_b)$. The types of all Dirac notations are computable (if exist).
\end{claim}


\subsection{TRS for Dirac notations}
The reduction rules for Dirac notation are presented below.


\subsubsection*{Delta Operator}
\begin{align*}
  \frac{\vdash s = t}{\delta_{s, t} \to \mathbf{1}}
\end{align*}
\textbf{Remark: } The delta operator seems to be redundant in the simplest situation. It will be necessary when big operators are introduced.


% \subsubsection*{Decomposition}
% \begin{align*}
%   & \vdash \ket{(t_1, t_2)} \to \ket{t_1} \otimes \ket{(t_1, t_2)} \qquad \vdash \bra{(t_1, t_2)}\to \bra{t_1} \otimes \bra{t_2}
% \end{align*}

\subsubsection*{Conjugate}
\begin{align*}
  & \vdash \textbf{0}_{T_k, T_b}^* \to \textbf{0}_{T_k, T_b} 
  \qquad \vdash \mathbf{1}^* \to \mathbf{1}
  \qquad \vdash \delta_{i,j}^* \to \delta_{i,j}\\
  & \vdash \ket{v}^* \to \ket{v} 
  \qquad \vdash \bra{v}^* \to \bra{v} \\
  & \vdash (e^*)^*\to e
  \qquad \vdash (e^T)^* \to (e^*)^T
  \qquad \textcolor{blue}{\vdash (c * e)^* \to \textrm{conj}(c) * (e^*)}\\
  & \vdash (e_1 + e_2)^* \to e_1^* + e_2^* \qquad \vdash (e_1 \cdot e_2)^* \to e_2^* \cdot e_1^* \qquad \vdash (e_1 \otimes e_2)^* \to e_1^* \otimes e_2^*
\end{align*}

\subsection*{Transpose}
\begin{align*}
  & \vdash \textbf{0}_{T_k, T_b}^T \to \textbf{0}_{T_b, T_k} 
  \qquad \vdash \mathbf{1}^T \to \mathbf{1}
  \qquad \vdash \delta_{i,j}^T \to \delta_{i,j} \\
  & \vdash \ket{v}^T \to \bra{v} 
  \qquad \vdash \bra{v}^T \to \ket{v} \\
  & \vdash (c * e)^T \to c * (e^T)
  \qquad \vdash (e^T)^T \to e\\
  & \vdash (e_1 + e_2)^T \to e_1^T + e_2^T \qquad \vdash (e_1 \cdot e_2)^T \to e_2^T \cdot e_1^T \qquad \vdash (e_1 \otimes e_2)^T \to e_1^T \otimes e_2^T
\end{align*}

\subsection*{Scalar Multiplication}
\begin{align*}
  & \frac{\mathbb{C} \vdash c = 0 \qquad \vdash e : (T_k, T_b)}{c * e \to \textbf{0}_{T_k, T_b}}\\
  &\ \\
  & \vdash c * \mathbf{0}_{T_k, T_b} \to \mathbf{0}_{T_k, T_b} \\
  & \textcolor{blue}{\vdash c_1 * (c_2 * e) \to (c_1 * c_2) * e} \\
  & \textcolor{red}{\vdash c * e_1 + c * e_2 \to c * (e_1 + e_2)}
\end{align*}

\textbf{Remark:} The last rule uses distributive law reversely. This is due to the requirement of LPO. Rewriting in this direction also makes the normal form more concise.

\subsubsection*{Addition}
\begin{align*}
  & \frac{\vdash e : (T_k, T_b)}{\textbf{0}_{T_k, T_b} + e \to e}
  \qquad \frac{\vdash e : (T_k, T_b)}{e + \textbf{0}_{T_k, T_b}\to e}\\
  &\ \\
  & \vdash c_1 * e + c_2 * e \to (c_1 + c_2) * e \\
  & \vdash c * e + e \to (c + 1) * e \\
  & \vdash e + e \to 2 * e \\
  & \vdash e_1 + (e_2 + e_3) \to e_1 + e_2 + e_3 \\
  & e_1 < e_2 \vdash e_1 + e_2 \to e_2 + e_1
\end{align*}

\subsubsection*{Multiplication}
\begin{align*}
  & \frac{\vdash e : (R, T_b)}{\textbf{0}_{T_k, R} \cdot e \to \textbf{0}_{T_k, T_b}}
  \qquad \frac{\vdash e : (T_k, R)}{e \cdot \textbf{0}_{R, T_b}\to \textbf{0}_{T_k, T_b}}\\
  &\ \\
  & \vdash \mathbf{1} \cdot e \to e
  \qquad
  \vdash e \cdot \mathbf{1} \to e \\
  & \vdash \bra{i} \cdot \ket{j} \to \delta_{ij}\\
  & \vdash (c * e_1) \cdot e_2 \to c * (e_1 \cdot e_2)
  \qquad \vdash e_1 \cdot (c * e_2) \to c * (e_1 \cdot e_2) \\ 
  & \vdash e_1 \cdot (e_2 + e_3) \to e_1 \cdot e_2 + e_1 \cdot e_3
  \qquad \vdash (e_1 + e_2) \cdot e_3 \to e_1 \cdot e_3 + e_2 \cdot e_3 \\
  & \vdash e_1 \cdot (e_2 \cdot e_3) \to e_1 \cdot e_2 \cdot e_3
\end{align*}

\subsubsection*{Tensor}
\begin{align*}
  & \frac{\vdash e : (T_k', T_b')}{\textbf{0}_{T_k, T_b} \otimes e \to \textbf{0}_{T_k * T_k', T_b * T_b'}}
  \qquad \frac{\vdash e : (T_k, T_b)}{e \otimes \textbf{0}_{T_k', T_b'} \to \textbf{0}_{T_k * T_k', T_b * T_b'}}\\
  &\ \\
  & \vdash \mathbf{1} \otimes e \to e
  \qquad
  \vdash e \otimes \mathbf{1} \to e\\
  & \vdash (c * e_1) \otimes e_2 \to c * (e_1 \otimes e_2)\\
  & \vdash e_1 \otimes (e_2 + e_3) \to e_1 \otimes e_2 + e_1 \otimes e_3
  \qquad \vdash (e_1 + e_2) \otimes e_3 \to e_1 \otimes e_3 + e_2 \otimes e_3\\
  & \vdash e_1 \otimes (e_2 \otimes e_3) \to e_1 \otimes e_2 \otimes e_3
\end{align*}

\textbf{Remark: } Tensor is not commutative because the order severes as the labelling.
  
  
The convergent proof of the reduction system is dependent on the order. Moreover, the efficiency of the reduction algorithm is also partially limited by the order. Therefore to optimize the algorithm, more effort is need to improve the reduction order and simplify the decending path.

\subsection{Congruence of TRS for Dirac notations}

\begin{definition}[LPO]
  Let $\Sigma$ be a finite signature and $>$ be a strict order on $\Sigma$. The \textbf{lexicographic path order}  $>_{lpo}$ on $T(\Sigma, V)$ induced by $>$ is defined as follows: $s >_{lpo} t$ iff
  \begin{itemize}
    \item \textbf{(LPO1)} $t \in \mathrm{Var}(s)$ and $s \neq t$, or
    \item \textbf{(LPO2)} $s = f(s_1, \dots, s_m)$, $t = g(t_1, \dots, t_n)$, and
    \item \begin{itemize}
      \item \textbf{(LPO2a)} there exists $i, 1\leq i \leq m$, with $s_i \geq_{lpo} t$, or
      \item \textbf{(LPO2b)} $f > g$ and $s >_{lpo} t_j$ for all $j, 1\leq j \leq n$, or
      \item \textbf{(LPO2c)} $f = g$, $s >_{lpo} t_j$ for all $j, 1\leq j \leq n$, and there exists $i, 1 \leq i \leq m$, such that $s_{i+1} = t_{i+1}, \dots, s_m = t_m$ and $s_i >_{lpo} t_i$.
    \end{itemize}
  \end{itemize}
  
\end{definition}

The rule \textbf{(LPO1)} and \textbf{(LPO2a)} guarantees that the induced LPO is a simplification order and thus a reduction order. The rule \textbf{(LPO2c)} compares the subterms from right to left, and that's why it's called lexicographic.

\begin{lemma}[Termination of TRS for Dirac notations]
  The termination of the TRS for Dirac notations can be proved by the LPO induced by the following strict order:

  \begin{center}
  \begin{tikzpicture}[node distance=15pt]
    \node[draw]                     (complex) {all complex function};
    \node[draw, right=of complex]                        (zero)   {$\mathbf{0}$};
    \node[draw, right=of zero]         (scalar)  {$*$};
    \node[draw, right=of scalar]        (add)  {$+$};
    \node[draw, right=of add]     (tensor)  {$\otimes$};
    \node[draw, below=of zero]     (one)     {$\mathbf{1}$};
    \node[draw, right=of one]     (delta)     {$\delta_{ij}$};
    \node[draw, right=of delta]       (mul)  {$\cdot$};
    \node[draw, right=of mul]     (trans)     {transpose};
    \node[draw, right=of trans]     (conj)     {conjugate};

    \node[draw, above=of add]       (ket) {$\ket{t}$};
    \node[draw, above=of ket]       (bra) {$\bra{t}$};
    
    \draw[->] (conj)  -- (trans);
    \draw[->] (trans) -- (tensor);
    \draw[->] (trans) -- (mul);
    \draw[->] (add) -- (scalar);
    \draw[->] (tensor) -- (add);
    \draw[->] (mul) -- (delta);
    \draw[->] (mul) -- (scalar);
    \draw[->] (scalar) -- (zero);
    \draw[->] (delta) -- (one);

    \draw[->] (one) -- (zero);
    \draw[->] (ket) -- (zero);
    \draw[->] (bra) -- (zero);
    \draw[->] (zero) -- (complex);
  \end{tikzpicture}
  \end{center}
\end{lemma}

\begin{proof}
  Most cases are direct by definition. It's worth noting that for associative symbols $\cdot$, $\otimes$ and $+$, the simpler form is left-most associative, which is consistent with the LPO definition, because the right most subterms are compared first in \textbf{(LPO2c)}. Besides, $+$ is commutative, and the side condition of the subterm order helps avoid the infinite loop of rewriting.

  We also ignore the complexity of complex scalars.
\end{proof}




\subsection{Labelled Dirac Notation}

\begin{definition}[quantum register]
  $$
  r ::= E\ |\ x\ |\ (r, r)
  $$
  Here $E$ is the terminal symbol for empty register and $x$ is a quantum variable.
\end{definition}

\begin{definition}[quantum variable typing]
  The typing for quantum variable $x$ is written as $x : T$, where $T$ is a space type.
\end{definition}

\begin{definition}[quantum context]
  The quantum contexts are ordered list of quantum variable typings, written as $\Gamma = [x : T; y : U; \dots]$. The empty context is denoted by $[]$.
\end{definition}

\begin{definition}[well-formed context]
  A well-formed context $\Gamma$, written as $\mathcal{WF}(\Gamma)$, is a context where variables appear uniquely. In other words, they are defined as:
  $$
  \frac{}{\mathcal{WF}([])}
  \qquad
  \frac{\mathcal{WF}(\Gamma)\qquad x \notin \Gamma}{\mathcal{WF}(\Gamma :: (x : T))}
  $$
\end{definition}


\begin{definition}[well-typed quantum register]
  Within a well-formed context $\mathcal{WF}(\Gamma)$, the well-typed quantum register is denoted as $\mathcal{WF}(\Gamma) \vdash r : T$, where $r$ denotes a quantum register and $T$ a space type. The well-typed quantum register is defined as follows.
  \begin{gather*}
  \frac{\mathcal{WF}(\Gamma)}{\mathcal{WF}(\Gamma) \vdash E : \texttt{Unit}}
  \qquad
  \frac{\mathcal{WF}(\Gamma)\qquad x:T \in \Gamma}{\mathcal{WF}(\Gamma) \vdash x : T}\\
  \ \\  
  \frac{\mathcal{WF}(\Gamma) \vdash r_1 : T_1 \qquad \mathcal{WF}(\Gamma) \vdash r_2 : T_2\qquad \mathcal{WF}(\Gamma) \vdash r_1 \| r_2}{\mathcal{WF}(\Gamma) \vdash (r_1, r_2) : (T_1 * T_2) }
  \end{gather*}
  Note that $\mathcal{WF}(\Gamma) \vdash r_1 \| r_2$ is defined below.
\end{definition}


\begin{definition}[atomic quantum register]
  We say a quantum register $r$ is atomic in context $\Gamma$ if we can prove
  $\mathcal{WF}(\Gamma) \vdash r : A$, where $A$ is a atomic type.
\end{definition}

\begin{definition}[quantum subsystem]
  A quantum subsystem $S$ is a set of quantum registers. 
  We say it's a well-formed quantum subsystem in context $\Gamma$ if all the elements are atomic quantum register in $\Gamma$. 
  For a quantum register $r$, $\mathrm{set}(\Gamma, r)$ represents the corresponding well-typed quantum subsystem in $\Gamma$.
  Two quantum registers are disjoint in $\Gamma$, written as $\mathcal{WF}(\Gamma) \vdash r_1 \| r_2$, if the corresponding quantum subsystems are disjoint.
\end{definition}
\textbf{Remark:} The description of quantum subsystem still need refinement.

\begin{definition}[labelled Dirac notation]
    Labelled Dirac notation is defined by:
    $$
    e ::= e_d [r_k; r_b]\ |\ e + e\ |\ e * e\ |\ e \otimes e\ |\ e^*\ |\ e^T.
    $$
    Here $e_d$ is a Dirac notation and $r_k, r_b$ are quantum registers.
\end{definition}

\begin{definition}[labelled notation typing]
  A typing of labelled Dirac notation $e$ in well-formed context $\Gamma$ is written as $\mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)$, where $S_k$ and $S_b$ are quantum subsystems. 
\end{definition}

\begin{definition}[well-typed labelled Dirac notation]
  For the typing of labelled Dirac notation $\mathcal{WF}(\Gamma) \vdash e : (T_k, T_b)$, the well-typed proof is defined by
  \begin{gather*}
    \frac{\vdash e_d : (T_k, T_b) \qquad \mathcal{WF}(\Gamma) \vdash r_k : T_k \qquad \mathcal{WF}(\Gamma) \vdash r_b : T_b}{\mathcal{WF}(\Gamma) \vdash e_d[r_k; r_b] : (\mathrm{set}(\Gamma, r_k), \mathrm{set}(\Gamma, r_b))}\\
    \ \\
    \frac{\mathcal{WF}(\Gamma) \vdash e_1 : (S_k, S_b) \qquad \mathcal{WF}(\Gamma) \vdash e_2 : (S_k, S_b)}{\mathcal{WF}(\Gamma) \vdash e_1 + e_2 : (S_k, S_b)}\\
    \ \\
    \frac{\mathcal{WF}(\Gamma) \vdash e_1 : (S_k, S_b) \qquad \mathcal{WF}(\Gamma) \vdash e_2 : (S_k', S_b')
    \qquad S_k \cap (S_k' - S_b) = \emptyset
    \qquad (S_b - S_k') \cap S_b' = \emptyset}
    {\mathcal{WF}(\Gamma) \vdash e_1 * e_2 : (S_k \cup (S_k' - S_b), (S_b - S_k') \cup S_b')}\\
    \ \\
    \frac{\mathcal{WF}(\Gamma) \vdash e_1 : (S_k, S_b) \qquad \mathcal{WF}(\Gamma) \vdash e_2 : (S_k', S_b')
    \qquad S_k \cap S_k' = \emptyset
    \qquad S_b \cap S_b' = \emptyset}
    {\mathcal{WF}(\Gamma) \vdash e_1 \otimes e_2 : (S_k \cup S_k', S_b \cup S_b')}\\
    \ \\
    \frac{\mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)}{\mathcal{WF}(\Gamma) \vdash e^* : (S_k, S_b)}
    \qquad
    \frac{\mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)}{\mathcal{WF}(\Gamma) \vdash e^T : (S_b, S_k)}
  \end{gather*}
\end{definition}

\begin{definition}[labelled Dirac notation reduction]
  We consider the reduction on typings of labelled Dirac notations. The rules are defined by:
  \begin{gather*}
    \mathcal{WF}(\Gamma) \vdash ((e_d + e_d')[r_k; r_b]: (S_k, S_b)) \to (e_d[r_k; r_b] + e_d'[r_k; r_b] : (S_k, S_b))\\
    \cdots
  \end{gather*}
\end{definition}

\begin{claim}[well-typing preservation]
  Reduction on labelled notation typings preserve the well-typed proof. That is,
  $$
  \forall e \forall \Gamma, \mathcal{WF}(\Gamma) \vdash (e : (S_k, S_b)) \to (e' : (S_k, S_b)),
  $$
  and
  $$
  \mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)\ \textrm{and}\ \mathcal{WF}(\Gamma) \vdash (e : (S_k, S_b)) \to (e' : (S_k, S_b))\ \textrm{imples}\ \mathcal{WF}(\Gamma) \vdash e' : (S_k, S_b).
  $$
\end{claim}


\section{Modularising Dirac Notation by Category}
In consideration of the complicated depnedency of different parts of the Dirac notation theory, expressing it in a modularised manner makes it more clear, organized and easy to extend. In Coq, the implementations follow this design by \textit{Module} and \textit{Module Types}. We can speak in category theory for the same purpose in theory developement.

% \begin{definition}[SpaceType]
%   \textsf{SpaceType} is a category. Its objects are lambda calculi with dependent types, where two special constants are defined:
%   \begin{itemize}
%     \item $\texttt{prod} : \texttt{Type} \to \texttt{Type} \to \texttt{Type}.$
%     \item $\texttt{pair} : (A : \texttt{Type}) \to (B : \texttt{Type}) \to \texttt{prod}\ A\ B.$
%   \end{itemize} 
%   Morphisms exist from the calculi to more expressive ones.
% \end{definition}
% The product and pair is necessary because we will consider tensor product in the linear algebra.

% More complicated module instances, such as those with tuples, can also be considered as objects in \textsf{SpaceType}.

% \begin{definition}[Field]
%   \textsf{Field} is a category. Its objects are algebras containing \textbf{field} as a subalgebra. Morphisms exist from algebras to more expressive ones.  
% \end{definition}

% \begin{definition}[LinAlg]
%   \textsf{LinAlg} is a category. Its objects are lambda calculi with dependent types containing the following constants:
%   \begin{itemize}
%     \item an extra sort $\texttt{SType} : \texttt{Type}$,
%     \item $\mathbb{F} : \texttt{Type}$
%     \item $\texttt{WT\_Vec} : \texttt{SType} \to \texttt{Type}$,
%     \item $\texttt{WT\_LOpt} : \texttt{SType} \to \texttt{SType} \to \texttt{Type}$,
%     \item $\texttt{VecTerm} : (T : \texttt{SType}) \to (t : T) \to \texttt{WF\_Vec}\ T$,
%     \item $\texttt{VecScale} : (T : \texttt{SType}) \to \mathbb{F} \to \texttt{WF\_Vec}\ T \to \texttt{WF\_Vec}\ T$,
%     \item (more constructors on vectors ... )
%     \item $\texttt{LOptElement} : (T_1\ T_2 : \texttt{SType}) \to \texttt{WT\_Vec}\ T_1 \to \texttt{WT\_Vec}\ T_2 \to \texttt{WT\_LOpt}\ T_1\ T_2$,
%   \end{itemize}

% \end{definition}




\section{Motivating Examples}
The theory \textbf{Dirac0} is very limited as we almost don't have variables. Now we investigate several examples that motivates our extension on it.


\begin{example}
  Assume $S, T$ are two disjoint subsystems with orthonormal basis $\{\ket{v_i}_S\}_{i \in J}$ and $\{\ket{u_i}_T\}_{i \in J}$.
  $$
  \sum_{mn}A(m, n) \ket{v_m}_S\bra{v_n} \sum_i \ket{v_i}_S \ket{u_i}_T.
  $$
\end{example}
We have big-op of sum, and the indices appear in the vector (not the quantum register). This makes sense because the summation requires every labelled dirac notation to have the same type. It's also appropriate to assume that indices $m, n$ and $i$ are variables following some space type $T$. And the scope of summation is implicitly designated as a set. We also need functions: they appear directly as $A : T \to T \to \mathbb{C}$, and play the important role in big-op:
$$
\frac{\vdash v : T \to \texttt{Dirac}\ (U, \texttt{Unit}) \qquad \vdash m : T}{\vdash v_m : \texttt{Dirac}\ (U, \texttt{Unit})}.
$$
Here $\texttt{Dirac}\ (U, \texttt{Unit})$ represents Dirac notation with types of $(U, \texttt{Unit})$. Obviously we will need some typed lambda calculus for it. And actually the big-op of sum is a constant in such a typed lambda calculus:
$$
\sum : (D : \texttt{sType * sType}) \to \mathcal{P}(T) \to (T \to \texttt{Dirac}\ D) \to \texttt{Dirac}\ D.
$$

Here $\texttt{sType}$ is the sort for space types. The first argument $T$ corresponds to the type of indices, the second $D$ corresponds to the type of Dirac notations, the third argument is the set of index values and the last argument is the term expression.

\begin{example}
  Consider this notation:
  $$
  \left [\ket{+} := \texttt{fun x : bool => }\frac{\ket{0}_x + \ket{1}_x}{\sqrt{2}} \right ][\texttt{y : bool}] \vdash \bra{+}_y * \ket{+}_y = 1
  $$
\end{example}
In other words, it's reasonable to have definitions for Dirac notations. Typed lambda calculus also solves this problem.


\section{About Big Operators and Lambda Calculus}
I believe the two vital considerations for big operators are \textbf{lambda calculus} and \textbf{set syntax}. We have to include lambda calculus, because the expression for big operators are essentially functions. And for sets with certain syntax, it is possible to design a complete term rewriting system.

Assume the index of big operator has type $T$, then a set of index values can be considered as functions of $T \to \texttt{bool}$.

\begin{example}[big-op lifting]
  We can consider how to extend a term rewriting system $R$ with big operators. It is essentially the a functor between the two category.

  \begin{enumerate}
    \item Consider a simply typed lambda calculus, where functions in $R$ appear as constants in the calculus.
    \item Pick out an associative bineary function symbol $+$.
    \item Pick out the neuteral element so that $0 + a \to a$.
    \item Define the type $T$ as type of indices.
    \item Define the type $\texttt{set} : T \to \texttt{Type}$ as the sets.
    \item The big operator is a constant $\sum : \texttt{set}\ T \to (T \to U) \to U$, where $U$ is the type of the big operator expression.
  \end{enumerate}
\end{example}


\begin{example}
  Assume sets are constructed by enumerating $T$ terms, then the syntax with big operators is still decidable.
\end{example}

May be the integer set $[m, n]$ worth considering. But I don't believe it can be decidable in more general cases.


\section{Tuple, Variable Index and Separation Logic}

\subsection{Motivating example}

Consider the notation:
$$
\texttt{CX}[a[i], a[j]] = \texttt{H}[a[j]]\ \texttt{CZ}[a[i], a[j]]\ \texttt{H}[a[j]]
$$
where $a$ is a quantum tuple register. The equality seems to hold, but here is a precondition: $i \neq j$. Otherwise, the Dirac notation is not even well-typed. 

Because we only consider well-typed Dirac notations, we use separation logic to deal with these precondition on well-typed proofs.