  
% \input{yingte/20231117.tex}

Firstly let's review the simply typed lambda calculus with product type and projections. Product type is used to model the tensor of linear spaces.

\section{STLC with Tuples}

\subsection{STLC with tuple types and projections}

\begin{definition}
    A \textbf{simply typed lambda calculus} with (strict) tuple types and projections consists of types $\tau$ and terms $e$. The syntax is:
    \begin{align*}
        \tau ::=&\ T\ |\ \tau \to \tau\\
          &\ |\ \{ \tau * \tau * \cdots * \tau \} \\
        e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
          &\ |\ \{ e, e, \dots, e \}\ |\ \pi_i\ e
    \end{align*}
    Here $T \in B$ is a basic type, $x$ is a variable and $c$ is a constant.
    $\tau * \tau * \cdots * \tau$ and $e, e, \dots, e$ are finite sequences. $i$ is a constant positive number.
\end{definition}

\textbf{Remark:} Unit is modelled by the empty tuple $\{*\}$, which has the only term $\{\}$.

\begin{definition}[typing rules]
    \label{def:STLC_tuple_typing}
    A typing assumption has the form $x : \tau$, meaning variable $x$ has the type $\tau$. A typing context $\Gamma$ consists of typing assumptions and each variable appears only once at most.

    A typing judgement $\Gamma \vdash e : \sigma$ indicates that $e$ is a term of type $\sigma$ in context $\Gamma$. The well-typed lambda terms are defined by the following rules:
    \begin{gather*}
        \frac{x : \sigma \in \Gamma}{\Gamma \vdash x : \sigma}
        \qquad \frac{c\ \textrm{is a constant of}\ T}{\Gamma \vdash c : T}\\
        \ \\
        \textcolor{red}{\frac{\Gamma::(x : \tau) \vdash e : \sigma}{\Gamma \vdash (\lambda x : \tau.e) : (\tau \to \sigma)}}
        \qquad \frac{\Gamma \vdash e_1 : \tau \to \sigma \qquad \Gamma \vdash e_2 : \tau}{\Gamma \vdash e_1\ e_2 : \sigma}\\
        \ \\
        \frac{\forall i, \Gamma \vdash e_i : \tau_i}{\Gamma \vdash \{e_1, \dots, e_n \} : \{ \tau_1 * \cdots * \tau_n\}}
        \qquad 
        \frac{\Gamma \vdash e : \{ \tau_1 * \cdots * \tau_n \} \qquad i \leq n}{\Gamma \vdash \pi_i\ e : \tau_i}
    \end{gather*}
\end{definition}
\yx{$\Gamma::(x : \tau)$ can be not well-formed. Maybe rename the bound variable?}

\begin{definition}[equational theory]
    \label{def:STLC_tuple_red}
    The reduction rules for terms are:
    \begin{gather*}
        \frac{\Gamma::(x:\tau)\vdash t:\sigma\qquad \Gamma\vdash u:\tau}{\Gamma \vdash (\lambda x : \tau.t)u \ \triangleright_\beta\ t[x/u]}
        \qquad 
        \frac{\Gamma \vdash t : \tau \to \sigma\qquad x\ \textrm{is free in}\ t}{\Gamma \vdash \lambda x : \tau. t\ x\ \triangleright_\eta\ t}\\
        \ \\
        \frac{\Gamma \vdash \{e_1, \dots, e_n \} : \{ \tau_1 * \cdots \tau_n\}\qquad i \leq n}{\Gamma \vdash \pi_i\ \{e_1, \dots, e_n \}\ \triangleright_\pi\ e_i}
        \qquad
        \frac{\Gamma \vdash u : \{ \tau_1 * \cdots * \tau_n\}}{\Gamma \vdash \{\pi_1\ u, \dots, \pi_n\ u \}\ \triangleright_\pi\ u}
        \qquad
        \frac{\Gamma \vdash t : \{*\}}{\Gamma \vdash t\ \triangleright_\pi\ \{\}}
    \end{gather*}

    Two terms $s$ and $t$ are $\beta\eta\pi$-equivalent in context $\Gamma$, written as $\Gamma \vdash s =_{\beta\eta\pi} t$, if they have the same normal form after $\beta\eta\pi$-reduction.
\end{definition}

\yx{The congruence of the reductions needs to be clarified. This should have been well studied already.}


\subsection{STLC with flexible tuples}

Types of flexible tuple are needed to facilitate the reasoning of Dirac notations in the mathematical style, where the equivalence is considered much more casually. For example:
$$
\ket{[0,[1,0]]} = \ket{0} \otimes (\ket{1} \otimes \ket{0}) = \ket{0} \otimes \ket{1} \otimes \ket{0} = \ket{[[0, 1], 0]} = \ket{[0, 1, 0]}.
$$

\begin{definition}[STLC with flexible tuples]
  A \textbf{simply typed lambda calculus} with flexible tuples consists of types $\tau$ and terms $e$. The syntax is:
  \begin{align*}
      \tau ::=&\ T\ |\ \tau \to \tau\\
        &\ |\ \{ \tau * \tau * \cdots * \tau \} \\
        &\ |\ [ \tau * \tau * \cdots * \tau ] \\
      e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
        &\ |\ \{ e, e, \dots, e \}\ |\ \pi_i\ e \\
        &\ |\ [ e, e, \dots, e ]
  \end{align*}
  Here $T \in B$ is a basic type, $x$ is a variable and $c$ is a constant.
  $\tau * \tau * \cdots * \tau$ and $e, e, \dots, e$ are finite sequences. $i$ is a constant positive number.
\end{definition}

\textbf{Remark: }We don't consider projections for sequence $[ e, e, \dots, e ]$ because they don't have a fixed length after we incorporate the isomorphism into the equational theory.



\begin{definition}[typing rules]
  \label{def:STLC_flexible_tuple_typing}
  The typing rules include those in Def.\ref{def:STLC_tuple_typing} and the following rules:
  \begin{gather*}
      \frac{\forall i, \Gamma \vdash e_i : \tau_i}{\Gamma \vdash [e_1, \dots, e_n ] : [ \tau_1 * \cdots * \tau_n ]}
  \end{gather*}
\end{definition}

Due to the product and unit types, we need to extend the $\beta\eta\pi$-equivalence to contain the isomorphism as well. This is necessary because of the isomorphism between linear spaces.
\begin{definition}[equational theory for flexible tuple]
  \label{def:STLC_flexible_tuple_red}
  The extra reduction rules incorporating linear space isomorphisms are:
  \begin{gather*}
      \vdash [\tau_1 * \cdots * \tau_i * [\sigma_1 * \cdots * \sigma_m] * \tau_{i+1} * \cdots * \tau_n] \ \triangleright_\phi\ [\tau_1 * \cdots * \tau_i * \sigma_1 * \cdots * \sigma_m * \tau_{i+1} * \cdots * \tau_n]\\
      \ \\        
      \frac{\forall i, \Gamma \vdash e_i : \tau_i \qquad \forall i, \Gamma \vdash s_i : \sigma_i}{\Gamma \vdash [e_1, \dots, e_i, [s_1, \dots, s_m], e_{i+1}, \dots, e_n] \ \triangleright_\phi\ [e_1, \dots, e_i, s_1, \dots, s_m, e_{i+1}, \dots, e_n]}\\
      \ \\
      \frac{\Gamma \vdash t : [*]}{\Gamma \vdash t\ \triangleright_\phi\ []}
  \end{gather*}
  The first several rules define the equational theory for types, and the corresponding extra typing rule is:
  $$
  \frac{\Gamma \vdash s : \tau\qquad \tau =_\phi \sigma}{\Gamma \vdash s : \sigma}
  $$
  Two terms are equivalent if they have the same normal form after $\beta\eta\pi\phi$-reduction.
\end{definition}

In short, the flexible tuple $[\cdots]$ is flattened and the unit types inside are removed. It is used to encode the Dirac notations in the mathematics style, and the strict tuple $\{\cdots\}$ serves as the normal form for the decision procedure.

\yx{Congruence for $\beta\eta\pi\phi$-reduction?}

\section{Dirac Lambda Calculus}

I believe that the decision procedure for linear algebra is necessary, but I didn't notice any serious work on this topic. It should be because decision procedure is considered and required in formal verification, but not was linear algebra, not until now we have quantum programs. 

Actually the syntax we are considering here is far beyond linear algebra.
And after I transplanted the theory onto the simply typed lambda calculus, soon I realized the theory we require is very similar to quantum lambda calculi.


\subsection{Motivating Examples}
We investigate several examples that motivates the adoption of a lambda calculus.

\begin{example}[variable and big-op]
  Assume $S, T$ are two disjoint subsystems with orthonormal basis $\{\ket{v_i}_S\}_{i \in J}$ and $\{\ket{u_i}_T\}_{i \in J}$.
  $$
  \sum_{mn}A(m, n) \ket{v_m}_S\bra{v_n} \sum_i \ket{v_i}_S \ket{u_i}_T.
  $$
\end{example}
We have big-op of sum, and the indices appear in the vector (not the quantum register). This makes sense because the summation requires every labelled dirac notation to have the same type. It's also appropriate to assume that indices $m, n$ and $i$ are variables following some space type $T$. And the scope of summation is implicitly designated as a set. We also need functions: they appear directly as $A : T \times T \to \mathbb{C}$, and play the important role in big-op:
$$
\frac{\Gamma \vdash v : T \to \texttt{Unit} \multimap \tau \qquad \Gamma \vdash m : T}{\Gamma \vdash v_m : \texttt{Unit} \multimap \tau}.
$$
Here $\texttt{Unit} \multimap \tau$ represents the type of linear operators with domain \texttt{Unit} and codomain $\tau$. Obviously we will need some typed lambda calculus for it. And actually the big-op of sum can be modelled by:
$$
\sum : (T\ \tau\ \sigma : \texttt{Type}) \to \mathcal{P}(T) \to (T \to \tau \multimap \sigma) \to (\tau \multimap \sigma).
$$

Here $\texttt{Type}$ is the sort for types. The first argument $T$ corresponds to the type of indices, the next two parameters $\tau$ and $\sigma$ correspond to the type of Dirac notations, the fourth argument is the set of index values and the last argument is the term expression.

\begin{example}[definitions]
  Consider this notation (of labelled Dirac notations):
  $$
  \left [\ket{+} := \lambda x:\texttt{qvar(bool)}.\frac{\ket{0}_x + \ket{1}_x}{\sqrt{2}} \right ][y : \texttt{qvar(bool)}] \vdash \bra{+}_y * \ket{+}_y = 1
  $$
\end{example}
In other words, it's reasonable to have definitions for Dirac notations. Typed lambda calculus also solves this problem.

\begin{example}[super operator]
  Consider the super operator 
  $$
  \mathcal{P}_0 (\rho) = \ket{0}\bra{0} \rho \ket{0}\bra{0} + \ket{0}\bra{1} \rho \ket{1}\bra{0}.
  $$
  It can be expressed by the Dirac notation
  $$
  \mathcal{P}_0 : (\texttt{bool} \multimap \texttt{bool}) \multimap (\texttt{bool} \multimap \texttt{bool}) := \ket{\ket{0}\bra{0}}\bra{\ket{0}\bra{0}} + \ket{\ket{0}\bra{0}}\bra{\ket{1}\bra{1}}
  $$
\end{example}
\yx{This is a promising solution for super operator but problems still exist. For example, the equivalence when transforming to Choi representation:
$$
\ket{\frac{1}{2}I} = \ket{\frac{1}{2}(\ket{0}\bra{0} + \ket{1}\bra{1})} \mathop{=}^? \frac{1}{2}(\ket{\ket{0}\bra{0}} + \ket{\ket{1}\bra{1}}).
$$
}


\subsection{Syntax and Typing}

Now we extend the simply typed lambda calculus with Dirac notations.

\begin{postulate}[complex number]
  $\mathbb{C}$ is an algebra for complex numbers. It has the symbols $(0, 1, +, *, \textrm{conj})$.
\end{postulate}
It means that somehow we can express and decide complex number terms, but the theory should not be considered here.

\begin{definition}[atomic type and term]
  The atomic types are $\mathbf{Z}_n$.
  The constants of the type $\mathbf{Z}_n$ is $\{i \in \mathbb{N} : i<n\}$
  Here $n$ and $i$ are natural numbers.
\end{definition}

% \textbf{Remark:} We define atomic types separatedly because they describe the types of atomic quantum subsystems.

\begin{definition}[Dirac lambda calculus]
  \textbf{Dirac lambda calculus} is an extension of STLC with tuple types and Dirac notations. The syntax for types and terms is:
  \begin{align*}
    \tau ::=&\ T\ |\ \tau \to \tau\\
      &\ |\ [ \tau *\tau*\cdots * \tau ] \\
      &\ |\ \tau \multimap \tau\\
    e ::=&\ x\ |\ c\ |\ \lambda x : \tau. e\ |\ e\ e\\
      &\ |\ [e, e, \dots, e] \\
      &\ |\ \mathbf{0}_{\tau, \tau}\ |\ \mathbf{1}\ |\ \delta_{e, e}\ |\ \ket{e}\ |\ \bra{e}\ |\ e^*\ |\ e^T\ |\ e * e\ |\ e + e\ |\ e \cdot e\ |\ e \otimes e
  \end{align*}
  Here $T \in \{\mathbf{Z}_n, \mathbb{C}\}$ is a basic type, $x$ is a variable and $c$ is a constant. $\tau *\tau*\cdots * \tau$ and $e, e, \dots, e$ are finite sequences.
\end{definition}

\textbf{Remark: } Note that strict tuple $\{\cdots\}$ are not considered here. The essential reason is that only the order of tensor is considered in the structure of Hilbert space.

\begin{definition}[typing rules]
  The concept of typing assumption, context and typing judgement is defined the same as in Def.\ref{def:STLC_flexible_tuple_typing}. The typing rules for Dirac lambda calculus include thoes in Def.\ref{def:STLC_flexible_tuple_typing} as well as the following ones:
  \begin{gather*}
    \frac{}{\Gamma \vdash \mathbf{0}_{\tau, \sigma} : [\tau] \multimap [\sigma]}
    \qquad
    \frac{}{\Gamma \vdash \mathbf{1} : [*] \multimap [*]}
    \qquad
    \frac{\Gamma \vdash s : \tau \qquad \Gamma \vdash t : \tau}{\Gamma \vdash \delta_{s, t} : [*] \multimap [*]}\\
    \ \\
    \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \ket{t} : [*] \multimap [\tau]}
    \qquad 
    \frac{\Gamma \vdash t : \tau}{\Gamma \vdash \bra{t} : [\tau] \multimap [*]}\\
    \ \\
    \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash e^* : \sigma \multimap \tau}
    \qquad
    \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash e^T : \sigma \multimap \tau}
    \qquad
    \frac{\Gamma \vdash c : \mathbb{C}\qquad \Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash c * e : \tau \multimap \sigma}\\
    \ \\
    \frac{\Gamma \vdash e_1 : \tau \multimap \sigma \qquad \Gamma \vdash e_2 : \tau \multimap \sigma }{\Gamma \vdash e_1 + e_2 : \tau \multimap \sigma }
    \qquad 
    \frac{\Gamma \vdash e_1 : \tau \multimap \rho\qquad \Gamma \vdash e_2 : \rho \multimap \sigma}{\Gamma \vdash e_2 \cdot e_1 : \tau \multimap \sigma}\\
    \ \\
    \frac{\Gamma \vdash e_1 : \tau \multimap \sigma \qquad \Gamma \vdash e_2 : \tau' \multimap \sigma'}{\Gamma \vdash e_1 \otimes e_2 : [\tau * \tau'] \multimap [\sigma * \sigma']}
  \end{gather*}
  
\end{definition}

\begin{claim}
  For any term $e$ of Dirac lambda calculus in any context $\Gamma$, there exists at most one type $\tau$ (w.r.t. $=_\phi$) that satisfies $\Gamma \vdash e : \tau$. The types of all terms are computable (if exist).
\end{claim}

\subsection{Reduction in Dirac lambda calculus}
The reduction rules for terms in Dirac lambda calculus include thoes in Def.\ref{def:STLC_tuple_red}, Def.\ref{def:STLC_flexible_tuple_red} and the ones presented below.


\subsubsection*{Delta Operator}
\begin{align*}
  & \Gamma \vdash \delta_{s, s}\ \triangleright\ \mathbf{1}
  \qquad
  \frac{s =? t\ \textrm{has no unifier in}\ \Gamma}{\Gamma \vdash \delta_{s, t} \ \triangleright\ \mathbf{0}_{[*], [*]}}
  \qquad
  \frac{s < t}{\Gamma \vdash \delta_{s, t} \ \triangleright\ \delta_{t, s}}
\end{align*}

\subsubsection*{Ket}
\begin{align*}
  & \Gamma \vdash \ket{[]} \ \triangleright\ \mathbf{1} \\
  & \Gamma \vdash \ket{[s_1, s_2, \dots, s_n]} \ \triangleright\ \ket{s_1} \otimes \ket{s_2} \otimes \cdots \otimes \ket{s_n}
\end{align*}

\subsubsection*{Bra}
\begin{align*}
  & \Gamma \vdash \bra{[]} \ \triangleright\ \mathbf{1} \\
  & \Gamma \vdash \bra{[s_1, s_2, \dots, s_n]} \ \triangleright\ \bra{s_1} \otimes \bra{s_2} \otimes \cdots \otimes \bra{s_n}
\end{align*}

\textbf{Remark: } The flexible tuple $[\cdots]$ is mainly to couple with the equivalence of tensor product. For example, we require $\mathbf{1} \otimes e = e$, which means that unit types should be removed during reduction. Another example is that we require that $\ket{s} \otimes (\ket{t} \otimes \ket{v}) = (\ket{s} \otimes \ket{t}) \otimes \ket{v}$, therefore $[s, [t, v]] = [[s, t], v]$, which means the tuple should be ``flattened'' when considering equivalence.

\subsubsection*{Conjugate}
\begin{align*}
  & \Gamma \vdash \textbf{0}_{\tau, \sigma}^* \ \triangleright\ \textbf{0}_{\tau, \sigma}
  \qquad 
  \Gamma \vdash \mathbf{1}^* \ \triangleright\ \mathbf{1}
  \qquad 
  \Gamma \vdash \delta_{s,t}^* \ \triangleright\ \delta_{s,t}\\
  & \Gamma \vdash \ket{v}^* \ \triangleright\ \ket{v}
  \qquad 
  \Gamma \vdash \bra{v}^* \ \triangleright\ \bra{v} \\
  & \Gamma \vdash (e^*)^*\ \triangleright\ e
  \qquad 
  \Gamma \vdash (e^T)^* \ \triangleright\ (e^*)^T
  \qquad 
  \textcolor{blue}{\Gamma \vdash (c * e)^* \ \triangleright\ \textrm{conj}(c) * (e^*)}\\
  & \Gamma \vdash (e_1 + e_2)^* \ \triangleright\ e_1^* + e_2^* 
  \qquad \Gamma \vdash (e_1 \cdot e_2)^* \ \triangleright\ e_2^* \cdot e_1^* 
  \qquad \Gamma \vdash (e_1 \otimes e_2)^* \ \triangleright\ e_1^* \otimes e_2^*
\end{align*}

\subsubsection*{Transpose}
\begin{align*}
  & \Gamma \vdash \textbf{0}_{\tau, \sigma}^T \ \triangleright\ \textbf{0}_{\sigma, \tau} 
  \qquad \Gamma \vdash \mathbf{1}^T \ \triangleright\ \mathbf{1}
  \qquad \Gamma \vdash \delta_{s,t}^T \ \triangleright\ \delta_{s,t} \\
  & \Gamma \vdash \ket{v}^T \ \triangleright\ \bra{v} 
  \qquad \Gamma \vdash \bra{v}^T \ \triangleright\ \ket{v} \\
  & \Gamma \vdash (c * e)^T \ \triangleright\ c * (e^T)
  \qquad \Gamma \vdash (e^T)^T \ \triangleright\ e\\
  & \Gamma \vdash (e_1 + e_2)^T \ \triangleright\ e_1^T + e_2^T 
  \qquad \Gamma \vdash (e_1 \cdot e_2)^T \ \triangleright\ e_2^T \cdot e_1^T 
  \qquad \Gamma \vdash (e_1 \otimes e_2)^T \ \triangleright\ e_1^T \otimes e_2^T
\end{align*}


\subsubsection*{Scalar Multiplication}
\begin{align*}
  & \frac{\Gamma, \mathbb{C} \vdash c = 0 \qquad \Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash c * e \ \triangleright\ \textbf{0}_{\tau, \sigma}}
  \qquad 
  \frac{\Gamma, \mathbb{C} \vdash c = 1 }{\Gamma \vdash c * e \ \triangleright\ e}\\
  &\ \\
  & \Gamma \vdash c * \mathbf{0}_{\tau, \sigma} \ \triangleright\ \mathbf{0}_{\tau, \sigma} \\
  & \textcolor{blue}{\Gamma \vdash c_1 * (c_2 * e) \ \triangleright\ (c_1 * c_2) * e} \\
  & \Gamma \vdash c * (e_1 + e_2) \ \triangleright\ c * e_1 + c * e_2
\end{align*}

\subsubsection*{Addition}
\begin{align*}
  &
  \frac{\Gamma \vdash e : \tau \multimap \sigma}{\Gamma \vdash e + \textbf{0}_{\tau, \sigma}\to e}\\
  &\ \\
  & 
  \textcolor{red}{\Gamma \vdash c_1 * e + c_2 * e \ \triangleright\ (c_1 + c_2) * e 
  \quad \Gamma \vdash c * e + e \ \triangleright\ (c + 1) * e
  \quad \Gamma \vdash e + e \ \triangleright\ 2 * e} \\
  & \Gamma \vdash e_1 + (e_2 + e_3) \ \triangleright\ e_1 + e_2 + e_3 \\
  &\ \\
  & \frac{e_1 < e_2}{\Gamma \vdash e_1 + e_2 \ \triangleright\ e_2 + e_1}
\end{align*}

\yx{The rules for item merging seem not obeying the LPO. Maybe $(c_1 + c_2)*e$ can be considered as a subterm of $c_1 * e$ if we ignore the structure of complex numbers?}

\subsubsection*{Multiplication}
\begin{align*}
  & \frac{\Gamma \vdash e : \tau \multimap \rho}{\Gamma \vdash \textbf{0}_{\rho, \sigma} \cdot e \ \triangleright\ \textbf{0}_{\tau, \sigma}}
  \qquad 
  \frac{\Gamma \vdash e : \rho \multimap \sigma}{\Gamma \vdash e \cdot \textbf{0}_{\tau, \rho} \ \triangleright\ \textbf{0}_{\tau, \sigma}}\\
  &\ \\
  & \Gamma \vdash \mathbf{1} \cdot e \ \triangleright\ e
  \qquad
  \Gamma \vdash e \cdot \mathbf{1} \ \triangleright\ e \\
  & \Gamma \vdash \bra{s} \cdot \ket{t} \ \triangleright\ \delta_{s, t}\\
  & \Gamma \vdash (c * e_1) \cdot e_2 \ \triangleright\ c * (e_1 \cdot e_2)
  \qquad \Gamma \vdash e_1 \cdot (c * e_2) \ \triangleright\ c * (e_1 \cdot e_2) \\ 
  & \Gamma \vdash e_1 \cdot (e_2 + e_3) \ \triangleright\ e_1 \cdot e_2 + e_1 \cdot e_3
  \qquad \Gamma \vdash (e_1 + e_2) \cdot e_3 \ \triangleright\ e_1 \cdot e_3 + e_2 \cdot e_3 \\
  & \Gamma \vdash e_1 \cdot (e_2 \cdot e_3) \ \triangleright\ e_1 \cdot e_2 \cdot e_3\\
  &\ \\
  & \frac{\Gamma \vdash e_1 : [*] \multimap \tau\qquad \Gamma \vdash e_2 : \sigma \multimap [*]}{\Gamma \vdash e_1 \cdot e_2 \ \triangleright\ e_1 \otimes e_2}\\
  &\ \\
  & \frac{\Gamma \vdash e_1 : \rho \multimap \tau \qquad \Gamma \vdash e_2 : \sigma \multimap \rho}{\Gamma \vdash (E_1 \otimes e_1) \cdot (E_2 \otimes e_2) \ \triangleright\ (E_1 \cdot E_2) \otimes (e_1 \cdot e_2)}
\end{align*}

\textbf{Remark: } The last two rules conduct \textbf{tensorization}. Here's an illustration for the rule in tensor network.
\begin{center}
\includegraphics*[width=0.8\textwidth]{fig/tn_example.png}
\end{center}

\yx{Most complicated rules can be intuitively explained by tensor network graphs. It's worth building the connection between Dirac notation and tensor network representations.}

\subsubsection*{Tensor}
\begin{align*}
  & \frac{\Gamma \vdash e : \tau \multimap \sigma}{e \otimes \textbf{0}_{\tau', \sigma'} \ \triangleright\ \textbf{0}_{[\tau * \tau'], [\sigma * \sigma']}}
  \qquad \Gamma \vdash e \otimes \mathbf{1} \ \triangleright\ e\\
  & \Gamma \vdash (c * e_1) \otimes e_2 \ \triangleright\ c * (e_1 \otimes e_2)\\
  & \Gamma \vdash e_1 \otimes (e_2 + e_3) \ \triangleright\ e_1 \otimes e_2 + e_1 \otimes e_3
  \qquad 
  \Gamma \vdash (e_1 + e_2) \otimes e_3 \ \triangleright\ e_1 \otimes e_3 + e_2 \otimes e_3\\
  & \Gamma \vdash e_1 \otimes (e_2 \otimes e_3) \ \triangleright\ e_1 \otimes e_2 \otimes e_3\\
  & \frac{\Gamma \vdash e_1 : \tau_1 \multimap \sigma_1 \qquad \Gamma \vdash e_2 : \tau_2 \multimap \sigma_2 \qquad \tau_1 = [*] \vee \tau_2 = [*]\qquad \sigma_1 = [*] \vee \sigma_2 = [*] \qquad e_1 < e_2}{\Gamma \vdash e_1 \otimes e_2 \ \triangleright\ e_2 \otimes e_1}
\end{align*}

\textbf{Remark: } Tensor is only commutative when one side of the domain and codomain is $[*]$, because the order of product matters when there is no labelling.


\subsection{Congruence of TRS for Dirac notations}

\begin{definition}[LPO]
  Let $\Sigma$ be a finite signature and $>$ be a strict order on $\Sigma$. The \textbf{lexicographic path order}  $>_{lpo}$ on $T(\Sigma, V)$ induced by $>$ is defined as follows: $s >_{lpo} t$ iff
  \begin{itemize}
    \item \textbf{(LPO1)} $t \in \mathrm{Var}(s)$ and $s \neq t$, or
    \item \textbf{(LPO2)} $s = f(s_1, \dots, s_m)$, $t = g(t_1, \dots, t_n)$, and
    \item \begin{itemize}
      \item \textbf{(LPO2a)} there exists $i, 1\leq i \leq m$, with $s_i \geq_{lpo} t$, or
      \item \textbf{(LPO2b)} $f > g$ and $s >_{lpo} t_j$ for all $j, 1\leq j \leq n$, or
      \item \textbf{(LPO2c)} $f = g$, $s >_{lpo} t_j$ for all $j, 1\leq j \leq n$, and there exists $i, 1 \leq i \leq m$, such that $s_{i+1} = t_{i+1}, \dots, s_m = t_m$ and $s_i >_{lpo} t_i$.
    \end{itemize}
  \end{itemize}
  
\end{definition}

The rule \textbf{(LPO2c)} compares the subterms from right to left, and that's why it's called lexicographic.

\begin{lemma}[Termination of TRS for Dirac notations]
  The termination of the TRS for Dirac notations can be proved by the LPO induced by the following strict order:

  \begin{center}
  \begin{tikzpicture}[node distance=15pt]
    \node[draw]                     (complex) {all complex function};
    \node[draw, below= of complex, align=center] (STLC) {$x$\\$c$\\$\lambda x : \tau . t$\\$e\ e$\\$[e, e, \dots, e]$};

    \node[draw, right=of complex]                        (zero)   {$\mathbf{0}$};
    \node[draw, right=of zero]     (one)     {$\mathbf{1}$};
    \node[draw, right=of one]        (add)  {$+$};
    \node[draw, right=of add]         (scalar)  {$*$};
    \node[draw, right=of scalar]     (tensor)  {$\otimes$};
    \node[draw, right=of tensor]       (bra) {$\bra{t}$};
    \node[draw, right=of bra]       (ket) {$\ket{t}$};
    \node[draw, right=of ket]     (delta)     {$\delta_{ij}$};
    \node[draw, right=of delta]       (mul)  {$\cdot$};
    \node[draw, right=of mul]     (trans)     {transpose};
    \node[draw, right=of trans]     (conj)     {conjugate};

    
    \graph{
      (conj) -> (trans) -> (mul) -> (delta) -> (ket) -> (bra) -> (tensor) -> (scalar) ->(add) -> (one) -> (zero) -> (complex);
      (zero) -> (STLC);
    };
  \end{tikzpicture}
  \end{center}
\end{lemma}

\begin{proof}
  We need to check that every reduction rule makes the term strictly smaller in the LPO.
  Most cases are direct by definition. It's worth noting that for associative symbols $\cdot$, $\otimes$ and $+$, the simpler form is left-most associative, which is consistent with the LPO definition, because the right most subterms are compared first in \textbf{(LPO2c)}. Besides, $+$ is commutative, and the side condition of the subterm order helps avoid the infinite loop of rewriting.
\end{proof}


\begin{example}
  Important local confluence:
  \begin{center}
    \begin{tikzpicture}[node distance=20pt]
      \node[draw] (P) {$\ket{[s_1,[t_1, t_2]]}$};
      \node[draw, right=of P]  (Q1)   {$\ket{[s_1, t_1, t_2]}$};
      \node[draw, below=of P]  (Q2)   {$\ket{s_1} \otimes \ket{[t_1, t_2]}$};

      \node[draw, right=of Q2]  (Q3)   {$\ket{s_1} \otimes (\ket{t_1} \otimes \ket{t_2})$};
      \node[draw, right=of Q3]  (Q4)   {$\ket{s_1} \otimes \ket{t_1} \otimes \ket{t_2}$};


      \graph{
        (P) -> (Q1) -> (Q4);
        (P) -> (Q2) -> (Q3) -> (Q4);
      };
    \end{tikzpicture}
  \end{center}
\end{example}

\begin{claim}[Normal Form]
  The normal form $NF$ of Dirac notations should approximately be like:
  \begin{align*}
    NF ::=&\ \mathbf{0}_{\tau, \sigma}\ |\ \sum (c*\delta\otimes\delta\otimes \cdots \otimes \delta \otimes OPT \otimes OPT \otimes \cdots \otimes OPT) \\
    OPT ::=& \ket{\cdot} \otimes \ket{\cdot} \otimes \cdots \otimes \ket{\cdot} \otimes \bra{\cdot} \otimes \bra{\cdot} \otimes \cdots \otimes \bra{\cdot}\ |\ X
  \end{align*}
\end{claim}

$\ket{\cdot}$ represents ket-like terms and $\bra{\cdot}$ represents bra-like terms.


\clearpage


% \subsection{Labelled Dirac Notation}

% \begin{definition}[quantum register]
%   $$
%   r ::= E\ |\ x\ |\ (r, r)
%   $$
%   Here $E$ is the terminal symbol for empty register and $x$ is a quantum variable.
% \end{definition}

% \begin{definition}[quantum variable typing]
%   The typing for quantum variable $x$ is written as $x : T$, where $T$ is a space type.
% \end{definition}

% \begin{definition}[quantum context]
%   The quantum contexts are ordered list of quantum variable typings, written as $\Gamma = [x : T; y : U; \dots]$. The empty context is denoted by $[]$.
% \end{definition}

% \begin{definition}[well-formed context]
%   A well-formed context $\Gamma$, written as $\mathcal{WF}(\Gamma)$, is a context where variables appear uniquely. In other words, they are defined as:
%   $$
%   \frac{}{\mathcal{WF}([])}
%   \qquad
%   \frac{\mathcal{WF}(\Gamma)\qquad x \notin \Gamma}{\mathcal{WF}(\Gamma :: (x : T))}
%   $$
% \end{definition}


% \begin{definition}[well-typed quantum register]
%   Within a well-formed context $\mathcal{WF}(\Gamma)$, the well-typed quantum register is denoted as $\mathcal{WF}(\Gamma) \vdash r : T$, where $r$ denotes a quantum register and $T$ a space type. The well-typed quantum register is defined as follows.
%   \begin{gather*}
%   \frac{\mathcal{WF}(\Gamma)}{\mathcal{WF}(\Gamma) \vdash E : \texttt{Unit}}
%   \qquad
%   \frac{\mathcal{WF}(\Gamma)\qquad x:T \in \Gamma}{\mathcal{WF}(\Gamma) \vdash x : T}\\
%   \ \\  
%   \frac{\mathcal{WF}(\Gamma) \vdash r_1 : T_1 \qquad \mathcal{WF}(\Gamma) \vdash r_2 : T_2\qquad \mathcal{WF}(\Gamma) \vdash r_1 \| r_2}{\mathcal{WF}(\Gamma) \vdash (r_1, r_2) : (T_1 * T_2) }
%   \end{gather*}
%   Note that $\mathcal{WF}(\Gamma) \vdash r_1 \| r_2$ is defined below.
% \end{definition}


% \begin{definition}[atomic quantum register]
%   We say a quantum register $r$ is atomic in context $\Gamma$ if we can prove
%   $\mathcal{WF}(\Gamma) \vdash r : A$, where $A$ is a atomic type.
% \end{definition}

% \begin{definition}[quantum subsystem]
%   A quantum subsystem $S$ is a set of quantum registers. 
%   We say it's a well-formed quantum subsystem in context $\Gamma$ if all the elements are atomic quantum register in $\Gamma$. 
%   For a quantum register $r$, $\mathrm{set}(\Gamma, r)$ represents the corresponding well-typed quantum subsystem in $\Gamma$.
%   Two quantum registers are disjoint in $\Gamma$, written as $\mathcal{WF}(\Gamma) \vdash r_1 \| r_2$, if the corresponding quantum subsystems are disjoint.
% \end{definition}
% \textbf{Remark:} The description of quantum subsystem still need refinement.

% \begin{definition}[labelled Dirac notation]
%     Labelled Dirac notation is defined by:
%     $$
%     e ::= e_d [r_k; r_b]\ |\ e + e\ |\ e * e\ |\ e \otimes e\ |\ e^*\ |\ e^T.
%     $$
%     Here $e_d$ is a Dirac notation and $r_k, r_b$ are quantum registers.
% \end{definition}

% \begin{definition}[labelled notation typing]
%   A typing of labelled Dirac notation $e$ in well-formed context $\Gamma$ is written as $\mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)$, where $S_k$ and $S_b$ are quantum subsystems. 
% \end{definition}

% \begin{definition}[well-typed labelled Dirac notation]
%   For the typing of labelled Dirac notation $\mathcal{WF}(\Gamma) \vdash e : (T_k, T_b)$, the well-typed proof is defined by
%   \begin{gather*}
%     \frac{\vdash e_d : (T_k, T_b) \qquad \mathcal{WF}(\Gamma) \vdash r_k : T_k \qquad \mathcal{WF}(\Gamma) \vdash r_b : T_b}{\mathcal{WF}(\Gamma) \vdash e_d[r_k; r_b] : (\mathrm{set}(\Gamma, r_k), \mathrm{set}(\Gamma, r_b))}\\
%     \ \\
%     \frac{\mathcal{WF}(\Gamma) \vdash e_1 : (S_k, S_b) \qquad \mathcal{WF}(\Gamma) \vdash e_2 : (S_k, S_b)}{\mathcal{WF}(\Gamma) \vdash e_1 + e_2 : (S_k, S_b)}\\
%     \ \\
%     \frac{\mathcal{WF}(\Gamma) \vdash e_1 : (S_k, S_b) \qquad \mathcal{WF}(\Gamma) \vdash e_2 : (S_k', S_b')
%     \qquad S_k \cap (S_k' - S_b) = \emptyset
%     \qquad (S_b - S_k') \cap S_b' = \emptyset}
%     {\mathcal{WF}(\Gamma) \vdash e_1 * e_2 : (S_k \cup (S_k' - S_b), (S_b - S_k') \cup S_b')}\\
%     \ \\
%     \frac{\mathcal{WF}(\Gamma) \vdash e_1 : (S_k, S_b) \qquad \mathcal{WF}(\Gamma) \vdash e_2 : (S_k', S_b')
%     \qquad S_k \cap S_k' = \emptyset
%     \qquad S_b \cap S_b' = \emptyset}
%     {\mathcal{WF}(\Gamma) \vdash e_1 \otimes e_2 : (S_k \cup S_k', S_b \cup S_b')}\\
%     \ \\
%     \frac{\mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)}{\mathcal{WF}(\Gamma) \vdash e^* : (S_k, S_b)}
%     \qquad
%     \frac{\mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)}{\mathcal{WF}(\Gamma) \vdash e^T : (S_b, S_k)}
%   \end{gather*}
% \end{definition}

% \begin{definition}[labelled Dirac notation reduction]
%   We consider the reduction on typings of labelled Dirac notations. The rules are defined by:
%   \begin{gather*}
%     \mathcal{WF}(\Gamma) \vdash ((e_d + e_d')[r_k; r_b]: (S_k, S_b)) \to (e_d[r_k; r_b] + e_d'[r_k; r_b] : (S_k, S_b))\\
%     \cdots
%   \end{gather*}
% \end{definition}

% \begin{claim}[well-typing preservation]
%   Reduction on labelled notation typings preserve the well-typed proof. That is,
%   $$
%   \forall e \forall \Gamma, \mathcal{WF}(\Gamma) \vdash (e : (S_k, S_b)) \to (e' : (S_k, S_b)),
%   $$
%   and
%   $$
%   \mathcal{WF}(\Gamma) \vdash e : (S_k, S_b)\ \textrm{and}\ \mathcal{WF}(\Gamma) \vdash (e : (S_k, S_b)) \to (e' : (S_k, S_b))\ \textrm{imples}\ \mathcal{WF}(\Gamma) \vdash e' : (S_k, S_b).
%   $$
% \end{claim}


\section{Modularising Dirac Notation by Category}
In consideration of the complicated depnedency of different parts of the Dirac notation theory, expressing it in a modularised manner makes it more clear, organized and easy to extend. In Coq, the implementations follow this design by \textit{Module} and \textit{Module Types}. We can speak in category theory for the same purpose in theory developement.

% \begin{definition}[SpaceType]
%   \textsf{SpaceType} is a category. Its objects are lambda calculi with dependent types, where two special constants are defined:
%   \begin{itemize}
%     \item $\texttt{prod} : \texttt{Type} \to \texttt{Type} \to \texttt{Type}.$
%     \item $\texttt{pair} : (A : \texttt{Type}) \to (B : \texttt{Type}) \to \texttt{prod}\ A\ B.$
%   \end{itemize} 
%   Morphisms exist from the calculi to more expressive ones.
% \end{definition}
% The product and pair is necessary because we will consider tensor product in the linear algebra.

% More complicated module instances, such as those with tuples, can also be considered as objects in \textsf{SpaceType}.

% \begin{definition}[Field]
%   \textsf{Field} is a category. Its objects are algebras containing \textbf{field} as a subalgebra. Morphisms exist from algebras to more expressive ones.  
% \end{definition}

% \begin{definition}[LinAlg]
%   \textsf{LinAlg} is a category. Its objects are lambda calculi with dependent types containing the following constants:
%   \begin{itemize}
%     \item an extra sort $\texttt{SType} : \texttt{Type}$,
%     \item $\mathbb{F} : \texttt{Type}$
%     \item $\texttt{WT\_Vec} : \texttt{SType} \to \texttt{Type}$,
%     \item $\texttt{WT\_LOpt} : \texttt{SType} \to \texttt{SType} \to \texttt{Type}$,
%     \item $\texttt{VecTerm} : (T : \texttt{SType}) \to (t : T) \to \texttt{WF\_Vec}\ T$,
%     \item $\texttt{VecScale} : (T : \texttt{SType}) \to \mathbb{F} \to \texttt{WF\_Vec}\ T \to \texttt{WF\_Vec}\ T$,
%     \item (more constructors on vectors ... )
%     \item $\texttt{LOptElement} : (T_1\ T_2 : \texttt{SType}) \to \texttt{WT\_Vec}\ T_1 \to \texttt{WT\_Vec}\ T_2 \to \texttt{WT\_LOpt}\ T_1\ T_2$,
%   \end{itemize}

% \end{definition}




\section{About Big Operators and Lambda Calculus}
I believe the two vital considerations for big operators are \textbf{lambda calculus} and \textbf{set syntax}. We have to include lambda calculus, because the expression for big operators are essentially functions. And for sets with certain syntax, it is possible to design a complete term rewriting system.

Assume the index of big operator has type $T$, then a set of index values can be considered as functions of $T \to \texttt{bool}$.

\begin{example}[big-op lifting]
  We can consider how to extend a term rewriting system $R$ with big operators.

  \begin{enumerate}
    \item Consider a simply typed lambda calculus, where functions in $R$ appear as constants in the calculus.
    \item Pick out an associative bineary function symbol $+$.
    \item Pick out the neuteral element so that $0 + a \to a$.
    \item Define the type $T$ as type of indices.
    \item Define the type $\texttt{set} : T \to \texttt{Type}$ as the sets.
    \item The big operator is a constant $\sum : \texttt{set}\ T \to (T \to U) \to U$, where $U$ is the type of the big operator expression.
  \end{enumerate}
\end{example}


\begin{example}
  Assume sets are constructed by enumerating $T$ terms, then the syntax with big operators is still decidable.
\end{example}

May be the sets of integer intervals $[m, n]$ are worth considering. But I don't believe it can be decidable in more general cases.


\section{Tuple, Variable Index and Separation Logic}

\subsection{Motivating example}

Consider the notation:
$$
\texttt{CX}[a[i], a[j]] = \texttt{H}[a[j]]\ \texttt{CZ}[a[i], a[j]]\ \texttt{H}[a[j]]
$$
where $a$ is a quantum tuple register. The equality seems to hold, but here is a precondition: $i \neq j$. Otherwise, the Dirac notation is not even well-typed. 

Because we only consider well-typed Dirac notations, we use separation logic to deal with these precondition on well-typed proofs.