%
%            Entiers relatifs, systeme confluent avec 
%            - addition
%            - soustraction, oppose
%            - multiplication
%            - pgcd
%
operators
  x,y,z,u,v,w : variable

operators
%constructeurs
  0 : constant
  1_z,j_z,0_z : postfix unary

% equations entre constructeurs
axioms
 (0)0_z = 0 ;

% addition
operators 
  + : AC

theory ACU(+,0)
unification theory ACU(+,0)

axioms
%  x + 0 = x ;
  (x)0_z + (y)0_z = (x + y)0_z ;
  (x)0_z + (y)1_z = (x + y)1_z ;
  (x)0_z + (y)j_z = (x + y)j_z ;
  (x)1_z + (y)1_z = (x + y + (0)1_z)j_z ;
  (x)j_z + (y)j_z = (x + y + (0)j_z)1_z ;
  (x)1_z + (y)j_z = (x + y)0_z ;

% negative and minus
operators
  - : infix binary
  neg : unary
axioms
  neg(0) = 0 ;
  neg((x)0_z) = (neg(x))0_z ;
  neg((x)1_z) = (neg(x))j_z ;
  neg((x)j_z) = (neg(x))1_z ;
  x - y = x + neg(y) ;

% multiplication
operators 
  . : AC

axioms
  x . 0 = 0 ;
  x . (y)0_z = (x.y)0_z ;
  x . (y)1_z = (x.y)0_z + x ;
  x . (y)j_z = (x.y)0_z + neg(x) ;

% valeur absolue
operators 
  abs : unary
  test_abs : 3
axioms
  abs(x) = test_abs(x,x,0);

  test_abs((x)0_z,y,z) = test_abs(x,y,z);
  test_abs((x)1_z,y,z) = test_abs(x,y,(0)1_z);
  test_abs((x)j_z,y,z) = test_abs(x,y,(0)j_z);

  test_abs(0,x,0) = 0;
  test_abs(0,x,(0)1_z) = x;
  test_abs(0,x,(0)j_z) = neg(x);

% signe
operators 
  signe : unary
  test_signe : binary
axioms
  signe(x) = test_signe(x,0);

  test_signe(0,x) = x;
  test_signe((x)0_z,y) = test_signe(x,y);
  test_signe((x)1_z,y) = test_signe(x,(0)1_z);
  test_signe((x)j_z,y) = test_signe(x,(0)j_z);

% min(x,y) = celui de x ou y qui a la plus petite valeur absolue
operators 
  min,min',min'' : binary
  test_min : 4
axioms
%  min(x,y) = test_min_pos(neg(test_abs_pos(x,x)) + test_abs_pos(y,y),x,y);

  min(x,y) = test_min(abs(y)-abs(x),x,y,0);
  min'(x,y) = test_min(abs((y)1_z)-abs((x)1_z),x,y,0);
  min''(x,y) = test_min(abs((y)j_z)-abs((x)j_z),x,y,0);

  test_min((x)0_z,y,z,u) = test_min(x,y,z,u);
  test_min((x)1_z,y,z,u) = test_min(x,y,z,(0)1_z);
  test_min((x)j_z,y,z,u) = test_min(x,y,z,(0)j_z);

  test_min(0,x,y,0) = x;
  test_min(0,x,y,(0)1_z) = x;
  test_min(0,x,y,(0)j_z) = y;


% f(x,y) = x/pgcd(x,y)
operators 
  f : binary
axioms
  f(0,x) = 0;
  f(x,0) = signe(x);

  f((x)0_z,(y)0_z) = f(x,y);
  f((x)0_z,(y)1_z) = (f(x,(y)1_z))0_z;
  f((x)0_z,(y)j_z) = (f(x,(y)j_z))0_z;

  f((x)1_z,(y)0_z) = f((x)1_z,y);

  f((x)1_z,(y)1_z) =
    (f(x - min'(x,y), (y)1_z))0_z + f(min((x)1_z,(y)1_z), x - y);

  f((x)1_z,(y)j_z) = 
    (f(x + min''(neg(x),y), (y)j_z))0_z + f(min((x)1_z,(neg(y))1_z), x + y);

  f((x)j_z,(y)0_z) = f((x)j_z,y);

  f((x)j_z,(y)1_z) =
    (f(x + min'(neg(x),y), (y)1_z))0_z + f(min((x)j_z,(neg(y))j_z), x + y);

  f((x)j_z,(y)j_z) =
    (f(x - min''(x,y), (y)j_z))0_z + f(min((x)j_z,(y)j_z), x - y);

operators
  rat, irred : binary
  # : commutative
  * : commutative

axioms

  rat(x,y) = irred(signe(y).f(x,y),signe(y).f(y,x));
 
  irred(x,y) # irred(u,v) = rat((x.v) + (u.y),y.v);

  irred(x,y) * irred(u,v) = rat(x.u,y.v);

%problems

%  reduce rat(0,((0)1_z)j_z);
%  reduce irred((0)1_z,((0)1_z)j_z) * irred((0)1_z,(0)1_z) ;

end

order
semi_interactive(
lexico(
  poly(
[0] = 2 ;
[0_z](x) = x + 1;
[1_z](x) = x + 1;
[j_z](x) = x + 1;
[+](x,y) = x + y - 2;
[neg](x) = x;
[-](x,y) = x + y;
[.](x,y) = x.y - x - y + 2;
[abs](x) = 6.x;
[test_abs](x,y,z) = 3.x + y + z;
[signe](x) = 4.x  ;
[test_signe](x,y) = 2.x + y;
[min](x,y) = 16.x + 16.y;
[min'](x,y) = 20.x + 20.y;
[min''](x,y) = 20.x + 20.y;
[test_min](x,y,z,u) = 3.x + y + z + u;
[f](x,y) = 2);
  poly(
[0] = 2 ;
[0_z](x) = x;
[1_z](x) = x + 1;
[j_z](x) = x + 1;
[+](x,y) = x + y - 2;
[neg](x) = x;
[-](x,y) = x + y - 1;
[.](x,y) = x.y;
[f](x,y) = 2);
  poly(
[0] = 2 ;
[0_z](x) = x + 1;
[1_z](x) = x + 1;
[j_z](x) = x + 1;
[+](x,y) = x + y - 2;
[neg](x) = 2.x;
[-](x,y) = x + y - 1;
[.](x,y) = x.y;
[f](x,y) = 2)))





