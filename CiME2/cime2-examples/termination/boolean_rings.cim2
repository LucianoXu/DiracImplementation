(*
Full theory of booleans.
(Hsiang, 82), (Ben Cherifa & Lescanne, 87, p. 152), (Hsiang &
Dershowitz, 83), (Dershowitz 87, p. 102), (Steinbach 91, Example 8.5)
*)

let F = signature "
T,F : constant ;
and,xor,impl,or,equiv : binary ;
neg : unary ;
";

let X = vars "x y z";

let booleans = TRS F X "
xor(x, F) -> x ;
xor(x, neg(x)) -> F ;
and(x, T) -> x ;
and(x, F) -> F ;
and(x, x) -> x ;
and(xor(x, y), z) -> xor(and(x, z), and(y, z)) ;
xor(x, x) -> F ;
impl(x, y) -> xor(and(x, y), xor(x, T)) ;
or(x, y) -> xor(and(x, y), xor(x, y)) ;
equiv(x, y) -> xor(x, xor(y, T)) ;
neg(x) -> xor(x, T) ;
";

#time;

termination booleans;

#time;

(*

the same, but with AC symbols

*)

let F_AC = signature "
T,F : constant ;
and,xor,or : prefix AC ;
impl,equiv : binary ;
neg : unary ;
";

let booleans_AC = TRS F_AC X "
xor(x, F) -> x ;
xor(x, neg(x)) -> F ;
and(x, T) -> x ;
and(x, F) -> F ;
and(x, x) -> x ;
and(xor(x, y), z) -> xor(and(x, z), and(y, z)) ;
xor(x, x) -> F ;
impl(x, y) -> xor(and(x, y), xor(x, T)) ;
or(x, y) -> xor(and(x, y), xor(x, y)) ;
equiv(x, y) -> xor(x, xor(y, T)) ;
neg(x) -> xor(x, T) ;
";

#time;

termination booleans_AC;

#time;

