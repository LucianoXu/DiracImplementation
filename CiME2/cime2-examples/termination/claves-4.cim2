let F = signature "
member_out, nil, reach_out : constant;
delete_out, member1_in, member1_out : unary;
cons, delete_in, member_in : binary;
U'''1 : 3;
U''''1, U''1, reach_in : 4;
U'1, U1 : 5;
U'2, U'3 : 6;
U'4 : 7;
";

let X = vars "X Y E L Z V1 H T1 T2";

let R = TRS F X "
reach_in(X, Y, E, L) -> U1(member_in(cons(X, cons(Y, nil)), E), X, Y, E, L);
U1(member_out, X, Y, E, L) -> reach_out;
reach_in(X, Z, E, L) -> U'1(member1_in(E), X, Z, E, L);
U'1(member1_out(cons(X, cons(Y, nil))), X, Z, E, L) -> U'2(member_in(Y, L), X, Z, E, L, Y);
U'2(member_out, X, Z, E, L, Y) -> U'3(delete_in(Y, L), X, Z, E, L, Y);
U'3(delete_out(V1), X, Z, E, L, Y) -> U'4(reach_in(Y, Z, E, V1), X, Z, E, L, Y, V1);
U'4(reach_out, X, Z, E, L, Y, V1) -> reach_out;
member_in(H, cons(H, L)) -> member_out;
member_in(X, cons(H, L)) -> U''1(member_in(X, L), X, H, L);
U''1(member_out, X, H, L) -> member_out;
member1_in(cons(H, L)) -> member1_out(H);
member1_in(cons(H, L)) -> U'''1(member1_in(L), H, L);
U'''1(member1_out(X), H, L) -> member1_out(X);
delete_in(X, cons(X, Y)) -> delete_out(Y);
delete_in(X, cons(H, T1)) -> U''''1(delete_in(X, T1), X, H, T1);
U''''1(delete_out(T2), X, H, T1) -> delete_out(cons(H, T2));
";

termcrit "dp";
termpolybound 1;
#time on;
termination R;
