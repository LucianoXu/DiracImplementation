let F_BOOL = signature " 
  isBool : 1 ;
  or_bool, and_bool : 2;
  if_bool : 3;
  True, False : 0;
  ";

let X_BOOL = vars "x y z";

let R_BOOL = HTRS {} F_BOOL X_BOOL "
  isBool(True) -> True ;
  isBool(False) -> True; 
  if_bool(True,x,y) -> x;
  if_bool(False,x,y) -> y; 
  or_bool(x,True) -> True;
  or_bool(x,False) -> x;
  or_bool(True,x) -> True;
  or_bool(False,x) -> x;
  and_bool(True,x) -> x;
  and_bool(False,x) -> False;
  and_bool(x,True) -> x;
  and_bool(x,False) -> False;
";  

(*
  fmod PEANO-NAT is
    sorts Nat NzNat .
    subsorts NzNat < Nat .
    op 0 : -> Nat .
    ops 1 2 3 4 5 6 7 : -> NzNat .
    op s_ : Nat -> NzNat .
    op p_ : NzNat -> Nat .
    op _+_ : Nat Nat -> Nat [comm] .
    op _*_ : Nat Nat -> Nat [comm] .
    op _*_ : NzNat NzNat -> NzNat [comm] .
    op _>_ : Nat Nat -> Bool .
    op _<_ : Nat Nat -> Bool .
    op d : Nat Nat -> Nat [comm] .
    op quot : Nat NzNat -> Nat .
    op gcd : Nat Nat -> Nat [comm] .
    op gcd : NzNat NzNat -> NzNat [comm] .
    vars N M : Nat .  
    vars N' M' : NzNat .
    eq p s N = N .
    eq N + 0 = N .
    eq (s N) + (s M) = s s (N + M) .
    eq N * 0 = 0 .
    eq (s N) * (s M) = s (N + (M + (N * M))) .
    eq 0 > M = false .
    eq N' > 0 = true .
    eq s N > s M = N > M .
    eq N < M = M > N .
    eq d(0,N) = N .
    eq d(s N, s M) = d(N,M) .
    ceq quot(N,M') = s quot(d(N,M'),M') if N > M' .
    eq quot(M',M') = s 0 .
    ceq quot(N,M') = 0 if M' > N .
    eq gcd(0,N) = 0 .
    eq gcd(N',N') = N' .
    ceq gcd(N',M') =  gcd(d(N',M'),M') if N' > M' .
    eq 1 = s 0 .
    eq 2 = s s 0 .
    eq 3 = s s s 0 .
    eq 4 = s s s s 0 .
    eq 5 = s s s s s 0 .
    eq 6 = s s s s s s 0 .
    eq 7 = s s s s s s s 0 .
   endfm
*)

let F_PEANO_NAT = signature "
(*
    sorts Nat NzNat .
*)
    isNat,isNzNat : 1;
(*
    subsorts NzNat < Nat .
*)
    u1 : 1;
(*
    op 0 : -> Nat .
*)
    0 : 0;
(*
    ops 1 2 3 4 5 6 7 : -> NzNat .
*)
    1,2,3,4,5,6,7 : 0;
(*
    op s_ : Nat -> NzNat .
*)
    s : 1; u2 : 1;
(*
    op p_ : NzNat -> Nat .
*)
    p : 1; u3 : 1;
(*
    op _+_ : Nat Nat -> Nat [comm] .
*)
    + : infix commutative;
    u4 : 2 ; u5 : 1;
(*
    op _*_ : Nat Nat -> Nat [comm] .
    op _*_ : NzNat NzNat -> NzNat [comm] .
*)
(*
    op _>_ : Nat Nat -> Bool .
*)
    gt : infix 2;
    u10 : 2 ; u11 : 1;
(*
    op _<_ : Nat Nat -> Bool .
*)
(*
    op d : Nat Nat -> Nat [comm] .
*)
    d : commutative;
    u20 : 2 ; u21 : 1;
(*
    op quot : Nat NzNat -> Nat .
*)
    quot : 2;
    u22 : 2 ; u23 : 1;
(*
    op gcd : Nat Nat -> Nat [comm] .
    op gcd : NzNat NzNat -> NzNat [comm] .
*)
(*
    vars N M : Nat .  
    vars N' M' : NzNat .
*)
(*
    eq p s N = N .
*)
    u50 : 2;
(*
    eq N + 0 = N .
*)
    u51 : 2 ;
(*
    eq (s N) + (s M) = s s (N + M) .
*)
    u52,u53 : 3;
(*
    eq N * 0 = 0 .
    eq (s N) * (s M) = s (N + (M + (N * M))) .
*)
(*
    eq 0 > M = false .
*)
    u60 : 1;
(*
    eq N' > 0 = true .
*)
    u61 : 1;
(*
    eq s N > s M = N > M .
*)
    u62,u63 : 3;
(*
    eq N < M = M > N .
*)
(*
    eq d(0,N) = N .
*)
    u70 : 2; u71 : 1;
(*
    eq d(s N, s M) = d(N,M) .
*)
    u72,u73 : 3;
(*
    ceq quot(N,M') = s quot(d(N,M'),M') if N > M' .
*)
    u74,u75 :3;
(*
    eq quot(M',M') = s 0 .
*)
    u76 : 1;
(*
    ceq quot(N,M') = 0 if M' > N .
*)
    u77 : 2; u78 : 1;
(*
    eq gcd(0,N) = 0 .
    eq gcd(N',N') = N' .
    ceq gcd(N',M') =  gcd(d(N',M'),M') if N' > M' .
    eq 1 = s 0 .
    eq 2 = s s 0 .
    eq 3 = s s s 0 .
    eq 4 = s s s s 0 .
    eq 5 = s s s s s 0 .
    eq 6 = s s s s s s 0 .
    eq 7 = s s s s s s s 0 .
*)
";


(*
    vars N M : Nat .  
    vars N' M' : NzNat .
*)
let X_PEANO_NAT = vars "x y N M N' M'";


let R_PEANO_NAT = HTRS {R_BOOL} F_PEANO_NAT X_PEANO_NAT "
(*
    sorts Nat NzNat .
    subsorts NzNat < Nat .
    isNat(x) -> True if isNzNat(x) -> true;
*)
    isNat(x) -> u1(isNzNat(x));
    u1(True) -> True;
(*
    op 0 : -> Nat .
*)
    isNat(0) -> True ;
(*
    ops 1 2 3 4 5 6 7 : -> NzNat .
*)
    isNzNat(1) -> True ;
    isNzNat(2) -> True ;
    isNzNat(3) -> True ;
    isNzNat(4) -> True ;
    isNzNat(5) -> True ;
    isNzNat(6) -> True ;
    isNzNat(7) -> True ;
(*
    op s_ : Nat -> NzNat .
    isNzNat(s(x)) -> True if isNat(x) -> True    
*)
    isNzNat(s(x)) -> u2(isNat(x));
    u2(True) -> True;
(*
    op p_ : NzNat -> Nat .
    isNat(p(x)) -> True if isNzNat(x) -> True 
*)
    isNat(p(x)) -> u3(isNzNat(x));
    u3(True) -> True;
(*
    op _+_ : Nat Nat -> Nat [comm] .
    isNat(x+y) -> True if isNat(x) -> True, isNat(y) -> True;
*)
    isNat(x+y) -> u4(isNat(x),y) ;
    u4(True,y) -> u5(isNat(y)) ;
    u5(True) -> True;
(*
    op _*_ : Nat Nat -> Nat [comm] .
    op _*_ : NzNat NzNat -> NzNat [comm] .
*)
(*
    op _>_ : Nat Nat -> Bool .
    isBool(x gt y) -> True if isNat(x) -> True, isNat(y) -> True;
*)
   (*
   overrides isBool!
   isBool(x gt y) -> ...
   *)
(*
    op _<_ : Nat Nat -> Bool .
*)
(*
    op d : Nat Nat -> Nat [comm] .
*)
    isNat(x gt y) -> u20(isNat(x),y);
    u20(True,y) -> u21(isNat(y));
    u21(True) -> True;
(*
    op quot : Nat NzNat -> Nat .
*)
(*
    isNat(quot(x,y)) -> u22(isNat(x),y);
    u22(True,y) -> u23(isNzNat(y));
    u23(True) -> True;
*)
(*
    op gcd : Nat Nat -> Nat [comm] .
    op gcd : NzNat NzNat -> NzNat [comm] .
    vars N M : Nat .  
    vars N' M' : NzNat .
*)
(*
    eq p s N = N .
    p(s(N)) -> N if isNat(N) -> True;
*)
    p(s(N)) -> u50(isNat(N),N);
    u50(True,N) -> N;
(*
    eq N + 0 = N .
    N+0 -> N if isNat(N) -> True;
*)
    N+0 -> u51(isNat(N),N);
    u51(True,N) -> N;
(*
    eq (s N) + (s M) = s s (N + M) .
    (s N) + (s M) -> s s (N + M) if isNat(N) -> True, isNat(M) -> True;
*)
    (s N) + (s M) -> u52(isNat(N),N,M) ;
    u52(True,N,M) -> u53(isNat(M),N,M) ;
    u53(True,N,M) -> s s (N + M) ;
(*
    eq N * 0 = 0 .
    eq (s N) * (s M) = s (N + (M + (N * M))) .
*)
(*
    eq 0 > M = false .
*)
    0 gt M -> u60(isNat(M)) ;
    u60(True) -> False;
(*
    eq N' > 0 = true .
*)
    N' gt 0 -> u61(isNzNat(N'));
    u61(True) -> True;
(*
    eq s N > s M = N > M .
*)
    s N gt s M -> u62(isNat(N),N,M);
    u62(True,N,M) -> u63(isNat(M),N,M);
    u63(True,N,M) -> N gt M;
(*
    eq N < M = M > N .
*)
(*
    eq d(0,N) = N .
*)
    d(0,N) -> u70(isNat(N),N);
    u70(True,N) -> N;    
(*
    eq d(s N, s M) = d(N,M) .
*)
    d(s N, s M) -> u72(isNat(N),N,M);
    u72(True,N,M) -> u73(isNat(M),N,M);
    u73(True,N,M) -> d(N,M) ;

(*
    ceq quot(N,M') = s quot(d(N,M'),M') if N > M' .
*)
    quot(N,M') -> u74(isNat(N),N,M');
    u74(True,N,M') -> u75(isNzNat(M'),N,M');
    u75(True,N,M') -> s quot(d(N,M'),M');
(*
    eq quot(M',M') = s 0 .
*)
    quot(M',M') -> u76(isNzNat(M'));
    u76(True) -> s 0;
(*
    ceq quot(N,M') = 0 if M' > N .
*)
    quot(N,M') -> u77(isNat(N),M');
    u77(True,M') -> u78(isNzNat(M'));
    u78(True) -> 0;
(*
    eq gcd(0,N) = 0 .
    eq gcd(N',N') = N' .
    ceq gcd(N',M') =  gcd(d(N',M'),M') if N' > M' .
    eq 1 = s 0 .
    eq 2 = s s 0 .
    eq 3 = s s s 0 .
    eq 4 = s s s s 0 .
    eq 5 = s s s s s 0 .
    eq 6 = s s s s s s 0 .
    eq 7 = s s s s s s s 0 .
   endfm
*)

  ";

termcrit "minimal";
polyinterpkind {("linear", 2); ("simple",6)};
#time on;
h_termination R_PEANO_NAT;
(* output_last_proof "";*)
(* ok in 0.26s *)






