
(* 

Sequent calculus modulo, by Éric Deplagne 
   (based on ESSLLI student session 2000)

*)

let F = signature "
  ef : unary ;
  Pe : unary;
  1 : constant;
  id : constant;
  shift : constant;
  . : infix binary;
  ron : infix binary;
  substt : infix binary;
  convaf : unary;
  neg : unary;
  and : infix binary;
  or : infix  binary;
  imp : infix binary;
  forall : unary;
  exists : unary;
  substf : infix binary;
  emptyfset : constant;
  convf : unary;
  virg : AC;
  emptysset : constant;
  convs : unary;
  sequent : infix binary;
  * : AC ;
";

let X = vars "x y s t u f g a b";


let R = HTRS {} F X "
  ef(x) substt y -> ef(x substt y);
  Pe(x) substf y -> Pe(x substt y);

  neg(f) substf s -> neg(f substf s);
  (f and g) substf s -> (f substf s) and (g substf s);
  (f or g) substf s -> (f substf s) or (g substf s);
  (f imp g) substf s -> (f substf s) imp (g substf s);

  forall(f) substf s -> forall(f substf (1.(s ron shift)));
  exists(f) substf s -> exists(f substf (1.(s ron shift)));

  x substt id -> x;
  f substf id -> f;
  (x substt s) substt t -> x substt (s ron t);
  (f substf s) substf t -> f substf (s ron t);

  1 substt (x.s) -> x;

  id ron s -> s;
  shift ron (x.s) -> s;
  (s ron t) ron u -> s ron (t ron u);
  (x.s) ron t -> (x substt t).(s ron t);
  s ron id -> s;
  1.shift -> id;
  (1 substt s).(shift ron s) -> s;

  a virg emptyfset -> a;
  a virg a -> a;
  a*emptysset -> a;

  a*a -> a;

  neg(neg(f)) -> f;
  f and f -> f;
  f or f -> f;
  f imp g -> neg(f) or g;
  exists(f) -> neg(forall(neg(f)));

  (a virg convf(neg(f))) sequent b -> a sequent (convf(f) virg b);
  convf(neg(f)) sequent b -> emptyfset sequent (b virg convf(f));

  a sequent (convf(neg(f)) virg b) -> (a virg convf(f)) sequent b;
  a sequent convf(neg(f)) -> (a virg convf(f)) sequent emptyfset;

  (a virg convf(f and g)) sequent b -> 
  (a virg convf(f) virg convf(g)) sequent b;
  convf(f and g) sequent b -> (convf(f) virg convf(g)) sequent b;

  a sequent (convf(f or g) virg b) -> 
  a sequent (convf(f) virg convf(g) virg b);
  a sequent convf(f or g) -> a sequent (convf(f) virg convf(g));

  convs(a sequent (convf(f and g) virg b)) -> 
  convs(a sequent (convf(f) virg b))*convs(a sequent (convf(g) virg b));
  convs(a sequent convf(f and g)) -> 
  convs(a sequent convf(f))*convs(a sequent convf(g));

  convs((a virg convf(f or g)) sequent b) -> 
  convs((a virg convf(f)) sequent b)*convs((a virg convf(g)) sequent b);
  convs(convf(f or g) sequent b) -> 
  convs(convf(f) sequent b)*convs(convf(g) sequent b);

  convs((a virg convf(f)) sequent (convf(f) virg b)) -> emptysset;
  convs((a virg convf(f)) sequent convf(f)) -> emptysset;
  convs(convf(f) sequent (b virg convf(f))) -> emptysset;
  convs(convf(f) sequent convf(f)) -> emptysset;

  convs(a sequent b)*convs((a virg f) sequent (g virg b)) -> 
  convs(a sequent b);
  convs(a sequent b)*convs((a virg f) sequent b) -> convs(a sequent b);
  convs(a sequent b)*convs(a sequent (b virg f)) -> convs(a sequent b);
  convs(a sequent emptyfset)*convs((a virg f) sequent b) -> 
  convs(a sequent emptyfset);
  convs(a sequent (b virg f))*convs(emptyfset sequent b) -> 
  convs(emptyfset sequent b);
  convs(a sequent b)*convs(emptyfset sequent b) -> 
  convs(emptyfset sequent b);
  convs(a sequent b)*convs(a sequent emptyfset) -> 
  convs(a sequent emptyfset);
  convs(a sequent b)*convs(emptyfset sequent emptyfset) -> 
  convs(emptyfset sequent emptyfset);

";


(* Without minimal decomposition. ----------------------------*)

(* Without marks (requires more than 7400s on a PIII-933MHz running linux) *)
(*termcrit "nomarks"; polyinterpkind "simple"; termpolybound 3;
#time;
h_termination R; *)

(* With marks (requires about 132s on a PIII-933MHz running linux) *)
(*termcrit "marks"; polyinterpkind "simple"; termpolybound 3;
#time;
h_termination R; *)


(* Minimal modular decomposition. ----------------------------*)
termcrit "minimal";

(* For this system we do not need marks. *)
termcrit "nomarks";
(* Simple interpretations are required. *)
(* A maximal bound of 3 is enough. *)
polyinterpkind { ("simple",3) };


#time;
h_termination R;

(* Slightly better with a little tuning... *)
(* Requires about 8s. *)
polyinterpkind {("simple",2);("simple",3)};
h_termination R;

#quit;


