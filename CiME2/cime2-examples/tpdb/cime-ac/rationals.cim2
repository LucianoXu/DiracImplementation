(*

  Evelyne Contejean, Claude Marché, Landy Rabehasaina, RTA'97

  AC rewrite system for addition and multiplication of rational
  numbers, in ternary representation

  (Currently fails with CiME)

*)
[v, u, z, y, x]

AC [*, +]

comm [*_Q, +_Q]

0(#) -> # ;
+(#,x) -> x ;
+(0(x),0(y)) -> 0(+(x,y)) ;
+(0(x),1(y)) -> 1(+(x,y)) ;
+(0(x),j(y)) -> j(+(x,y)) ;
+(1(x),1(y)) -> j(+(1(#),+(x,y))) ;
+(j(x),j(y)) -> 1(+(j(#),+(x,y))) ;
+(1(x),j(y)) -> 0(+(x,y)) ;
opp(#) -> # ;
opp(0(x)) -> 0(opp(x)) ;
opp(1(x)) -> j(opp(x)) ;
opp(j(x)) -> 1(opp(x)) ;
-(x,y) -> +(opp(y),x) ;
*(#,x) -> # ;
*(0(x),y) -> 0(*(x,y)) ;
*(1(x),y) -> +(0(*(x,y)),y) ;
*(j(x),y) -> -(0(*(x,y)),y) ;
abs(x) -> test_abs_pos(x,x) ;
test_abs_pos(#,x) -> x ;
test_abs_pos(0(x),y) -> test_abs_pos(x,y) ;
test_abs_pos(1(x),y) -> test_abs_pos(x,y) ;
test_abs_pos(j(x),y) -> test_abs_neg(x,y) ;
test_abs_neg(#,x) -> opp(x) ;
test_abs_neg(0(x),y) -> test_abs_neg(x,y) ;
test_abs_neg(1(x),y) -> test_abs_pos(x,y) ;
test_abs_neg(j(x),y) -> test_abs_neg(x,y) ;
signe(#) -> # ;
signe(0(x)) -> signe(x) ;
signe(1(x)) -> test_signe_pos(x) ;
signe(j(x)) -> test_signe_neg(x) ;
test_signe_pos(#) -> 1(#) ;
test_signe_pos(0(x)) -> test_signe_pos(x) ;
test_signe_pos(1(x)) -> test_signe_pos(x) ;
test_signe_pos(j(x)) -> test_signe_neg(x) ;
test_signe_neg(#) -> j(#) ;
test_signe_neg(0(x)) -> test_signe_neg(x) ;
test_signe_neg(1(x)) -> test_signe_pos(x) ;
test_signe_neg(j(x)) -> test_signe_neg(x) ;
min(x,y) -> test_min_pos(-(abs(y),abs(x)),x,y) ;
min'(x,y) -> test_min_pos(-(abs(1(y)),abs(1(x))),x,y) ;
min''(x,y) -> test_min_pos(-(abs(j(y)),abs(j(x))),x,y) ;
test_min_pos(#,x,y) -> x ;
test_min_pos(0(x),y,z) -> test_min_pos(x,y,z) ;
test_min_pos(1(x),y,z) -> test_min_pos(x,y,z) ;
test_min_pos(j(x),y,z) -> test_min_neg(x,y,z) ;
test_min_neg(#,x,y) -> y ;
test_min_neg(0(x),y,z) -> test_min_neg(x,y,z) ;
test_min_neg(1(x),y,z) -> test_min_pos(x,y,z) ;
test_min_neg(j(x),y,z) -> test_min_neg(x,y,z) ;
f(#,x) -> # ;
f(x,#) -> signe(x) ;
f(0(x),0(y)) -> f(x,y) ;
f(0(x),1(y)) -> 0(f(x,1(y))) ;
f(0(x),j(y)) -> 0(f(x,j(y))) ;
f(1(x),0(y)) -> f(1(x),y) ;
f(1(x),1(y)) -> +(0(f(-(x,min'(x,y)),1(y))),f(min(1(x),1(y)),-(x,y))) ;
f(1(x),j(y)) ->
+(0(f(+(min''(opp(x),y),x),j(y))),f(min(1(x),1(opp(y))),+(x,y))) ;
f(j(x),0(y)) -> f(j(x),y) ;
f(j(x),1(y)) ->
+(0(f(+(min'(opp(x),y),x),1(y))),f(min(j(x),j(opp(y))),+(x,y))) ;
f(j(x),j(y)) -> +(0(f(-(x,min''(x,y)),j(y))),f(min(j(x),j(y)),-(x,y))) ;
rat(x,y) -> irred(*(signe(y),f(x,y)),*(signe(y),f(y,x))) ;
+_Q(irred(x,y),irred(u,v)) -> irred(+(*(x,v),*(y,u)),*(y,v)) ;
*_Q(irred(x,y),irred(u,v)) -> rat(*(x,u),*(y,v)) ;

(*

let F = signature "
     # : constant;
     0 , 1 , j : postfix unary;
     opp : unary;
     - : infix binary;
     + , * : AC;
     abs : unary ;
     test_abs_pos, test_abs_neg : binary;
     signe, test_signe_pos, test_signe_neg : unary;
     min,min',min'' : binary ;
     test_min_pos, test_min_neg : 3 ;
     f : binary ;
     rat, irred : binary ;
     +_Q : infix commutative ;
     *_Q : infix commutative ;
";

let X = vars "x y z u v";

let R = HTRS {} F X "
     (#)0 -> #;
     # + x -> x;
     (x)0 + (y)0 -> (x+y)0;
     (x)0 + (y)1 -> (x+y)1;
     (x)0 + (y)j -> (x+y)j;
     (x)1 + (y)1 -> (x+y+(#)1)j;
     (x)j + (y)j -> (x+y+(#)j)1;
     (x)1 + (y)j -> (x+y)0;
     opp(#) -> # ;
     opp((x)0) -> (opp(x))0 ;
     opp((x)1) -> (opp(x))j ;
     opp((x)j) -> (opp(x))1 ;
     x - y -> x+opp(y) ;
     # * x -> #;
     (x)0 * y -> (x*y)0;
     (x)1 * y -> (x*y)0 + y;
     (x)j * y -> (x*y)0 - y;
     abs(x) -> test_abs_pos(x,x);
  test_abs_pos(#,x) -> x;
  test_abs_pos((x)0,y) -> test_abs_pos(x,y);
  test_abs_pos((x)1,y) -> test_abs_pos(x,y);
  test_abs_pos((x)j,y) -> test_abs_neg(x,y);
  test_abs_neg(#,x) -> opp(x);
  test_abs_neg((x)0,y) -> test_abs_neg(x,y);
  test_abs_neg((x)1,y) -> test_abs_pos(x,y);
  test_abs_neg((x)j,y) -> test_abs_neg(x,y);
  signe(#) -> #;
  signe((x)0) -> signe(x);
  signe((x)1) -> test_signe_pos(x);
  signe((x)j) -> test_signe_neg(x);
  test_signe_pos(#) -> (#)1;
  test_signe_pos((x)0) -> test_signe_pos(x);
  test_signe_pos((x)1) -> test_signe_pos(x);
  test_signe_pos((x)j) -> test_signe_neg(x);
  test_signe_neg(#) -> (#)j;
  test_signe_neg((x)0) -> test_signe_neg(x);
  test_signe_neg((x)1) -> test_signe_pos(x);
  test_signe_neg((x)j) -> test_signe_neg(x);
  min(x,y) -> test_min_pos(abs(y)-abs(x),x,y);
  min'(x,y) -> test_min_pos(abs((y)1)-abs((x)1),x,y);
  min''(x,y) -> test_min_pos(abs((y)j)-abs((x)j),x,y);
  test_min_pos(#,x,y) -> x;
  test_min_pos((x)0,y,z) -> test_min_pos(x,y,z);
  test_min_pos((x)1,y,z) -> test_min_pos(x,y,z);
  test_min_pos((x)j,y,z) -> test_min_neg(x,y,z);
  test_min_neg(#,x,y) -> y;
  test_min_neg((x)0,y,z) -> test_min_neg(x,y,z);
  test_min_neg((x)1,y,z) -> test_min_pos(x,y,z);
  test_min_neg((x)j,y,z) -> test_min_neg(x,y,z);
  f(#,x) -> #;
  f(x,#) -> signe(x);
  f((x)0,(y)0) -> f(x,y);
  f((x)0,(y)1) -> (f(x,(y)1))0;
  f((x)0,(y)j) -> (f(x,(y)j))0;
  f((x)1,(y)0) -> f((x)1,y);
  f((x)1,(y)1) ->
    (f(x - min'(x,y), (y)1))0 + f(min((x)1,(y)1), x - y);
  f((x)1,(y)j) -> 
    (f(x + min''(opp(x),y), (y)j))0 + f(min((x)1,(opp(y))1), x + y);
  f((x)j,(y)0) -> f((x)j,y);
  f((x)j,(y)1) ->
    (f(x + min'(opp(x),y), (y)1))0 + f(min((x)j,(opp(y))j), x + y);
  f((x)j,(y)j) ->
    (f(x - min''(x,y), (y)j))0 + f(min((x)j,(y)j), x - y);
  rat(x,y) -> irred(signe(y)*f(x,y),signe(y)*f(y,x));
  irred(x,y) +_Q irred(u,v) -> irred((x*v) + (u*y),y*v);
  irred(x,y) *_Q irred(u,v) -> rat(x*u,y*v);
";


termcrit "minimal";
termcrit "nomarks";
polyinterpkind { ("linear",1); ("simple",2) };
h_termination R;
output_last_proof "";
export_htrs R;

*)
