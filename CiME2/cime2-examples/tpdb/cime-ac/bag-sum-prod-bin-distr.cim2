(*

  Claude Marché

  Sum and product of a bag of integers

  Binary notation, * distributes over +

*)

[b, z, y, x]

AC [U, *, +]

0(#) -> # ;
+(#,x) -> x ;
+(0(x),0(y)) -> 0(+(x,y)) ;
+(0(x),1(y)) -> 1(+(x,y)) ;
+(1(x),1(y)) -> 0(+(1(#),+(x,y))) ;
*(#,x) -> # ;
*(0(x),y) -> 0(*(x,y)) ;
*(1(x),y) -> +(0(*(x,y)),y) ;
*(+(y,z),x) -> +(*(x,y),*(x,z)) ;
U(empty,b) -> b ;
sum(empty) -> 0(#) ;
sum(singl(x)) -> x ;
sum(U(x,y)) -> +(sum(x),sum(y)) ;
prod(empty) -> 1(#) ;
prod(singl(x)) -> x ;
prod(U(x,y)) -> *(prod(x),prod(y)) ;

(*

let X = vars "x y z l b";


let F = signature "
  #   : constant ; 
  0,1 : postfix unary ;
  + : AC ;
  * : AC ;
  empty : constant ; 
  singl : unary ; 
  U : AC ;
  sum,prod : unary ;
";



let R = HTRS {} F X "
  (#)0 -> #;

  x + # -> x;
  (x)0 + (y)0 -> (x+y)0;
  (x)0 + (y)1 -> (x+y)1;
  (x)1 + (y)1 -> (x+y+(#)1)0;

  x * # -> #;
  (x)0 * y -> (x*y)0;
  (x)1 * y -> (x*y)0 + y;
  x*(y+z) -> (x*y)+(x*z);

  empty U b -> b;

  sum(empty) -> (#)0;
  sum(singl(x)) -> x;
  sum(x U y) -> sum(x) + sum(y);

  prod(empty) -> (#)1;
  prod(singl(x)) -> x;
  prod(x U y) -> prod(x) * prod(y);
";


termcrit "minimal";
termcrit "nomarks";
polyinterpkind {("linear",1);("simple",2)};
h_termination R;
output_last_proof "";


*)

