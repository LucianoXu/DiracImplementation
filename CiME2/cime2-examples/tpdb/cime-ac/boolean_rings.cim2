(*

Full theory of booleans.
(Hsiang, 82), (Ben Cherifa & Lescanne, 87, p. 152), (Hsiang &
Dershowitz, 83), (Dershowitz 87, p. 102), (Steinbach 91, Example 8.5)

*)

[z, y, x]

AC [or, xor, and]

xor(F,x) -> x ;
xor(neg(x),x) -> F ;
and(T,x) -> x ;
and(F,x) -> F ;
and(x,x) -> x ;
and(xor(x,y),z) -> xor(and(x,z),and(y,z)) ;
xor(x,x) -> F ;
impl(x,y) -> xor(and(x,y),xor(T,x)) ;
or(x,y) -> xor(and(x,y),xor(x,y)) ;
equiv(x,y) -> xor(xor(T,y),x) ;
neg(x) -> xor(T,x) ;

(*

let F_AC = signature "
T,F : constant ;
and,xor,or : prefix AC ;
impl,equiv : binary ;
neg : unary ;
";

let X = vars "x y z";

let booleans_AC = HTRS {} F_AC X "
xor(x, F) -> x ;
xor(x, neg(x)) -> F ;
and(x, T) -> x ;
and(x, F) -> F ;
and(x, x) -> x ;
and(xor(x, y), z) -> xor(and(x, z), and(y, z)) ;
xor(x, x) -> F ;
impl(x, y) -> xor(and(x, y), xor(x, T)) ;
or(x, y) -> xor(and(x, y), xor(x, y)) ;
equiv(x, y) -> xor(x, xor(y, T)) ;
neg(x) -> xor(x, T) ;
";

termcrit "minimal";
termcrit "nomarks";
polyinterpkind {("linear",1);("simple",3)};
h_termination booleans_AC;
output_last_proof "";


*)
