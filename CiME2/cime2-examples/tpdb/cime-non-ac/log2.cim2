(*

  Xavier Urbain

  Base 2 logarithm. Integers in binary notation.

*)

[z, y, x]

0(#) -> # ;
+(#,x) -> x ;
+(x,#) -> x ;
+(0(x),0(y)) -> 0(+(x,y)) ;
+(0(x),1(y)) -> 1(+(x,y)) ;
+(1(x),0(y)) -> 1(+(x,y)) ;
+(1(x),1(y)) -> 0(+(+(x,y),1(#))) ;
+(+(x,y),z) -> +(x,+(y,z)) ;
-(#,x) -> # ;
-(x,#) -> x ;
-(0(x),0(y)) -> 0(-(x,y)) ;
-(0(x),1(y)) -> 1(-(-(x,y),1(#))) ;
-(1(x),0(y)) -> 1(-(x,y)) ;
-(1(x),1(y)) -> 0(-(x,y)) ;
not(true) -> false ;
not(false) -> true ;
if(true,x,y) -> x ;
if(false,x,y) -> y ;
ge(0(x),0(y)) -> ge(x,y) ;
ge(0(x),1(y)) -> not(ge(y,x)) ;
ge(1(x),0(y)) -> ge(x,y) ;
ge(1(x),1(y)) -> ge(x,y) ;
ge(x,#) -> true ;
ge(#,0(x)) -> ge(#,x) ;
ge(#,1(x)) -> false ;
log(x) -> -(log'(x),1(#)) ;
log'(#) -> # ;
log'(1(x)) -> +(log'(x),1(#)) ;
log'(0(x)) -> if(ge(x,1(#)),+(log'(x),1(#)),#) ;


(*

let F = signature "
  # : constant ; 
0,1 : postfix unary ;
+,- : infix binary ;
ge : binary ;
true,false : constant ;
not : unary ;
log : unary ;
log' : unary ;
if : 3 ;
";

let X = vars "x y z";

let R = HTRS {} F X "
   (#)0 -> #;

     # + x -> x;
     x + # -> x;
     (x)0 + (y)0 -> (x+y)0;
     (x)0 + (y)1 -> (x+y)1;
     (x)1 + (y)0 -> (x+y)1;
     (x)1 + (y)1 -> (x+y+(#)1)0;
     (x+y)+z -> x+(y+z) ;

    # - x -> #;
     x - # -> x;
     (x)0 - (y)0 -> (x-y)0;
     (x)0 - (y)1 -> ((x-y)-(#)1)1;
     (x)1 - (y)0 -> (x-y)1;
     (x)1 - (y)1 -> (x-y)0;

      not(true) -> false ;
      not(false) -> true ;

  if(true,x,y) -> x;
  if(false,x,y) -> y;

      ge((x)0,(y)0) -> ge(x,y) ;
      ge((x)0,(y)1) -> not(ge(y,x)) ;
      ge((x)1,(y)0) -> ge(x,y) ;
      ge((x)1,(y)1) -> ge(x,y) ;
      ge(x,#) -> true ;
      ge(#,(x)0) -> ge(#,x) ;
      ge(#,(x)1) -> false ;

     log(x) -> log'(x) - (#)1 ;
     log'(#) -> # ;
   log'((x)1) -> log'(x) + (#)1 ;
   log'((x)0) -> if(ge(x,(#)1),log'(x) + (#)1,#);

";



termcrit "minimal";
polyinterpkind {("linear",1);("simple",2)};
h_termination R;
output_last_proof "";
export_htrs R;

*)
