(*

  Claude Marché

  From: J.-C. Filliâtre, S. Owre, H. Rueß, and N. Shankar. Deciding
        propositional combinations of equalities and
	inequalities. http://www.lri.fr/~filliatr/ftp/publis/ics.ps

*)
[t, c, b, a, x, n]

g(A) -> A ;
g(B) -> A ;
g(B) -> B ;
g(C) -> A ;
g(C) -> B ;
g(C) -> C ;
foldB(t,0) -> t ;
foldB(t,s(n)) -> f(foldB(t,n),B) ;
foldC(t,0) -> t ;
foldC(t,s(n)) -> f(foldC(t,n),C) ;
f(t,x) -> f'(t,g(x)) ;
f'(triple(a,b,c),C) -> triple(a,b,s(c)) ;
f'(triple(a,b,c),B) -> f(triple(a,b,c),A) ;
f'(triple(a,b,c),A) -> f''(foldB(triple(s(a),0,c),b)) ;
f''(triple(a,b,c)) -> foldC(triple(a,b,0),c) ;
fold(t,x,0) -> t ;
fold(t,x,s(n)) -> f(fold(t,x,n),x) ;

(*

let F = signature "
A,B,C,0 : constant ;
g,s : unary;
nil : constant ;
cons : binary ;
f : binary ;
triple : 3 ;
fold : 3 ;
foldB,foldC : binary;
f' : binary ;
f'' : unary ; ";

let X = vars "n x y z a b c t";

let R = HTRS {} F X "
g(A) -> A;
g(B) -> A;
g(B) -> B;
g(C) -> A;
g(C) -> B;
g(C) -> C;
foldB(t,0) -> t;
foldB(t,s(n)) -> f(foldB(t,n),B);
foldC(t,0) -> t;
foldC(t,s(n)) -> f(foldC(t,n),C);
f(t,x) -> f'(t,g(x)) ;
f'(triple(a,b,c),C) -> triple(a,b,s(c)) ;
f'(triple(a,b,c),B) -> f(triple(a,b,c),A) ;
f'(triple(a,b,c),A) -> f''(foldB(triple(s(a),0,c),b)) ;
f''(triple(a,b,c)) -> foldC(triple(a,b,0),c) ;
fold(t,x,0) -> t;
fold(t,x,s(n)) -> f(fold(t,x,n),x);
";


termcrit "minimal";
polyinterpkind {("linear",1)};
h_termination R;
output_last_proof "";
export_htrs R;

*)

