(*

  Claude Marché

  Intersection of list of integers.

*)

[l3, l2, l1, l, y, x]

if(true,x,y) -> x ;
if(false,x,y) -> y ;
eq(0,0) -> true ;
eq(0,s(x)) -> false ;
eq(s(x),0) -> false ;
eq(s(x),s(y)) -> eq(x,y) ;
app(nil,l) -> l ;
app(cons(x,l1),l2) -> cons(x,app(l1,l2)) ;
app(app(l1,l2),l3) -> app(l1,app(l2,l3)) ;
mem(x,nil) -> false ;
mem(x,cons(y,l)) -> ifmem(eq(x,y),x,l) ;
ifmem(true,x,l) -> true ;
ifmem(false,x,l) -> mem(x,l) ;
inter(x,nil) -> nil ;
inter(nil,x) -> nil ;
inter(app(l1,l2),l3) -> app(inter(l1,l3),inter(l2,l3)) ;
inter(l1,app(l2,l3)) -> app(inter(l1,l2),inter(l1,l3)) ;
inter(cons(x,l1),l2) -> ifinter(mem(x,l2),x,l1,l2) ;
inter(l1,cons(x,l2)) -> ifinter(mem(x,l1),x,l2,l1) ;
ifinter(true,x,l1,l2) -> cons(x,inter(l1,l2)) ;
ifinter(false,x,l1,l2) -> inter(l1,l2) ;

(*

let F = signature "
  true,false : constant ; if : 3 ;

  0 : constant ;
  s : unary ;
  eq : binary ;

  nil : constant ;
  cons : binary ;
  app : binary ;
  mem : binary ;
  ifmem : 3;

  inter : infix binary;
  ifinter : 4;
";

let X = vars "x y z l l1 l2 l3";

let R = HTRS {} F X "
     if(true,x,y) -> x ;
     if(false,x,y) -> y ;
     eq(0,0) -> true ;
     eq(0,s(x)) -> false ;
     eq(s(x),0) -> false ;
     eq(s(x),s(y)) -> eq(x,y) ;

     app(nil,l) -> l ;
     app(cons(x,l1),l2) -> cons(x,app(l1,l2));
     app(app(l1,l2),l3) -> app(l1,app(l2,l3));

     mem(x,nil) -> false ;
     mem(x,cons(y,l)) -> ifmem(eq(x,y),x,l) ;
     ifmem(true,x,l) -> true ;
     ifmem(false,x,l) -> mem(x,l) ;

     x inter nil -> nil ;
     nil inter x -> nil ;
     app(l1,l2) inter l3 -> app(l1 inter l3,l2 inter l3) ;
     l1 inter app(l2,l3) -> app(l1 inter l2,l1 inter l3) ;

     cons(x,l1) inter l2 -> ifinter(mem(x,l2),x,l1,l2) ;
     l1 inter cons(x,l2) -> ifinter(mem(x,l1),x,l2,l1) ;

     ifinter(true,x,l1,l2) -> cons(x,l1 inter l2) ;
     ifinter(false,x,l1,l2) -> l1 inter l2 ;

";

termcrit "minimal";
polyinterpkind { ("linear",1); ("simple",2) };
h_termination R;
output_last_proof "";
export_htrs R;

*)


     


  
