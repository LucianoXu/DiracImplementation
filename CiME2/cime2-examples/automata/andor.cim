%***************************************************************************
%
% sort
%
% Project:                Cime
% Author(s):             Claude March\'e
%
% File name:        demo5.nc
% Created on:              1 avr 93
% Last modified on: 1 avr 93
%
%***************************************************************************

sort
  bool , int , list
 
operators

% booleens  
  true, false : constant as bool
  and, or : AC as bool -> bool -> bool

  x,y,z : variable as int
  l1,l2,l3 : variable as list
  x1,x2 : variable as bool

theory  
  ACU(or,false)
  ACU(and,true)


axioms

% booleens
  true or x = true;
  false and x = false;  


% listes    
%  mem(x,nil) = false;
%  mem(x,y.z) = (x eq y) or (mem(x,z));
 
%  append(nil,l2) = l2;
%  append(x1.l1,l2) = x1.append(l1,l2);

% tris

order
 rpo( 
%7>6>5>4>3>2>1>s>Z,
%	mem > false,
%        sorted > true,
%	le > true,
%	if_then_else > true,
%	if_then_else > false,
%	insert > . > nil,
%	eq > true,
%	sorting > insert,
%	eq > false,
%	mem > eq,
%	mem > or,
%	sorted > and,
%	sorted > le > false,
%	insert > if_then_else,
%	insert > le
%	is_perm > is_perm_aux > if_then_else,
%	is_perm_aux > append,
%	is_perm_aux > eq,
%	is_perm > nil,
%	append > .;
%	is_perm_aux lrlex
and      )
 % interactive


inductive
  
%  reduce mem(7,1.(2.(x.(3.nil)))) ;
%  reduce mem(7,1.(2.(x.(3.(y.nil))))) ;
%  reduce mem(7,1.(2.(x.(7.(y.nil))))) ;

%  reduce sorting(7.(1.(2.(6.(3.nil)))));
%  reduce sorting(1.(2.(x.(3.nil))));

%  reduce sorted(7.(1.(2.(6.(3.nil)))));
%  reduce sorted(1.(2.(x.(3.nil))));

%  reduce is_perm(1.(2.(3.nil)),3.(2.(1.nil)));

%  reduce is_perm(1.(2.(3.nil)),3.(2.(4.nil)));

%  sorted(sorting(x)) = true;
 
%  sorted(sorting(nil)) = true;

%  sorted(sorting(a)) = true -> sorted(sorting(x.a)) = true;

%  sorted(sorting(x.a)) = true;

%   sorted(sorting(x.nil)) = true  ;

%  sorted(sorting(x.a)) = true -> sorted(sorting(x.(y.a))) = true ;

%  sorted(sorting(a.(b.c))) = true ;

  true = true ;

end

Result:
{ [1] 1 -> s(Z),
  [2] 3 -> s(s(s(Z))),
  [3] 5 -> s(s(s(s(s(Z))))),
  [4] 7 -> s(s(s(s(s(s(s(Z))))))),
  [5] sorted(nil) -> true,
  [6] sorting(nil) -> nil,
  [7] append(nil,x) -> x,
  [8] x or true -> true,
  [9] x and false -> false,
  [10] Z le x -> true,
  [11] mem(x,nil) -> false,
  [12] if_then_else(true,x,y) -> x,
  [13] if_then_else(false,x,y) -> y,
  [14] Z eq Z -> true,
  [15] 2 -> s(s(Z)),
  [16] 6 -> s(s(s(s(s(s(Z)))))),
  [17] Z eq s(x) -> false,
  [18] s(x) eq Z -> false,
  [19] s(x) le Z -> false,
  [20] sorted(x.nil) -> true,
  [21] is_perm(x,y) -> is_perm_aux(x,y,nil),
  [22] insert(x,nil) -> x.nil,
  [23] is_perm_aux(nil,nil,nil) -> true,
  [24] is_perm_aux(nil,x.y,z) -> false,
  [25] is_perm_aux(x.y,nil,z) -> false,
  [26] sorting(x.y) -> insert(x,sorting(y)),
  [27] s(x) eq s(y) -> x eq y,
  [28] s(x) le s(y) -> x le y,
  [29] 4 -> s(s(s(s(Z)))),
  [30] sorted(insert(a,sorting(c))) -> true,
  [31] append(x.y,z) -> x.append(y,z),
  [32] mem(x,y.z) -> (x eq y) or mem(x,z),
  [33] sorted(x.(y.z)) -> (x le y) and sorted(y.z),
  [34] insert(x,y.z) -> if_then_else(x le y,x.(y.z),y.insert(x,z)),
  [35] is_perm_aux(x.y,z.l1,l2) ->
       if_then_else(x eq z,is_perm_aux(y,append(l1,l2),nil),is_perm_aux(x.y,
       l1,z.l2)) }
  (35 rules)


Is sorted(sorting(x)) ground reducible for the system defined by
{ [1] 1 -> s(Z),
  [2] 3 -> s(s(s(Z))),
  [3] 5 -> s(s(s(s(s(Z))))),
  [4] 7 -> s(s(s(s(s(s(s(Z))))))),
  [5] sorted(nil) -> true,
  [6] sorting(nil) -> nil,
  [7] append(nil,x) -> x,
  [8] x or true -> true,
  [9] x and false -> false,
  [10] Z le x -> true,
  [11] mem(x,nil) -> false,
  [12] if_then_else(true,x,y) -> x,
  [13] if_then_else(false,x,y) -> y,
  [14] Z eq Z -> true,
  [15] 2 -> s(s(Z)),
  [16] 6 -> s(s(s(s(s(s(Z)))))),
  [17] Z eq s(x) -> false,
  [18] s(x) eq Z -> false,
  [19] s(x) le Z -> false,
  [20] sorted(x.nil) -> true,
  [21] is_perm(x,y) -> is_perm_aux(x,y,nil),
  [22] insert(x,nil) -> x.nil,
  [23] is_perm_aux(nil,nil,nil) -> true,
  [24] is_perm_aux(nil,x.y,z) -> false,
  [25] is_perm_aux(x.y,nil,z) -> false,
  [26] sorting(x.y) -> insert(x,sorting(y)),
  [27] s(x) eq s(y) -> x eq y,
  [28] s(x) le s(y) -> x le y,
  [29] 4 -> s(s(s(s(Z)))),
  [30] sorted(insert(a,sorting(c))) -> true,
  [31] append(x.y,z) -> x.append(y,z),
  [32] mem(x,y.z) -> (x eq y) or mem(x,z),
  [33] sorted(x.(y.z)) -> (x le y) and sorted(y.z),
  [34] insert(x,y.z) -> if_then_else(x le y,x.(y.z),y.insert(x,z)),
  [35] is_perm_aux(x.y,z.l1,l2) ->
       if_then_else(x eq z,is_perm_aux(y,append(l1,l2),nil),is_perm_aux(x.y,
       l1,z.l2)),
  [0] append(append(x,y),z) -> append(x,append(y,z)),
  [0] x and true -> x,
  [0] x or false -> x } (38 rules)
L'automate dit NON 
 ----------------------State of completion, step 765 ----------------------
-- Equations to orient -- (min complexity = 1000000)
{}
-- Unorientable equations --
{}
-- Pre-oriented (symmetrized) equations -- (min complexities = 1000000,1000000)
{}
-- Pre-rules -- (min complexities = 1000000,1000000)
{}
-- Rules -- (min complexities = 1000000,1000000)
{ [1] 1 -> s(Z),
  [2] 3 -> s(s(s(Z))),
  [3] 5 -> s(s(s(s(s(Z))))),
  [4] 7 -> s(s(s(s(s(s(s(Z))))))),
  [5] sorted(nil) -> true,
  [6] sorting(nil) -> nil,
  [7] append(nil,x) -> x,
  [8] x or true -> true,
  [9] x and false -> false,
  [10] Z le x -> true,
  [11] mem(x,nil) -> false,
  [12] if_then_else(true,x,y) -> x,
  [13] if_then_else(false,x,y) -> y,
  [14] Z eq Z -> true,
  [15] 2 -> s(s(Z)),
  [16] 6 -> s(s(s(s(s(s(Z)))))),
  [17] Z eq s(x) -> false,
  [18] s(x) eq Z -> false,
  [19] s(x) le Z -> false,
  [20] sorted(x.nil) -> true,
  [21] is_perm(x,y) -> is_perm_aux(x,y,nil),
  [22] insert(x,nil) -> x.nil,
  [23] is_perm_aux(nil,nil,nil) -> true,
  [24] is_perm_aux(nil,x.y,z) -> false,
  [25] is_perm_aux(x.y,nil,z) -> false,
  [26] sorting(x.y) -> insert(x,sorting(y)),
  [27] s(x) eq s(y) -> x eq y,
  [28] s(x) le s(y) -> x le y,
  [29] 4 -> s(s(s(s(Z)))),
  [30] sorted(insert(a,sorting(c))) -> true,
  [31] append(x.y,z) -> x.append(y,z),
  [32] mem(x,y.z) -> (x eq y) or mem(x,z),
  [33] sorted(x.(y.z)) -> (x le y) and sorted(y.z),
  [34] insert(x,y.z) -> if_then_else(x le y,x.(y.z),y.insert(x,z)),
  [35] is_perm_aux(x.y,z.l1,l2) ->
       if_then_else(x eq z,is_perm_aux(y,append(l1,l2),nil),is_perm_aux(x.y,
       l1,z.l2)) }
  (35 rules)
Deduction indices : 1000000 1000000
-- conjectures --
{}


 not all of the following equations are inductive theorems
{sorted(sorting(x)) = true} (1 equations)

