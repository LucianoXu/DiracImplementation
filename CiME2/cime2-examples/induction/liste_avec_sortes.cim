sort 
  int , list 
operators

% entiers
  Z : constant as int
  s : unary as int -> int 
  + : infix AC as int -> int -> int
  x,y,z : variable as int

% listes
  nil : constant as list
  L : unary   as list -> int % longueur de la liste
  . : infix binary as int -> list -> list
  rev : unary  as list -> list % renvoie la liste inversee
  l1,l2 : variable as list
  @ : infix binary as list -> list -> list


axioms
  x+Z = x;
  x+s(y) = s(x+y);
  nil@l1 = l1;
  (x.l1)@l2 = x.(l1@l2);
  L(nil) = Z;
  L(x.l1) = s(L(l1));
  rev(nil) = nil;
  rev(x.l1) = (rev(l1)@(x.nil));

order rpo( L>+>s>Z ,
           rev>@>.>nil; @ lrlex, + mul)

inductive
  l1@nil = l1;
  l1@(l2@x) = (l1@l2)@x;
  rev(l1@l2) = rev(l2)@rev(l1);
  rev(l1@l2) = (rev(l2))@(rev(l1));
  rev(rev(x)) = x ;
  
  L(l1@l2) = (L(l1))+(L(l2)) ;
  
  L(rev(l1)) = L(l1) ;
  
end
