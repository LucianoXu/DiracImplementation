%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                                           %
%   BASE 2 ARITHMETIC                                                       %
%                                                                           %
%   Authors : Evelyne Contejean, Claude Marche'                             %
%                                                                           %
%                                                                           %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

operators
  +,* : AC
  # : constant
  zero,un : unary
  
  x,y,z : variable

%order
%lexico(  
 % poly(2;
 %   [+](x,y)=x+y-2 ; 
 %   [*](x,y)=x.y-x-y+2 ; 
 %   [#]=2 ; 
 %   [zero](x)=x+1 ; 
 %   [un](x)=x+2 ;
 %   [TOP(zero)](x)=x+1 ; 
 %   [TOP(+)](x,y)=x+y-1 ; 
 %   [TOP(*)](x,y)=x.y+2.x+2.y+2 
%    ) ;
%  poly(2;
%    [+](x,y)=(x+y);
%    [*](x,y)=x.y+2.(x+y)+2 ;
%    [#]=2 ;
%    [zero](x)=x+1 ; 
%    [un](x)=x 
%    )  
order
  poly(0;
    [+](x,y)=x+y ; 
    [*](x,y)=x.y+(x+y) ; 
    [#]=0 ; 
    [zero](x)=x+1 ; 
    [un](x)=x+2 ;
    [TOP(zero)](x)=x+1 ; 
    [TOP(+)](x,y)=x+y+1 ; 
    [TOP(*)](x,y)=x.y+4.x+4.y+12
)

%order
%rps(
%  mapo ( + > # );
%  x * y -> x+y;
%  zero(x) -> #;
%  un(x) -> #
%)
  
problems

dp_termination (  

    zero(#) -> # ;
    x+# -> x ;
    zero(x)+(zero(y)) -> zero(x+y) ;
    zero(x)+(un(y))   -> un(x+y) ;
    (un(x))+(un(y)) -> zero((x+y)+(un(#))) ;
    x*# -> # ;
%
    x*#*z -> #*z ;
    
    x*(zero(y)) -> zero(x*y) ;
%
    x*(zero(y))*z -> zero(x*y)*z ;

    x*(un(y))   -> x+(zero(x*y)) ;
%
    x*(un(y))*z   -> (x+(zero(x*y)))*z 


);

%compare    zero(#) with # ;
%compare    x+# with x ;
%compare    zero(x)+(zero(y)) with zero(x+y) ;
%compare    zero(x)+(un(y))   with un(x+y) ;
%compare    (un(x))+(un(y)) with zero((x+y)+(un(#))) ;
%compare    x*# with # ;
%compare    x*(zero(y)) with zero(x*y) ;
%compare    x*(un(y))   with x+(zero(x*y)) ;

 
end
