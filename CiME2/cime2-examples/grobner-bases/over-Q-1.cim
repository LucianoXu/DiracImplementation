%
%
%  base grobner de 2X^2Y-Y, 3XY^2-X sur Q
%
%  a executer avec
%
%  cime -ground -inner -rew-bound 5000 over-Q-1.cim


operators

%constructeurs

  0 : constant
  1_z,j_z,0_z : postfix unary

%operateurs

  +_z  : AC
  -_z : infix binary
  opp : unary
  *_z  : AC

% abreviations

  zero_z,un_z,deux_z,trois_z,moins_un_z : constant

%variables

  x,y,z,u,v,w : variable


theory
  USER(
  (0)0_z -> 0 ;
  x +_z 0 -> x ;
  (x)0_z +_z (y)0_z -> (x +_z y)0_z ;
  (x)0_z +_z (y)1_z -> (x +_z y)1_z ;
  (x)0_z +_z (y)j_z -> (x +_z y)j_z ;
  (x)1_z +_z (y)1_z -> (x +_z y +_z (0)1_z)j_z ;
  (x)j_z +_z (y)j_z -> (x +_z y +_z (0)j_z)1_z ;
  (x)1_z +_z (y)j_z -> (x +_z y)0_z ;
  opp(0) -> 0 ;
  opp((x)0_z) -> (opp(x))0_z ;
  opp((x)1_z) -> (opp(x))j_z ;
  opp((x)j_z) -> (opp(x))1_z ;
  x -_z y -> x +_z opp(y) ;
  x *_z 0 -> 0 ;
  x *_z (y)0_z -> (x*_z y)0_z ;
  x *_z (y)1_z -> (x*_z y)0_z +_z x ;
  x *_z (y)j_z -> (x*_z y)0_z +_z opp(x) ;

%   x *_z (y +_z z) -> (x *_z y)  +_z  (x *_z z);
%   opp(x +_z y) -> opp(x) +_z  opp(y);
%   x  +_z  opp(x) -> 0;
%   opp(opp(x)) -> x;
%   x *_z opp(y) -> opp(x *_z y);
%   x +_z x -> (x)0_z  +_z opp(x);

  zero_z -> 0 ;
  un_z -> (0)1_z ;
  deux_z -> ((0)1_z)j_z ;
  trois_z -> ((0)1_z)0_z ;
  moins_un_z -> (0)j_z )

operators

  abs : unary
  test_abs, test_abs_pos, test_abs_neg : binary
  signe, test_signe_pos, test_signe_neg : unary
  min : binary
  test_min, test_min_pos, test_min_neg : 3
  f : binary

theory
  USER(
  abs(x) -> test_abs_pos(x,x);

  test_abs_pos(0,x) -> x;
  test_abs_pos((x)0_z,y) -> test_abs_pos(x,y);
  test_abs_pos((x)1_z,y) -> test_abs_pos(x,y);
  test_abs_pos((x)j_z,y) -> test_abs_neg(x,y);

  test_abs_neg(0,x) -> opp(x);
  test_abs_neg((x)0_z,y) -> test_abs_neg(x,y);
  test_abs_neg((x)1_z,y) -> test_abs_pos(x,y);
  test_abs_neg((x)j_z,y) -> test_abs_neg(x,y);

  signe(0) -> 0;
  signe((x)0_z) -> signe(x);
  signe((x)1_z) -> test_signe_pos(x);
  signe((x)j_z) -> test_signe_neg(x);

  test_signe_pos(0) -> (0)1_z;
  test_signe_pos((x)0_z) -> test_signe_pos(x);
  test_signe_pos((x)1_z) -> test_signe_pos(x);
  test_signe_pos((x)j_z) -> test_signe_neg(x);

  test_signe_neg(0) -> (0)j_z;
  test_signe_neg((x)0_z) -> test_signe_neg(x);
  test_signe_neg((x)1_z) -> test_signe_pos(x);
  test_signe_neg((x)j_z) -> test_signe_neg(x);

  min(x,y) -> test_min_pos(abs(y) -_z abs(x),x,y);

  test_min_pos(0,x,y) -> x;
  test_min_pos((x)0_z,y,z) -> test_min_pos(x,y,z);
  test_min_pos((x)1_z,y,z) -> test_min_pos(x,y,z);
  test_min_pos((x)j_z,y,z) -> test_min_neg(x,y,z);

  test_min_neg(0,x,y) -> y;
  test_min_neg((x)0_z,y,z) -> test_min_neg(x,y,z);
  test_min_neg((x)1_z,y,z) -> test_min_pos(x,y,z);
  test_min_neg((x)j_z,y,z) -> test_min_neg(x,y,z);

  f(0,x) -> 0;
  f(x,0) -> signe(x);

  f((x)0_z,(y)0_z) -> f(x,y);
  f((x)0_z,(y)1_z) -> (f(x,(y)1_z))0_z;
  f((x)0_z,(y)j_z) -> (f(x,(y)j_z))0_z;

  f((x)1_z,(y)0_z) -> f((x)1_z,y);

  f((x)1_z,(y)1_z) ->
    (f(x -_z min(x,y), (y)1_z))0_z +_z f(min((x)1_z,(y)1_z), x -_z y);

  f((x)1_z,(y)j_z) ->
    (f(x +_z min(opp(x),y), (opp(y))1_z))0_z +_z f(min((x)1_z,(opp(y))1_z),x +_z y);

  f((x)j_z,(y)0_z) -> f((x)j_z,y);

  f((x)j_z,(y)1_z) ->
    (f(x +_z min(opp(x),y), (opp(y))j_z))0_z +_z f(min((x)j_z,(opp(y))j_z), x +_z y);

  f((x)j_z,(y)j_z) ->
    (f(x -_z min(x,y), (y)j_z))0_z +_z f(min((x)j_z,(y)j_z), x -_z y)

 )

operators

  rat, irred : binary
  +_q : commutative
  *_q : AC
  opp_q : unary

  un_q,zero_q : constant
  moins_un_q, deux_q,trois_q : constant


 theory
   USER(

   rat(x,y) -> irred(signe(y) *_z f(x,y),signe(y) *_z f(y,x));
 
   irred(x,y) +_q irred(u,v) -> rat((x *_z v) +_z (u *_z y),y *_z v);

   irred(x,y) *_q irred(u,v) -> rat(x *_z u,y *_z v) ;

%    x *_q (y +_q z) -> (x *_q y)  +_q  (x *_q z);
%    opp(x +_q y) -> opp(x) +_q  opp(y);
%    x  +_q  opp(x) -> 0;
%    opp(opp(x)) -> x;
%    x *_q opp(y) -> opp(x *_q y);

   opp_q(irred(x,y)) -> irred(opp(x),y) ;
   zero_q -> irred(0,(0)1_z) ;
   un_q -> irred((0)1_z,(0)1_z) ;
   deux_q -> irred(((0)1_z)j_z,(0)1_z) ;
   trois_q -> irred(((0)1_z)0_z,(0)1_z) ;
   moins_un_q -> irred((0)j_z,(0)1_z) 
   )

% polynomes

operators
  0_p, 1_p : constant
  +_p, *_p : AC
  -_p : unary
  Coef : unary

  X,Y : constant

  P,Q,R : variable

%axioms
%  P +_p 0_p = P;
%  P +_p -_p(P) = 0_p;
%  -_p(0_p) = 0_p;
%  -_p(-_p(P)) = P;
%  -_p(P +_p Q) = -_p(P) +_p -_p(Q) ;
%   P *_p 1_p = P ; 
%   P *_p 0_p = 0_p;
%   P *_p (Q +_p R) = (P *_p Q) +_p (P *_p R);
%   P *_p -_p(Q) = -_p(P *_p Q);
   
theory 
  Rat(un_z,Coef,irred,+_p,0_p,-_p,*_p,1_p)
  USER(0_p -> Coef(irred(0,(0)1_z));
       1_p -> Coef(irred((0)1_z,(0)1_z));
       -_p(P) -> P *_p Coef(irred((0)j_z,(0)1_z)) ;
       Coef(x) +_p Coef(y) -> Coef(x +_q y) ;
       Coef(x) *_p Coef(y) -> Coef(x *_q y) ;
       Coef(irred(0,(0)1_z)) +_p P -> P ;
       Coef(irred(0,(0)1_z)) *_p P -> Coef(irred(0,(0)1_z)) ;
       Coef(irred((0)1_z,(0)1_z)) *_p P -> P ;
       P +_p P -> Coef(irred(((0)1_z)j_z,(0)1_z)) *_p P;
       (Coef(x) *_p P) +_p P -> Coef(x +_q irred((0)1_z,(0)1_z)) *_p P;
       (Coef(x) *_p P) +_p (Coef(y) *_p P) -> Coef(x +_q y) *_p P
       )


axioms
%  Coef(x) +_p Coef(y) = Coef(x +_z y) ;
%  (Coef(x) *_p P) +_p (Coef(y) *_p P) = Coef(x +_z y) *_p P;
%  Coef(x) *_p Coef(y) = Coef(x *_z y);
%  Coef(0) = 0_p;
%  -_p(Coef(x)) = Coef(opp(x)) ;
%  -_p(P *_p Coef(x)) = P *_p Coef(opp(x)) ;

  (Coef(deux_q) *_p X *_p X *_p Y) +_p -_p(Y) = 0_p;
  (Coef(trois_q) *_p X *_p Y *_p Y) +_p -_p(X) = 0_p;
  
order  rpo( Y>X>*_p>+_p, X>Coef=irred=0=0_z=1_z=j_z  )


end

Welcome to CiME v1.14 - SunOS-5.4 - CSL opt - 11/05/96 17:42:14


New rule produced :
 [1] X *_p X *_p Y -> Coef(irred((0)1_z,((0)1_z)j_z)) *_p Y
New rule produced :
 [2] X *_p Y *_p Y -> Coef(irred((0)1_z,((0)1_z)0_z)) *_p X
New rule produced :
 [3] Y *_p Y -> Coef(irred(((0)1_z)j_z,((0)1_z)0_z)) *_p X *_p X
Rule [2] X *_p Y *_p Y -> Coef(irred((0)1_z,((0)1_z)0_z)) *_p X collapsed.
New rule produced :
 [4] X *_p X *_p X -> Coef(irred((0)1_z,((0)1_z)j_z)) *_p X

Result:
{ [1] X *_p X *_p Y -> Coef(irred((0)1_z,((0)1_z)j_z)) *_p Y,
  [3] Y *_p Y -> Coef(irred(((0)1_z)j_z,((0)1_z)0_z)) *_p X *_p X,
  [4] X *_p X *_p X -> Coef(irred((0)1_z,((0)1_z)j_z)) *_p X } (3 rules)

Number of calls to AC matching      : 9220
Number of successful calls          : 2290 (24%)
Number of calls to unification      : 28
Number of unifiers generated        : 16 (0.57 average)
Number of critical pairs considered : 14 (87%)
Number of rules produced            : 4
Number of rules retained            : 3

      times       |   user   |  system  |  total 
------------------+----------+----------+----------
Total times       |  172.650 |  156.530 |  329.180 
                  |( 2mn 52s)|( 2mn 36s)|( 5mn 29s)
Unification times |    0.050 |    0.000 |    0.050 
Matching times    |   83.940 |   77.200 |  161.140 
                  |( 1mn 23s)|( 1mn 17s)|( 2mn 41s)

