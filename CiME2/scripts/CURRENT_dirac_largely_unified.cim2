(* 

    Language and Term Rewriting System for "Typed Dirac Notation"

    This language can be used in two levels: deal with the internal untyped language directly,
    or use the typed syntax with type polymorphism.

    Yingte Xu, 2024

    unified symbols: 

    0X, ADJ, SCR, ADD

    unification undergoing:

*)

let F = signature
"

  (* complex number *)
  + : AC ;
  * : AC ;
  0 : constant ;
  1 : constant ;
  ^* : postfix unary ;

  (* -------- internal langauge -------- *)

  (* Basis *)
  PAIR : binary ;
  FST : unary ;
  SND : unary ;

  (* Scalar *)
  C : unary ;
  DELTA : commutative ;
  ADDS : AC ;
  MLTS : AC ;
  CONJS : unary ;
  DOT : infix binary ;

  (* Ket *)
  KET : unary ;
  MLTK : infix binary ;
  TSRK : infix binary ;

  (* Bra *)
  BRA : unary ;
  MLTB : infix binary ;
  TSRB : infix binary ;

  (* Operator *)
  1O : constant ;
  OUTER : infix binary ;
  MLTO : infix binary ;
  TSRO : infix binary ;

  (* unified *)
  0X : constant ;
  ADJ : unary ;
  SCR : infix binary ;
  ADD : AC ;

";

let X = vars "a b c x S0 S1 S2 S3 s s1 s2 t t1 t2 B0 B1 B2 K0 K1 K2 O0 O1 O2 O1' O2' T1 T2 T3 T4 X0 X1 X2 X3 x0 x1 x2 x3 x4";

let R = TRS F X "


  (* ############# REDUCTION RULES FOR INTERNAL LANGUAGE ############### *)

  (********************************************)
  (*           complex number (avatar)        *)
  (********************************************)

  0 + a -> a ;
  0 * a -> 0 ;
  1 * a -> a ;
  a * (b + c) -> (a * b) + (a * c) ;
  0 ^* -> 0 ;
  1 ^* -> 1 ;
  (a + b) ^* -> (a ^*) + (b ^*) ;
  (a * b) ^* -> (a ^*) * (b ^*) ;
  (a ^*) ^* -> a ;

  (********************************************)
  (*                 Basis                    *)
  (********************************************)

  FST(PAIR(s, t)) -> s ;
  SND(PAIR(s, t)) -> t ;
  PAIR(FST(t), SND(t)) -> t ;


  (********************************************)
  (*                 Scalars                  *)
  (********************************************)

  (* ============== Delta Operator ================ *)

  DELTA(s, PAIR(t1, t2)) -> DELTA(FST(s), t1) MLTS DELTA(SND(s), t2) ;
  DELTA(FST(s), FST(t)) MLTS DELTA(SND(s), SND(t)) -> DELTA(s, t) ;

  (* ============================================== *)

  C(0) ADDS a -> a ;
  C(a) ADDS C(b) -> C(a + b) ;
  S0 ADDS S0 -> C(1 + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS S0 -> C(a + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS (C(b) MLTS S0) -> C(a + b) MLTS S0 ;

  C(0) MLTS a -> C(0) ;
  C(1) MLTS a -> a ;
  C(a) MLTS C(b) -> C(a * b) ;
  S1 MLTS (S2 ADDS S3) -> (S1 MLTS S2) ADDS (S1 MLTS S3) ;


  CONJS(C(a)) -> C(a ^*) ;
  CONJS(DELTA(s, t)) -> DELTA(s, t) ;
  CONJS(S1 ADDS S2) -> CONJS(S1) ADDS CONJS(S2) ;
  CONJS(S1 MLTS S2) -> CONJS(S1) MLTS CONJS(S2) ;
  CONJS(CONJS(S0)) -> S0 ;
  CONJS(B0 DOT K0) -> ADJ(K0) DOT ADJ(B0) ;

  0X DOT K0 -> C(0) ;
  B0 DOT 0X -> C(0) ;
  (S0 SCR B0) DOT K0 -> S0 MLTS (B0 DOT K0) ;
  B0 DOT (S0 SCR K0) -> S0 MLTS (B0 DOT K0) ;
  (B1 ADD B2) DOT K0 -> (B1 DOT K0) ADDS (B2 DOT K0) ;
  B0 DOT (K1 ADD K2) -> (B0 DOT K1) ADDS (B0 DOT K2) ;
  BRA(s) DOT KET(t) -> DELTA(s, t) ;
  (B1 TSRB B2) DOT KET(t) -> (B1 DOT KET(FST(t))) MLTS (B2 DOT KET(SND(t))) ;
  BRA(t) DOT (K1 TSRK K2) -> (BRA(FST(t)) DOT K1) MLTS (BRA(SND(t)) DOT K2) ;
  (B1 TSRB B2) DOT (K1 TSRK K2) -> (B1 DOT K1) MLTS (B2 DOT K2) ;

  (B0 MLTB O0) DOT K0 -> B0 DOT (O0 MLTK K0) ;
  BRA(s) DOT ((O1 TSRO O2) MLTK K0) -> ((BRA(FST(s)) MLTB O1) TSRB (BRA(SND(s)) MLTB O2)) DOT K0 ;
  (B1 TSRB B2) DOT ((O1 TSRO O2) MLTK K0) -> ((B1 MLTB O1) TSRB (B2 MLTB O2)) DOT K0 ;

  (********************************************)
  (*            Ket and Bra                   *)
  (********************************************)


  (* >>>> Multiplication <<<< *)
  0X MLTK K0 -> 0X ;
  O0 MLTK 0X -> 0X ;
  1O MLTK K0 -> K0 ;
  (S0 SCR O0) MLTK K0 -> S0 SCR (O0 MLTK K0) ;
  O0 MLTK (S0 SCR K0) -> S0 SCR (O0 MLTK K0) ;
  (O1 ADD O2) MLTK K0 -> (O1 MLTK K0) ADD (O2 MLTK K0) ;
  O0 MLTK (K1 ADD K2) -> (O0 MLTK K1) ADD (O0 MLTK K2) ;
  (K1 OUTER B0) MLTK K2 -> (B0 DOT K2) SCR K1 ;
  (O1 MLTO O2) MLTK K0 -> O1 MLTK (O2 MLTK K0) ;
  (O1 TSRO O2) MLTK ((O1' TSRO O2') MLTK K0) -> ((O1 MLTO O1') TSRO (O2 MLTO O2')) MLTK K0 ;
  (O1 TSRO O2) MLTK KET(t) -> (O1 MLTK KET(FST(t))) TSRK (O2 MLTK KET(SND(t))) ;
  (O1 TSRO O2) MLTK (K1 TSRK K2) -> (O1 MLTK K1) TSRK (O2 MLTK K2) ;

  B0 MLTB 0X -> 0X ;
  0X MLTB O0 -> 0X ;
  B0 MLTB 1O -> B0 ;
  B0 MLTB (S0 SCR O0) -> S0 SCR (B0 MLTB O0) ;
  (S0 SCR B0) MLTB O0 -> S0 SCR (B0 MLTB O0) ;
  B0 MLTB (O1 ADD O2) -> (B0 MLTB O1) ADD (B0 MLTB O2) ;
  (B1 ADD B2) MLTB O0 -> (B1 MLTB O0) ADD (B2 MLTB O0) ;
  B1 MLTB (K0 OUTER B2) -> (B1 DOT K0) SCR B2 ;
  B0 MLTB (O1 MLTO O2) -> (B0 MLTB O1) MLTB O2 ;
  (B0 MLTB (O1' TSRO O2')) MLTB (O1 TSRO O2) -> B0 MLTB ((O1' MLTO O1) TSRO (O2' MLTO O2)) ;
  BRA(t) MLTB (O1 TSRO O2) -> (BRA(FST(t)) MLTB O1) TSRB (BRA(SND(t)) MLTB O2) ;
  (B1 TSRB B2) MLTB (O1 TSRO O2) -> (B1 MLTB O1) TSRB (B2 MLTB O2) ;

  (* >>>> Tensor Product <<<< *)
  0X TSRK K0 -> 0X ;
  K0 TSRK 0X -> 0X ;
  KET(s) TSRK KET(t) -> KET(PAIR(s, t)) ;
  (S0 SCR K1) TSRK K2 -> S0 SCR (K1 TSRK K2) ;
  K1 TSRK (S0 SCR K2) -> S0 SCR (K1 TSRK K2) ;
  (K1 ADD K2) TSRK K0 -> (K1 TSRK K0) ADD (K2 TSRK K0) ;
  K0 TSRK (K1 ADD K2) -> (K0 TSRK K1) ADD (K0 TSRK K2) ;

  0X TSRB B0 -> 0X ;
  B0 TSRB 0X -> 0X ;
  BRA(s) TSRB BRA(t) -> BRA(PAIR(s, t)) ;
  (S0 SCR B1) TSRB B2 -> S0 SCR (B1 TSRB B2) ;
  B1 TSRB (S0 SCR B2) -> S0 SCR (B1 TSRB B2) ;
  (B1 ADD B2) TSRB B0 -> (B1 TSRB B0) ADD (B2 TSRB B0) ;
  B0 TSRB (B1 ADD B2) -> (B0 TSRB B1) ADD (B0 TSRB B2) ;

  (********************************************)
  (*             Operators                    *)
  (********************************************)

  (* >>>> Outer Product <<<< *)
  0X OUTER B0 -> 0X ;
  K0 OUTER 0X -> 0X ;
  (S0 SCR K0) OUTER B0 -> S0 SCR (K0 OUTER B0) ;
  K0 OUTER (S0 SCR B0) -> S0 SCR (K0 OUTER B0) ;
  (K1 ADD K2) OUTER B0 -> (K1 OUTER B0) ADD (K2 OUTER B0) ;
  K0 OUTER (B1 ADD B2) -> (K0 OUTER B1) ADD (K0 OUTER B2) ;

  (* >>>> Multiplication <<<< *)
  0X MLTO O0 -> 0X ;
  O0 MLTO 0X -> 0X ;
  1O MLTO O0 -> O0 ;
  O0 MLTO 1O -> O0 ;
  (K0 OUTER B0) MLTO O0 -> K0 OUTER (B0 MLTB O0) ;
  O0 MLTO (K0 OUTER B0) -> (O0 MLTK K0) OUTER B0 ;
  (S0 SCR O1) MLTO O2 -> S0 SCR (O1 MLTO O2) ;
  O1 MLTO (S0 SCR O2) -> S0 SCR (O1 MLTO O2) ;
  (O1 ADD O2) MLTO O0 -> (O1 MLTO O0) ADD (O2 MLTO O0) ;
  O0 MLTO (O1 ADD O2) -> (O0 MLTO O1) ADD (O0 MLTO O2) ;
  (O1 MLTO O2) MLTO O0 -> O1 MLTO (O2 MLTO O0) ;
  (O1 TSRO O2) MLTO (O1' TSRO O2') -> (O1 MLTO O1') TSRO (O2 MLTO O2') ;
  (O1 TSRO O2) MLTO ((O1' TSRO O2') MLTO O0) -> ((O1 MLTO O1') TSRO (O2 MLTO O2')) MLTO O0 ;

  (* >>>> Tensor Product <<<< *)
  0X TSRO O0 -> 0X ;
  O0 TSRO 0X -> 0X ;
  1O TSRO 1O -> 1O ;
  (K1 OUTER B1) TSRO (K2 OUTER B2) -> (K1 TSRK K2) OUTER (B1 TSRB B2) ;
  (S0 SCR O1) TSRO O2 -> S0 SCR (O1 TSRO O2) ;
  O1 TSRO (S0 SCR O2) -> S0 SCR (O1 TSRO O2) ;
  (O1 ADD O2) TSRO O0 -> (O1 TSRO O0) ADD (O2 TSRO O0) ;
  O0 TSRO (O1 ADD O2) -> (O0 TSRO O1) ADD (O0 TSRO O2) ;


  (********************************************)
  (*             Unified Symbols              *)
  (********************************************)

  (* >>>> Conjugate Transpose <<<< *)
  ADJ(0X) -> 0X ;
  ADJ(ADJ(X0)) -> X0 ;
  ADJ(S0 SCR X0) -> CONJS(S0) SCR ADJ(X0) ;
  ADJ(X1 ADD X2) -> ADJ(X1) ADD ADJ(X2) ;

  ADJ(BRA(t)) -> KET(t) ;
  ADJ(B0 MLTB O0) -> ADJ(O0) MLTK ADJ(B0) ;
  ADJ(B1 TSRB B2) -> ADJ(B1) TSRK ADJ(B2) ;

  ADJ(KET(t)) -> BRA(t) ;
  ADJ(O0 MLTK K0) -> ADJ(K0) MLTB ADJ(O0) ;
  ADJ(K1 TSRK K2) -> ADJ(K1) TSRB ADJ(K2) ;

  ADJ(1O) -> 1O ;
  ADJ(K0 OUTER B0) -> ADJ(B0) OUTER ADJ(K0) ;
  ADJ(O1 MLTO O2) -> ADJ(O2) MLTO ADJ(O1) ;
  ADJ(O1 TSRO O2) -> ADJ(O1) TSRO ADJ(O2) ;

  (* >>>> Scalar Multiplication <<<< *)
  C(0) SCR X0 -> 0X ;
  C(1) SCR X0 -> X0 ;
  S0 SCR 0X -> 0X ;
  S1 SCR (S2 SCR X0) -> (S1 MLTS S2) SCR X0 ;
  S0 SCR (X1 ADD X2) -> (S0 SCR X1) ADD (S0 SCR X2) ;

  (* >>>> Addition <<<< *)
  X0 ADD 0X -> X0 ;
  X0 ADD X0 -> C(1 + 1) SCR X0 ;
  (S0 SCR X0) ADD X0 -> (S0 ADDS C(1)) SCR X0 ;
  (S1 SCR X0) ADD (S2 SCR X0) -> (S1 ADDS S2) SCR X0 ;

  
";

(* optional : 

  DELTA(s, s) -> C(1) ;

*)

