(* 

    Language and Term Rewriting System for "Typed Dirac Notation"

    This language can be used in two levels: deal with the internal untyped language directly,
    or use the typed syntax with type polymorphism.

    Yingte Xu, 2024

    ket and bra has the unified representation.

*)

let F = signature
"

  (* complex number *)
  + : AC ;
  * : AC ;
  0 : constant ;
  1 : constant ;
  ^* : postfix unary ;


  (* -------- types -------- *)
  T : constant ;
  PROD : infix binary ;

  Base : binary ;
  S : unary ;
  K : binary ;
  B : binary ;
  O : 3 ;
  

  (* -------- syntax symbols -------- *)
  (* The external language. Will be be transformed in to the internal langauge during type checking. *)

  (* Basis *)
  pair_S : binary ;
  fst_S : unary ;
  snd_S : unary ;

  (* Scalar *)
  C_S : unary ;
  delta_S : binary ;
  ADDS_S : infix binary ;
  MLTS_S : infix binary ;
  CONJS_S : unary ;
  DOT_S : infix binary ;

  (* Ket *)
  0K_S : unary ;
  ket_S : unary ;
  CTK_S : unary ;
  SCRK_S : infix binary ;
  ADDK_S : infix binary ;
  MLTK_S : infix binary ;
  TSRK_S : infix binary ;

  (* Bra *)
  0B_S : unary ;
  bra_S : unary ;
  CTB_S : unary ;
  SCRB_S : infix binary ;
  ADDB_S : infix binary ;
  MLTB_S : infix binary ;
  TSRB_S : infix binary ;

  (* Operator *)
  0O_S : binary ;
  OUTER_S : infix binary ;
  ADJO_S : unary ;
  SCRO_S : infix binary ;
  ADDO_S : infix binary ;
  MLTO_S : infix binary ;
  TSRO_S : infix binary ;

  (* universal application *)
  @ : infix binary ;

  (* otimes and cdot *)
  OTIMES : infix binary ;
  CDOT : infix binary ;

  (* -------- internal langauge -------- *)

  (* Basis *)
  pair : binary ;
  fst : unary ;
  snd : unary ;

  (* Scalar *)
  C : unary ;
  delta : commutative ;
  ADDS : AC ;
  MLTS : AC ;
  CONJS : unary ;
  DOT : infix binary ;

  (* Vector *)
  0V : constant ;
  v : unary ;
  ADJV : unary ;
  SCRV : infix binary ;
  ADDV : AC ;
  MLTK : infix binary ;
  MLTB : infix binary ;
  TSRV : infix binary ;

  (* Operator *)
  0O : constant ;
  1O : constant ;
  OUTER : infix binary ;
  ADJO : unary ;
  SCRO : infix binary ;
  ADDO : AC ;
  MLTO : infix binary ;
  TSRO : infix binary ;

";

let X = vars "a b c x S0 S1 S2 S3 s s1 s2 t t1 t2 B0 B1 B2 K0 K1 K2 K1' K2' O0 O1 O2 O1' O2' T1 T2 T3 T4 x0 x1 x2 x3 x4";

let R = TRS F X "

  (* ######################## TYPE CHECKING ############################ *)
  C_S(a) -> S(C(a)) ;
  delta_S(Base(s, T1), Base(t, T1)) -> S(delta(s, t)) ;
  S(a) ADDS_S S(b) -> S(a ADDS b) ;
  S(a) MLTS_S S(b) -> S(a MLTS b) ;
  CONJS_S(S(a)) -> S(CONJS(a)) ;
  B(B0, T1) DOT_S K(K0, T1) -> S(B0 DOT K0) ;

  (* Ket *)
  0K_S(T1) -> K(0V, T1) ;
  ket_S(Base(s, T1)) -> K(v(s), T1) ;
  CTK_S(B(B0, T1)) -> K(ADJV(B0), T1) ;
  S(S0) SCRK_S K(K0, T1) -> K(S0 SCRV K0, T1) ;
  K(K1, T1) ADDK_S K(K2, T1) -> K(K1 ADDV K2, T1) ;
  O(O0, T1, T2) MLTK_S K(K0, T2) -> K(O0 MLTK K0, T1) ;
  K(K1, T1) TSRK_S K(K2, T2) -> K(K1 TSRV K2, T1 PROD T2) ;

  (* Bra *)
  0B_S(T1) -> B(0V, T1) ;
  bra_S(Base(s, T1)) -> B(v(s), T1) ;
  CTB_S(K(K0, T1)) -> B(ADJV(K0), T1) ;
  S(S0) SCRB_S B(B0, T1) -> B(S0 SCRV B0, T1) ;
  B(B1, T1) ADDB_S B(B2, T1) -> B(B1 ADDV B2, T1) ;
  B(B0, T1) MLTB_S O(O0, T1, T2) -> B(O0 MLTB B0, T2) ;
  B(B1, T1) TSRB_S B(B2, T2) -> B(B1 TSRV B2, T1 PROD T2) ;

  (* Operator *)
  0O_S(T1, T2) -> O(0O, T1, T2) ;
  K(K0, T1) OUTER_S B(B0, T2) -> O(K0 OUTER B0, T1, T2) ;
  ADJO_S(O(O0, T1, T2)) -> O(ADJO(O0), T2, T1) ;
  S(S0) SCRO_S O(O0, T1, T2) -> O(S0 SCRO O0, T1, T2) ;
  O(O1, T1, T2) ADDO_S O(O2, T1, T2) -> O(O1 ADDO O2, T1, T2) ;
  O(O1, T1, T2) MLTO_S O(O2, T2, T3) -> O(O1 MLTO O2, T1, T3) ;
  O(O1, T1, T2) TSRO_S O(O2, T3, T4) -> O(O1 TSRO O2, T1 PROD T3, T2 PROD T4) ;

  (* -------- overload the universal application --------- *)
  S(S1) @ S(S2) -> S(S1 MLTS S2) ;
  S(S0) @ K(K0, T1) -> K(S0 SCRV K0, T1) ;
  S(S0) @ B(B0, T1) -> B(S0 SCRV B0, T1) ;

  S(S0) @ O(O0, T1, T2) -> O(S0 SCRO O0, T1, T2) ;
  K(K0, T1) @ S(S0) -> K(S0 SCRV K0, T1) ;
  K(K1, T1) @ K(K2, T2) -> K(K1 TSRV K2, T1 PROD T2) ;
  K(K0, T1) @ B(B0, T2) -> O(K0 OUTER B0, T1, T2) ;

  B(B0, T1) @ S(S0) -> B(S0 SCRV B0, T1) ;
  B(B0, T1) @ K(K0, T1) -> S(B0 DOT K0) ;
  B(B1, T1) @ B(B2, T2) -> B(B1 TSRV B2, T1 PROD T2) ;
  B(B0, T1) @ O(O0, T1, T2) -> B(B0 MLTB O0, T2) ;

  O(O0, T1, T2) @ S(S0) -> O(S0 SCRO O0, T1, T2) ;
  O(O0, T1, T2) @ K(K0, T2) -> K(O0 MLTK K0, T1) ;
  O(O1, T1, T2) @ O(O2, T2, T3) -> O(O1 MLTO O2, T1, T3) ;

  (* -------- overload of otimes and cdot -------- *)
  K(K1, T1) OTIMES K(K2, T2) -> K(K1 TSRV K2, T1 PROD T2) ;
  B(B1, T1) OTIMES B(B2, T2) -> B(B1 TSRV B2, T1 PROD T2) ;
  K(K0, T1) OTIMES B(B0, T2) -> O(K0 OUTER B0, T1, T2) ;
  O(O1, T1, T2) OTIMES O(O2, T3, T4) -> O(O1 TSRO O2, T1 PROD T3, T2 PROD T4) ;

  B(B0, T1) CDOT O(O0, T1, T2) -> B(B0 MLTB O0, T2) ;
  O(O0, T1, T2) CDOT K(K0, T2) -> K(O0 MLTK K0, T1) ;
  B(B0, T1) CDOT K(K0, T1) -> S(B0 DOT K0) ;
  O(O1, T1, T2) CDOT O(O2, T2, T3) -> O(O1 MLTO O2, T1, T3) ;


  (* ############# REDUCTION RULES FOR INTERNAL LANGUAGE ############### *)

  (********************************************)
  (*           complex number (avatar)        *)
  (********************************************)

  0 + a -> a ;
  0 * a -> 0 ;
  1 * a -> a ;
  a * (b + c) -> (a * b) + (a * c) ;
  0 ^* -> 0 ;
  1 ^* -> 1 ;
  (a + b) ^* -> (a ^*) + (b ^*) ;
  (a * b) ^* -> (a ^*) * (b ^*) ;
  (a ^*) ^* -> a ;

  (********************************************)
  (*                 Basis                    *)
  (********************************************)

  fst(pair(s, t)) -> s ;
  snd(pair(s, t)) -> t ;
  pair(fst(t), snd(t)) -> t ;


  (********************************************)
  (*                 Scalars                  *)
  (********************************************)

  (* ============== Delta Operator ================ *)

  delta(s, pair(t1, t2)) -> delta(fst(s), t1) MLTS delta(snd(s), t2) ;
  delta(fst(s), fst(t)) MLTS delta(snd(s), snd(t)) -> delta(s, t) ;

  (* ============================================== *)

  C(0) ADDS a -> a ;
  C(a) ADDS C(b) -> C(a + b) ;
  S0 ADDS S0 -> C(1 + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS S0 -> C(a + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS (C(b) MLTS S0) -> C(a + b) MLTS S0 ;

  C(0) MLTS a -> C(0) ;
  C(1) MLTS a -> a ;
  C(a) MLTS C(b) -> C(a * b) ;
  S1 MLTS (S2 ADDS S3) -> (S1 MLTS S2) ADDS (S1 MLTS S3) ;


  CONJS(C(a)) -> C(a ^*) ;
  CONJS(delta(s, t)) -> delta(s, t) ;
  CONJS(S1 ADDS S2) -> CONJS(S1) ADDS CONJS(S2) ;
  CONJS(S1 MLTS S2) -> CONJS(S1) MLTS CONJS(S2) ;
  CONJS(CONJS(S0)) -> S0 ;
  CONJS(K0 DOT K1) -> ADJV(K1) DOT ADJV(K0) ;

  0V DOT K0 -> C(0) ;
  K0 DOT 0V -> C(0) ;
  (S0 SCRV K0) DOT K1 -> S0 MLTS (K0 DOT K1) ;
  K0 DOT (S0 SCRV K1) -> S0 MLTS (K0 DOT K1) ;
  (K1 ADDV K2) DOT K0 -> (K1 DOT K0) ADDS (K2 DOT K0) ;
  K0 DOT (K1 ADDV K2) -> (K0 DOT K1) ADDS (K0 DOT K2) ;
  v(s) DOT v(t) -> delta(s, t) ;
  (K1 TSRV K2) DOT v(t) -> (K1 DOT v(fst(t))) MLTS (K2 DOT v(snd(t))) ;
  v(t) DOT (K1 TSRV K2) -> (v(fst(t)) DOT K1) MLTS (v(snd(t)) DOT K2) ;
  (K1 TSRV K2) DOT (K1' TSRV K2') -> (K1 DOT K1') MLTS (K2 DOT K2') ;

  (O0 MLTB K0) DOT K1 -> K0 DOT (O0 MLTK K1) ;
  v(s) DOT ((O1 TSRO O2) MLTK K0) -> ((O1 MLTB v(fst(s))) TSRV (O2 MLTB v(snd(s)))) DOT K0 ;
  (K1 TSRV K2) DOT ((O1 TSRO O2) MLTK K0) -> ((O1 MLTB K1) TSRV (O2 MLTB K2)) DOT K0 ;


  (********************************************)
  (*            Ket and Bra                   *)
  (********************************************)


  (* >>>> Conjugate Transpose <<<< *)
  ADJV(0V) -> 0V ;
  ADJV(v(t)) -> v(t) ;
  ADJV(ADJV(K0)) -> K0 ;
  ADJV(S0 SCRV K0) -> CONJS(S0) SCRV ADJV(K0) ;
  ADJV(K1 ADDV K2) -> ADJV(K1) ADDV ADJV(K2) ;
  ADJV(O0 MLTK K0) -> ADJO(O0) MLTB ADJV(K0) ;
  ADJV(K1 TSRV K2) -> ADJV(K1) TSRV ADJV(K2) ;

  ADJV(O0 MLTB K0) -> ADJO(O0) MLTK ADJV(K0) ;

  (* >>>> Scalar Multiplication <<<< *)
  C(0) SCRV K0 -> 0V ;
  C(1) SCRV K0 -> K0 ;
  S0 SCRV 0V -> 0V ;
  S1 SCRV (S2 SCRV K0) -> (S1 MLTS S2) SCRV K0 ;
  S0 SCRV (K1 ADDV K2) -> (S0 SCRV K1) ADDV (S0 SCRV K2) ;


  (* >>>> Addition <<<< *)
  K0 ADDV 0V -> K0 ;
  K0 ADDV K0 -> C(1 + 1) SCRV K0 ;
  (S0 SCRV K0) ADDV K0 -> (S0 ADDS C(1)) SCRV K0 ;
  (S1 SCRV K0) ADDV (S2 SCRV K0) -> (S1 ADDS S2) SCRV K0 ;

  (* >>>> Multiplication <<<< *)
  0O MLTK K0 -> 0V ;
  O0 MLTK 0V -> 0V ;
  1O MLTK K0 -> K0 ;
  (S0 SCRO O0) MLTK K0 -> S0 SCRV (O0 MLTK K0) ;
  O0 MLTK (S0 SCRV K0) -> S0 SCRV (O0 MLTK K0) ;
  (O1 ADDO O2) MLTK K0 -> (O1 MLTK K0) ADDV (O2 MLTK K0) ;
  O0 MLTK (K1 ADDV K2) -> (O0 MLTK K1) ADDV (O0 MLTK K2) ;
  (K1 OUTER K0) MLTK K2 -> (K0 DOT K2) SCRV K1 ;
  (O1 MLTO O2) MLTK K0 -> O1 MLTK (O2 MLTK K0) ;
  (O1 TSRO O2) MLTK ((O1' TSRO O2') MLTK K0) -> ((O1 MLTO O1') TSRO (O2 MLTO O2')) MLTK K0 ;
  (O1 TSRO O2) MLTK v(t) -> (O1 MLTK v(fst(t))) TSRV (O2 MLTK v(snd(t))) ;
  (O1 TSRO O2) MLTK (K1 TSRV K2) -> (O1 MLTK K1) TSRV (O2 MLTK K2) ;

  0O MLTB K0 -> 0V ;
  O0 MLTB 0V -> 0V ;
  1O MLTB K0 -> K0 ;
  (S0 SCRO O0) MLTB K0 -> S0 SCRV (O0 MLTB K0) ;
  O0 MLTB (S0 SCRV K0) -> S0 SCRV (O0 MLTB K0) ;
  (O1 ADDO O2) MLTB K0 -> (O1 MLTB K0) ADDV (O2 MLTB K0) ;
  O0 MLTB (K1 ADDV K2) -> (O0 MLTB K1) ADDV (O0 MLTB K2) ;
  (K1 OUTER K0) MLTB K2 -> (K2 DOT K1) SCRV K0 ;
  (O1 MLTO O2) MLTB K0 -> O2 MLTB (O1 MLTB K0) ;
  (O1 TSRO O2) MLTB ((O1' TSRO O2') MLTB K0) -> ((O1' MLTO O1) TSRO (O2' MLTO O2)) MLTB K0 ;
  (O1 TSRO O2) MLTB v(t) -> (O1 MLTB v(fst(t))) TSRV (O2 MLTB v(snd(t))) ;
  (O1 TSRO O2) MLTB (K1 TSRV K2) -> (O1 MLTB K1) TSRV (O2 MLTB K2) ;

  (* >>>> Tensor Product <<<< *)
  0V TSRV K0 -> 0V ;
  K0 TSRV 0V -> 0V ;
  v(s) TSRV v(t) -> v(pair(s, t)) ;
  (S0 SCRV K1) TSRV K2 -> S0 SCRV (K1 TSRV K2) ;
  K1 TSRV (S0 SCRV K2) -> S0 SCRV (K1 TSRV K2) ;
  (K1 ADDV K2) TSRV K0 -> (K1 TSRV K0) ADDV (K2 TSRV K0) ;
  K0 TSRV (K1 ADDV K2) -> (K0 TSRV K1) ADDV (K0 TSRV K2) ;


  (********************************************)
  (*             Operators                    *)
  (********************************************)

  (* >>>> Outer Product <<<< *)
  0V OUTER K0 -> 0O ;
  K0 OUTER 0V -> 0O ;
  (S0 SCRV K0) OUTER K1 -> S0 SCRO (K0 OUTER K1) ;
  K0 OUTER (S0 SCRV K1) -> S0 SCRO (K0 OUTER K1) ;
  (K1 ADDV K2) OUTER K0 -> (K1 OUTER K0) ADDO (K2 OUTER K0) ;
  K0 OUTER (K1 ADDV K2) -> (K0 OUTER K1) ADDO (K0 OUTER K2) ;

  (* >>>> Conjugate Transpose <<<< *)
  ADJO(0O) -> 0O ;
  ADJO(1O) -> 1O ;
  ADJO(K0 OUTER K1) -> ADJV(K1) OUTER ADJV(K0) ;
  ADJO(ADJO(O0)) -> O0 ;
  ADJO(S0 SCRO O0) -> CONJS(S0) SCRO ADJO(O0) ;
  ADJO(O1 ADDO O2) -> ADJO(O1) ADDO ADJO(O2) ;
  ADJO(O1 MLTO O2) -> ADJO(O2) MLTO ADJO(O1) ;
  ADJO(O1 TSRO O2) -> ADJO(O1) TSRO ADJO(O2) ;

  (* >>>> Scalar Multiplication <<<< *)
  C(0) SCRO O0 -> 0O ;
  C(1) SCRO O0 -> O0 ;
  S0 SCRO 0O -> 0O ;
  S1 SCRO (S2 SCRO O0) -> (S1 MLTS S2) SCRO O0 ;
  S0 SCRO (O1 ADDO O2) -> (S0 SCRO O1) ADDO (S0 SCRO O2) ;

  (* >>>> Addition <<<< *)
  O0 ADDO 0O -> O0 ;
  O0 ADDO O0 -> C(1 + 1) SCRO O0 ;
  (S0 SCRO O0) ADDO O0 -> (S0 ADDS C(1)) SCRO O0 ;
  (S1 SCRO O0) ADDO (S2 SCRO O0) -> (S1 ADDS S2) SCRO O0 ;


  (* >>>> Multiplication <<<< *)
  0O MLTO O0 -> 0O ;
  O0 MLTO 0O -> 0O ;
  1O MLTO O0 -> O0 ;
  O0 MLTO 1O -> O0 ;
  (K0 OUTER K1) MLTO O0 -> K0 OUTER (O0 MLTB K1) ;
  O0 MLTO (K0 OUTER K1) -> (O0 MLTK K0) OUTER K1 ;
  (S0 SCRO O1) MLTO O2 -> S0 SCRO (O1 MLTO O2) ;
  O1 MLTO (S0 SCRO O2) -> S0 SCRO (O1 MLTO O2) ;
  (O1 ADDO O2) MLTO O0 -> (O1 MLTO O0) ADDO (O2 MLTO O0) ;
  O0 MLTO (O1 ADDO O2) -> (O0 MLTO O1) ADDO (O0 MLTO O2) ;
  (O1 MLTO O2) MLTO O0 -> O1 MLTO (O2 MLTO O0) ;
  (O1 TSRO O2) MLTO (O1' TSRO O2') -> (O1 MLTO O1') TSRO (O2 MLTO O2') ;
  (O1 TSRO O2) MLTO ((O1' TSRO O2') MLTO O0) -> ((O1 MLTO O1') TSRO (O2 MLTO O2')) MLTO O0 ;

  (* >>>> Tensor Product <<<< *)
  0O TSRO O0 -> 0O ;
  O0 TSRO 0O -> 0O ;
  (K1 OUTER K2) TSRO (K1' OUTER K2') -> (K1 TSRV K1') OUTER (K2 TSRV K2') ;
  (S0 SCRO O1) TSRO O2 -> S0 SCRO (O1 TSRO O2) ;
  O1 TSRO (S0 SCRO O2) -> S0 SCRO (O1 TSRO O2) ;
  (O1 ADDO O2) TSRO O0 -> (O1 TSRO O0) ADDO (O2 TSRO O0) ;
  O0 TSRO (O1 ADDO O2) -> (O0 TSRO O1) ADDO (O0 TSRO O2) ;

  
  (* ################# extension rules for AC symbols ################## *)

  (* To prove the confluence of a system with AC symbols, we need to check the critical pairs of an extended system. *)

  (0 + a) + x -> a + x ;
  (0 * a) * x -> 0 * x ;
  (1 * a) * x -> a * x ;
  (a * (b + c)) * x -> ((a * b) + (a * c)) * x ;

  (C(0) ADDS a) ADDS x -> a ADDS x ;
  (C(a) ADDS C(b)) ADDS x -> C(a + b) ADDS x ;
  (S0 ADDS S0) ADDS x -> (C(1 + 1) MLTS S0) ADDS x ;
  ((C(a) MLTS S0) ADDS S0) ADDS x -> (C(a + 1) MLTS S0) ADDS x ;
  ((C(a) MLTS S0) ADDS (C(b) MLTS S0)) ADDS x -> (C(a + b) MLTS S0) ADDS x ;

  (C(0) MLTS a) MLTS x -> C(0) MLTS x ;
  (C(1) MLTS a) MLTS x -> a MLTS x ;
  (C(a) MLTS C(b)) MLTS x -> C(a * b) MLTS x ;
  (S1 MLTS (S2 ADDS S3)) MLTS x -> ((S1 MLTS S2) ADDS (S1 MLTS S3)) MLTS x ;

  (K0 ADDV 0V) ADDV x -> K0 ADDV x ;
  (K0 ADDV K0) ADDV x -> (C(1 + 1) SCRV K0) ADDV x ;
  ((S0 SCRV K0) ADDV K0) ADDV x -> ((S0 ADDS C(1)) SCRV K0) ADDV x ;
  ((S1 SCRV K0) ADDV (S2 SCRV K0)) ADDV x -> ((S1 ADDS S2) SCRV K0) ADDV x ;

  (O0 ADDO 0O) ADDO x -> O0 ADDO x ;
  (O0 ADDO O0) ADDO x -> (C(1 + 1) SCRO O0) ADDO x ;
  ((S0 SCRO O0) ADDO O0) ADDO x -> ((S0 ADDS C(1)) SCRO O0) ADDO x ;
  ((S1 SCRO O0) ADDO (S2 SCRO O0)) ADDO x -> ((S1 ADDS S2) SCRO O0) ADDO x ;
  
";

(* optional : 

  delta(s, s) -> C(1) ;

*)

