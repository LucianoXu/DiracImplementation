(* 

    We demonstrated that error can be throw out in a type system.

    Yingte Xu, 2024

*)

let F = signature
"

  (* unchecked syntax *)

  ADD : AC ;
  MLT : AC ;
  CONJ : unary ;

  (* complex number *)
  + : AC ;
  * : AC ;
  0 : constant ;
  1 : constant ;
  ^* : postfix unary ;

  WT : unary ;
  error : constant ;

";

let X = vars "a b c x S0 S1 S2 S3 s s1 s2 t t1 t2 B0 B1 B2 K0 K1 K2 O0 O1 O2 O1' O2' T1 T2 T3 T4";

let R = TRS F X "


  (* ############# REDUCTION RULES FOR INTERNAL LANGUAGE ############### *)

  WT(a) ADD WT(b) -> WT(a + b) ;
  WT(a) MLT WT(b) -> WT(a * b) ;
  CONJ(WT(a)) -> WT(a ^*) ;

  error ADD a -> error ;
  error MLT a -> error ;
  CONJ(error) -> error ;

  (********************************************)
  (*           complex number (avatar)        *)
  (********************************************)

  0 + a -> a ;
  0 * a -> 0 ;
  1 * a -> a ;
  a * (b + c) -> (a * b) + (a * c) ;
  0 ^* -> 0 ;
  1 ^* -> 1 ;
  (a + b) ^* -> (a ^*) + (b ^*) ;
  (a * b) ^* -> (a ^*) * (b ^*) ;
  (a ^*) ^* -> a ;
  
  (* ################# extension rules for AC symbols ################## *)

  (* To prove the confluence of a system with AC symbols, we need to check the critical pairs of an extended system. *)

  (WT(a) ADD WT(b)) ADD x -> WT(a + b) ADD x ;
  (WT(a) MLT WT(b)) MLT x -> WT(a * b) MLT x ;

  (error ADD a) ADD x -> error ADD x ;
  (error MLT a) MLT x -> error MLT x ;

  (0 + a) + x -> a + x ;
  (0 * a) * x -> 0 * x ;
  (1 * a) * x -> a * x ;
  (a * (b + c)) * x -> ((a * b) + (a * c)) * x ;
  
";