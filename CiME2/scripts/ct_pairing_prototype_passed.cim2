(* 

    Language and Term Rewriting System for "Typed Dirac Notation"

    This language can be used in two levels: deal with the internal untyped language directly,
    or use the typed syntax with type polymorphism.

    Yingte Xu, 2024

    We use the pairing technique to deal with conjugate and transpose problem. It works in the subsignature.

*)

let F = signature
"

  (* complex number *)
  + : AC ;
  * : AC ;
  0 : constant ;
  1 : constant ;
  ^* : postfix unary ;


  (* -------- internal langauge -------- *)

  (* Basis *)
  pair : binary ;
  fst : unary ;
  snd : unary ;

  (* Scalar *)
  C : unary ;
  delta : commutative ;
  ADDS : AC ;
  MLTS : AC ;
  CONJS : unary ;
  DOT : infix binary ;

  doteq : commutative ;
  INDOT : infix binary ;

  (* Ket *)
  0K : constant ;
  ket : unary ;
  CONJK : unary ;
  TRANK : unary ;

  (* Bra *)
  0B : constant ;
  bra : unary ;
  CONJB : unary ;
  TRANB : unary ;

";

let X = vars "a b c x y S0 S1 S2 S3 s s1 s2 t t1 t2 B0 B1 B2 K0 K1 K2 O0 O1 O2 O1' O2' T1 T2 T3 T4";

let R = TRS F X "


  (* ############# REDUCTION RULES FOR INTERNAL LANGUAGE ############### *)

  (********************************************)
  (*           complex number (avatar)        *)
  (********************************************)

  0 + a -> a ;
  0 * a -> 0 ;
  1 * a -> a ;
  a * (b + c) -> (a * b) + (a * c) ;
  0 ^* -> 0 ;
  1 ^* -> 1 ;
  (a + b) ^* -> (a ^*) + (b ^*) ;
  (a * b) ^* -> (a ^*) * (b ^*) ;
  (a ^*) ^* -> a ;

  (********************************************)
  (*                 Basis                    *)
  (********************************************)

  fst(pair(s, t)) -> s ;
  snd(pair(s, t)) -> t ;
  pair(fst(t), snd(t)) -> t ;


  (********************************************)
  (*                 Scalars                  *)
  (********************************************)

  (* ============== Delta Operator ================ *)

  delta(s, pair(t1, t2)) -> delta(fst(s), t1) MLTS delta(snd(s), t2) ;
  delta(fst(s), fst(t)) MLTS delta(snd(s), snd(t)) -> delta(s, t) ;

  (* ============================================== *)

  C(0) ADDS a -> a ;
  C(a) ADDS C(b) -> C(a + b) ;
  S0 ADDS S0 -> C(1 + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS S0 -> C(a + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS (C(b) MLTS S0) -> C(a + b) MLTS S0 ;

  C(0) MLTS a -> C(0) ;
  C(1) MLTS a -> a ;
  C(a) MLTS C(b) -> C(a * b) ;
  S1 MLTS (S2 ADDS S3) -> (S1 MLTS S2) ADDS (S1 MLTS S3) ;


  CONJS(C(a)) -> C(a ^*) ;
  CONJS(delta(s, t)) -> delta(s, t) ;
  CONJS(S1 ADDS S2) -> CONJS(S1) ADDS CONJS(S2) ;
  CONJS(S1 MLTS S2) -> CONJS(S1) MLTS CONJS(S2) ;
  CONJS(CONJS(S0)) -> S0 ;

  CONJS(doteq(x, y)) -> doteq(CONJS(x), CONJS(y)) ;
  CONJS(B0 INDOT K0) -> TRANB(K0) INDOT TRANK(B0) ;

  B0 DOT K0 -> doteq(B0 INDOT K0, CONJB(TRANB(K0)) INDOT CONJK(TRANK(B0))) ;
  

  doteq(0B INDOT K0, B0 INDOT 0K) -> C(0) ;
  doteq(bra(s) INDOT ket(t), bra(t) INDOT ket(s)) -> delta(s, t) ;

  (********************************************)
  (*            Ket and Bra                   *)
  (********************************************)

  (* >>>> Conjugate <<<< *)
  CONJK(0K) -> 0K ;
  CONJK(ket(t)) -> ket(t) ;
  CONJK(CONJK(K0)) -> K0 ;

  CONJB(0B) -> 0B ;
  CONJB(bra(t)) -> bra(t) ;
  CONJB(CONJB(B0)) -> B0 ;


  (* >>>> Transpose <<<< *)
  TRANK(0B) -> 0K ;
  TRANK(bra(t)) -> ket(t) ;
  TRANK(CONJB(B0)) -> CONJK(TRANK(B0)) ;
  TRANK(TRANB(K0)) -> K0 ;

  TRANB(0K) -> 0B ;
  TRANB(ket(t)) -> bra(t) ;
  TRANB(CONJK(K0)) -> CONJB(TRANB(K0)) ;
  TRANB(TRANK(B0)) -> B0 ;

  (* ################# extension rules for AC symbols ################## *)

  (* To prove the confluence of a system with AC symbols, we need to check the critical pairs of an extended system. *)

  (0 + a) + x -> a + x ;
  (0 * a) * x -> 0 * x ;
  (1 * a) * x -> a * x ;
  (a * (b + c)) * x -> ((a * b) + (a * c)) * x ;

  (C(0) ADDS a) ADDS x -> a ADDS x ;
  (C(a) ADDS C(b)) ADDS x -> C(a + b) ADDS x ;
  (S0 ADDS S0) ADDS x -> (C(1 + 1) MLTS S0) ADDS x ;
  ((C(a) MLTS S0) ADDS S0) ADDS x -> (C(a + 1) MLTS S0) ADDS x ;
  ((C(a) MLTS S0) ADDS (C(b) MLTS S0)) ADDS x -> (C(a + b) MLTS S0) ADDS x ;

  (C(0) MLTS a) MLTS x -> C(0) MLTS x ;
  (C(1) MLTS a) MLTS x -> a MLTS x ;
  (C(a) MLTS C(b)) MLTS x -> C(a * b) MLTS x ;
  (S1 MLTS (S2 ADDS S3)) MLTS x -> ((S1 MLTS S2) ADDS (S1 MLTS S3)) MLTS x ;

";

(* optional : 

  delta(s, s) -> C(1) ;

*)