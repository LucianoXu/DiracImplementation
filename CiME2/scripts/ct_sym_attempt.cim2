(* 

    Language and Term Rewriting System for "Typed Dirac Notation"

    This language can be used in two levels: deal with the internal untyped language directly,
    or use the typed syntax with type polymorphism.

    Yingte Xu, 2024

    test - test whether the sym operation solves the problem of conjugate transpose
      rich symmetrization

*)

let F = signature
"

  (* complex number *)
  + : AC ;
  * : AC ;
  0 : constant ;
  half : constant ;
  1 : constant ;
  ^* : postfix unary ;


  (* -------- internal langauge -------- *)

  (* Basis *)
  pair : binary ;
  fst : unary ;
  snd : unary ;

  (* Scalar *)
  C : unary ;
  delta : commutative ;
  ADDS : AC ;
  MLTS : AC ;
  CONJS : unary ;
  DOT : infix binary ;
  sym : unary ;

  (* Ket *)
  0K : constant ;
  ket : unary ;
  CONJK : unary ;
  TRANK : unary ;
  SCRK : infix binary ;
  ADDK : AC ;
  MLTK : infix binary ;
  TSRK : infix binary ;

  (* Bra *)
  0B : constant ;
  bra : unary ;
  CONJB : unary ;
  TRANB : unary ;
  SCRB : infix binary ;
  ADDB : AC ;
  MLTB : infix binary ;
  TSRB : infix binary ;

  (* Operator *)
  0O : constant ;
  OUTER : infix binary ;
  CONJO : unary ;
  TRANO : unary ;
  SCRO : infix binary ;
  ADDO : AC ;
  MLTO : infix binary ;
  TSRO : infix binary ;

";

let X = vars "a b c x S0 S1 S2 S3 s s1 s2 t t1 t2 B0 B1 B2 K0 K1 K2 O0 O1 O2 O1' O2' T1 T2 T3 T4 x0 x1 x2 x3 x4";

let R = TRS F X "


  (* ############# REDUCTION RULES FOR INTERNAL LANGUAGE ############### *)

  (********************************************)
  (*           complex number (avatar)        *)
  (********************************************)

  0 + a -> a ;
  half + half -> 1 ;
  (half * a) + (half * a) -> a;
  0 * a -> 0 ;
  1 * a -> a ;
  a * (b + c) -> (a * b) + (a * c) ;
  0 ^* -> 0 ;
  half ^* -> half ;
  1 ^* -> 1 ;
  (a + b) ^* -> (a ^*) + (b ^*) ;
  (a * b) ^* -> (a ^*) * (b ^*) ;
  (a ^*) ^* -> a ;


  (********************************************)
  (*                 Basis                    *)
  (********************************************)

  fst(pair(s, t)) -> s ;
  snd(pair(s, t)) -> t ;
  pair(fst(t), snd(t)) -> t ;


  (********************************************)
  (*                 Scalars                  *)
  (********************************************)

  (* ============== Delta Operator ================ *)

  delta(s, pair(t1, t2)) -> delta(fst(s), t1) MLTS delta(snd(s), t2) ;
  delta(fst(s), fst(t)) MLTS delta(snd(s), snd(t)) -> delta(s, t) ;

  (* ============================================== *)


  C(0) ADDS a -> a ;
  C(a) ADDS C(b) -> C(a + b) ;
  S0 ADDS S0 -> C(1 + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS S0 -> C(a + 1) MLTS S0 ;
  (C(a) MLTS S0) ADDS (C(b) MLTS S0) -> C(a + b) MLTS S0 ;

  C(0) MLTS a -> C(0) ;
  C(1) MLTS a -> a ;
  C(a) MLTS C(b) -> C(a * b) ;
  S1 MLTS (S2 ADDS S3) -> (S1 MLTS S2) ADDS (S1 MLTS S3) ;


  CONJS(C(a)) -> C(a ^*) ;
  CONJS(delta(s, t)) -> delta(s, t) ;
  CONJS(S1 ADDS S2) -> CONJS(S1) ADDS CONJS(S2) ;
  CONJS(S1 MLTS S2) -> CONJS(S1) MLTS CONJS(S2) ;
  CONJS(CONJS(S0)) -> sym(S0) ;
  CONJS(B0 DOT K0) -> sym(CONJB(B0) DOT CONJK(K0)) ;

  
  0B DOT K0 -> C(0) ;
  B0 DOT 0K -> C(0) ;
  (S0 SCRB B0) DOT K0 -> sym(S0) MLTS (B0 DOT K0) ;
  B0 DOT (S0 SCRK K0) -> sym(S0) MLTS (B0 DOT K0) ;
  (B1 ADDB B2) DOT K0 -> (B1 DOT K0) ADDS (B2 DOT K0) ;
  B0 DOT (K1 ADDK K2) -> (B0 DOT K1) ADDS (B0 DOT K2) ;
  bra(s) DOT ket(t) -> delta(s, t) ;
  (B1 TSRB B2) DOT ket(t) -> sym(B1 DOT ket(fst(t))) MLTS sym(B2 DOT ket(snd(t))) ;
  bra(t) DOT (K1 TSRK K2) -> sym(bra(fst(t)) DOT K1) MLTS sym(bra(snd(t)) DOT K2) ;
  (B1 TSRB B2) DOT (K1 TSRK K2) -> sym(B1 DOT K1) MLTS sym(B2 DOT K2) ;

  sym(B0 DOT K0) -> (C(half) MLTS (sym(B0) DOT sym(K0))) ADDS (C(half) MLTS (TRANB(sym(K0)) DOT TRANK(sym(B0)))) ;
  sym(C(a)) -> C(a) ;
  sym(delta(s, t)) -> delta(s, t) ;
  sym(a ADDS b) -> sym(a) ADDS sym(b) ;
  sym(a MLTS b) -> sym(a) MLTS sym(b) ;
  sym(sym(S0)) -> sym(S0) ;

  sym(CONJS(S0)) -> CONJS(sym(S0)) ;

  sym(0K) -> 0K ;
  sym(0B) -> 0B ;
  sym(ket(t)) -> ket(t) ;
  sym(bra(t)) -> bra(t) ;
  sym(CONJK(K0)) -> CONJK(sym(K0)) ;
  sym(CONJB(B0)) -> CONJB(sym(B0)) ;
  sym(TRANK(B0)) -> TRANK(sym(B0)) ;
  sym(TRANB(K0)) -> TRANB(sym(K0)) ;
  sym(S0 SCRK K0) -> sym(S0) SCRK sym(K0) ;
  sym(S0 SCRB B0) -> sym(S0) SCRB sym(B0) ;
  sym(K1 ADDK K2) -> sym(K1) ADDK sym(K2) ;
  sym(B1 ADDB B2) -> sym(B1) ADDB sym(B2) ;
  sym(O0 MLTK K0) -> sym(O0) MLTK sym(K0) ;
  sym(B0 MLTB O0) -> sym(B0) MLTB sym(O0) ;
  sym(K1 TSRK K2) -> sym(K1) TSRK sym(K2) ;
  sym(B1 TSRB B2) -> sym(B1) TSRB sym(B2) ;
  sym(0O) -> 0O ;
  sym(K0 OUTER B0) -> sym(K0) OUTER sym(B0) ;
  sym(CONJO(O0)) -> CONJO(sym(O0)) ;
  sym(TRANO(O0)) -> TRANO(sym(O0)) ;
  sym(S0 SCRO O0) -> sym(S0) SCRO sym(O0) ;
  sym(O1 ADDO O2) -> sym(O1) ADDO sym(O2) ;
  sym(O1 MLTO O2) -> sym(O1) MLTO sym(O2) ;
  sym(O1 TSRO O2) -> sym(O1) TSRO sym(O2) ;




  (B0 MLTB O0) DOT K0 -> B0 DOT (O0 MLTK K0) ;
  bra(s) DOT ((O1 TSRO O2) MLTK K0) -> sym(((bra(fst(s)) MLTB O1) TSRB (bra(snd(s)) MLTB O2)) DOT K0) ;
  (B1 TSRB B2) DOT ((O1 TSRO O2) MLTK K0) -> sym(((B1 MLTB O1) TSRB (B2 MLTB O2)) DOT K0) ;


  (********************************************)
  (*            Ket and Bra                   *)
  (********************************************)

  (* >>>> Conjugate <<<< *)
  CONJK(0K) -> 0K ;
  CONJK(ket(t)) -> ket(t) ;
  CONJK(CONJK(K0)) -> K0 ;
  CONJK(S0 SCRK K0) -> CONJS(S0) SCRK CONJK(K0) ;
  CONJK(K1 ADDK K2) -> CONJK(K1) ADDK CONJK(K2) ;
  CONJK(O0 MLTK K0) -> CONJO(O0) MLTK CONJK(K0) ;
  CONJK(K1 TSRK K2) -> CONJK(K1) TSRK CONJK(K2) ;

  CONJB(0B) -> 0B ;
  CONJB(bra(t)) -> bra(t) ;
  CONJB(CONJB(B0)) -> B0 ;
  CONJB(S0 SCRB B0) -> CONJS(S0) SCRB CONJB(B0) ;
  CONJB(B1 ADDB B2) -> CONJB(B1) ADDB CONJB(B2) ;
  CONJB(B0 MLTB O0) -> CONJB(B0) MLTB CONJO(O0) ;
  CONJB(B1 TSRB B2) -> CONJB(B1) TSRB CONJB(B2) ;


  (* >>>> Transpose <<<< *)
  TRANK(0B) -> 0K ;
  TRANK(bra(t)) -> ket(t) ;
  TRANK(CONJB(B0)) -> CONJK(TRANK(B0)) ;
  TRANK(TRANB(K0)) -> K0 ;
  TRANK(S0 SCRB B0) -> S0 SCRK TRANK(B0) ;
  TRANK(B1 ADDB B2) -> TRANK(B1) ADDK TRANK(B2) ;
  TRANK(B0 MLTB O0) -> TRANO(O0) MLTK TRANK(B0) ;
  TRANK(B1 TSRB B2) -> TRANK(B1) TSRK TRANK(B2) ;

  TRANB(0K) -> 0B ;
  TRANB(ket(t)) -> bra(t) ;
  TRANB(CONJK(K0)) -> CONJB(TRANB(K0)) ;
  TRANB(TRANK(B0)) -> B0 ;
  TRANB(S0 SCRK K0) -> S0 SCRB TRANB(K0) ;
  TRANB(K1 ADDK K2) -> TRANB(K1) ADDB TRANB(K2) ;
  TRANB(O0 MLTK K0) -> TRANB(K0) MLTB TRANO(O0) ;
  TRANB(K1 TSRK K2) -> TRANB(K1) TSRB TRANB(K2) ;

  (* >>>> Scalar Multiplication <<<< *)
  C(0) SCRK K0 -> 0K ;
  C(1) SCRK K0 -> K0 ;
  S0 SCRK 0K -> 0K ;
  S1 SCRK (S2 SCRK K0) -> (S1 MLTS S2) SCRK K0 ;
  S0 SCRK (K1 ADDK K2) -> (S0 SCRK K1) ADDK (S0 SCRK K2) ;

  C(0) SCRB B0 -> 0B ;
  C(1) SCRB B0 -> B0 ;
  S0 SCRB 0B -> 0B ;
  S1 SCRB (S2 SCRB B0) -> (S1 MLTS S2) SCRB B0 ;
  S0 SCRB (B1 ADDB B2) -> (S0 SCRB B1) ADDB (S0 SCRB B2) ;

  (* >>>> Addition <<<< *)
  K0 ADDK 0K -> K0 ;
  K0 ADDK K0 -> C(1 + 1) SCRK K0 ;
  (S0 SCRK K0) ADDK K0 -> (S0 ADDS C(1)) SCRK K0 ;
  (S1 SCRK K0) ADDK (S2 SCRK K0) -> (S1 ADDS S2) SCRK K0 ;

  B0 ADDB 0B -> B0 ;
  B0 ADDB B0 -> C(1 + 1) SCRB B0 ;
  (S0 SCRB B0) ADDB B0 -> (S0 ADDS C(1)) SCRB B0 ;
  (S1 SCRB B0) ADDB (S2 SCRB B0) -> (S1 ADDS S2) SCRB B0 ;


  (* >>>> Multiplication <<<< *)
  0O MLTK K0 -> 0K ;
  O0 MLTK 0K -> 0K ;
  (S0 SCRO O0) MLTK K0 -> S0 SCRK (O0 MLTK K0) ;
  O0 MLTK (S0 SCRK K0) -> S0 SCRK (O0 MLTK K0) ;
  (O1 ADDO O2) MLTK K0 -> (O1 MLTK K0) ADDK (O2 MLTK K0) ;
  O0 MLTK (K1 ADDK K2) -> (O0 MLTK K1) ADDK (O0 MLTK K2) ;
  (K1 OUTER B0) MLTK K2 -> sym(B0 DOT K2) SCRK K1 ;
  (O1 MLTO O2) MLTK K0 -> O1 MLTK (O2 MLTK K0) ;
  (O1 TSRO O2) MLTK ((O1' TSRO O2') MLTK K0) -> ((O1 MLTO O1') TSRO (O2 MLTO O2')) MLTK K0 ;
  (O1 TSRO O2) MLTK ket(t) -> (O1 MLTK ket(fst(t))) TSRK (O2 MLTK ket(snd(t))) ;
  (O1 TSRO O2) MLTK (K1 TSRK K2) -> (O1 MLTK K1) TSRK (O2 MLTK K2) ;

  B0 MLTB 0O -> 0B ;
  0B MLTB O0 -> 0B ;
  B0 MLTB (S0 SCRO O0) -> S0 SCRB (B0 MLTB O0) ;
  (S0 SCRB B0) MLTB O0 -> S0 SCRB (B0 MLTB O0) ;
  B0 MLTB (O1 ADDO O2) -> (B0 MLTB O1) ADDB (B0 MLTB O2) ;
  (B1 ADDB B2) MLTB O0 -> (B1 MLTB O0) ADDB (B2 MLTB O0) ;
  B1 MLTB (K0 OUTER B2) -> sym(B1 DOT K0) SCRB B2 ;
  B0 MLTB (O1 MLTO O2) -> (B0 MLTB O1) MLTB O2 ;
  (B0 MLTB (O1' TSRO O2')) MLTB (O1 TSRO O2) -> B0 MLTB ((O1' MLTO O1) TSRO (O2' MLTO O2)) ;
  bra(t) MLTB (O1 TSRO O2) -> (bra(fst(t)) MLTB O1) TSRB (bra(snd(t)) MLTB O2) ;
  (B1 TSRB B2) MLTB (O1 TSRO O2) -> (B1 MLTB O1) TSRB (B2 MLTB O2) ;

  (* >>>> Tensor Product <<<< *)
  0K TSRK K0 -> 0K ;
  K0 TSRK 0K -> 0K ;
  ket(s) TSRK ket(t) -> ket(pair(s, t)) ;
  (S0 SCRK K1) TSRK K2 -> S0 SCRK (K1 TSRK K2) ;
  K1 TSRK (S0 SCRK K2) -> S0 SCRK (K1 TSRK K2) ;
  (K1 ADDK K2) TSRK K0 -> (K1 TSRK K0) ADDK (K2 TSRK K0) ;
  K0 TSRK (K1 ADDK K2) -> (K0 TSRK K1) ADDK (K0 TSRK K2) ;

  0B TSRB B0 -> 0B ;
  B0 TSRB 0B -> 0B ;
  bra(s) TSRB bra(t) -> bra(pair(s, t)) ;
  (S0 SCRB B1) TSRB B2 -> S0 SCRB (B1 TSRB B2) ;
  B1 TSRB (S0 SCRB B2) -> S0 SCRB (B1 TSRB B2) ;
  (B1 ADDB B2) TSRB B0 -> (B1 TSRB B0) ADDB (B2 TSRB B0) ;
  B0 TSRB (B1 ADDB B2) -> (B0 TSRB B1) ADDB (B0 TSRB B2) ;

  (********************************************)
  (*             Operators                    *)
  (********************************************)

  (* >>>> Outer Product <<<< *)
  0K OUTER B0 -> 0O ;
  K0 OUTER 0B -> 0O ;
  (S0 SCRK K0) OUTER B0 -> S0 SCRO (K0 OUTER B0) ;
  K0 OUTER (S0 SCRB B0) -> S0 SCRO (K0 OUTER B0) ;
  (K1 ADDK K2) OUTER B0 -> (K1 OUTER B0) ADDO (K2 OUTER B0) ;
  K0 OUTER (B1 ADDB B2) -> (K0 OUTER B1) ADDO (K0 OUTER B2) ;

  (* >>>> Conjugate <<<< *)
  CONJO(0O) -> 0O ;
  CONJO(K0 OUTER B0) -> CONJK(K0) OUTER CONJB(B0) ;
  CONJO(CONJO(O0)) -> O0 ;
  CONJO(S0 SCRO O0) -> CONJS(S0) SCRO CONJO(O0) ;
  CONJO(O1 ADDO O2) -> CONJO(O1) ADDO CONJO(O2) ;
  CONJO(O1 MLTO O2) -> CONJO(O1) MLTO CONJO(O2) ;
  CONJO(O1 TSRO O2) -> CONJO(O1) TSRO CONJO(O2) ;

  (* >>>> Transpose <<<< *)
  TRANO(0O) -> 0O ;
  TRANO(K0 OUTER B0) -> TRANK(B0) OUTER TRANB(K0) ;
  TRANO(CONJO(O0)) -> CONJO(TRANO(O0)) ;
  TRANO(TRANO(O0)) -> O0 ;
  TRANO(S0 SCRO O0) -> S0 SCRO TRANO(O0) ;
  TRANO(O1 ADDO O2) -> TRANO(O1) ADDO TRANO(O2) ;
  TRANO(O1 MLTO O2) -> TRANO(O2) MLTO TRANO(O1) ;
  TRANO(O1 TSRO O2) -> TRANO(O1) TSRO TRANO(O2) ;

  (* >>>> Scalar Multiplication <<<< *)
  C(0) SCRO O0 -> 0O ;
  C(1) SCRO O0 -> O0 ;
  S0 SCRO 0O -> 0O ;
  S1 SCRO (S2 SCRO O0) -> (S1 MLTS S2) SCRO O0 ;
  S0 SCRO (O1 ADDO O2) -> (S0 SCRO O1) ADDO (S0 SCRO O2) ;

  (* >>>> Addition <<<< *)
  O0 ADDO 0O -> O0 ;
  O0 ADDO O0 -> C(1 + 1) SCRO O0 ;
  (S0 SCRO O0) ADDO O0 -> (S0 ADDS C(1)) SCRO O0 ;
  (S1 SCRO O0) ADDO (S2 SCRO O0) -> (S1 ADDS S2) SCRO O0 ;


  (* >>>> Multiplication <<<< *)
  0O MLTO O0 -> 0O ;
  O0 MLTO 0O -> 0O ;
  (K0 OUTER B0) MLTO O0 -> K0 OUTER (B0 MLTB O0) ;
  O0 MLTO (K0 OUTER B0) -> (O0 MLTK K0) OUTER B0 ;
  (S0 SCRO O1) MLTO O2 -> S0 SCRO (O1 MLTO O2) ;
  O1 MLTO (S0 SCRO O2) -> S0 SCRO (O1 MLTO O2) ;
  (O1 ADDO O2) MLTO O0 -> (O1 MLTO O0) ADDO (O2 MLTO O0) ;
  O0 MLTO (O1 ADDO O2) -> (O0 MLTO O1) ADDO (O0 MLTO O2) ;
  (O1 MLTO O2) MLTO O0 -> O1 MLTO (O2 MLTO O0) ;
  (O1 TSRO O2) MLTO (O1' TSRO O2') -> (O1 MLTO O1') TSRO (O2 MLTO O2') ;
  (O1 TSRO O2) MLTO ((O1' TSRO O2') MLTO O0) -> ((O1 MLTO O1') TSRO (O2 MLTO O2')) MLTO O0 ;

  (* >>>> Tensor Product <<<< *)
  0O TSRO O0 -> 0O ;
  O0 TSRO 0O -> 0O ;
  (K1 OUTER B1) TSRO (K2 OUTER B2) -> (K1 TSRK K2) OUTER (B1 TSRB B2) ;
  (S0 SCRO O1) TSRO O2 -> S0 SCRO (O1 TSRO O2) ;
  O1 TSRO (S0 SCRO O2) -> S0 SCRO (O1 TSRO O2) ;
  (O1 ADDO O2) TSRO O0 -> (O1 TSRO O0) ADDO (O2 TSRO O0) ;
  O0 TSRO (O1 ADDO O2) -> (O0 TSRO O1) ADDO (O0 TSRO O2) ;

  
  (* ################# extension rules for AC symbols ################## *)

  (* To prove the confluence of a system with AC symbols, we need to check the critical pairs of an extended system. *)

  (0 + a) + x -> a + x ;
  (half + half) + x -> 1 + x ;
  ((half * a) + (half * a)) + x -> a + x ;
  (0 * a) * x -> 0 * x ;
  (1 * a) * x -> a * x ;
  (a * (b + c)) * x -> ((a * b) + (a * c)) * x ;

  (C(0) ADDS a) ADDS x -> a ADDS x ;
  (C(a) ADDS C(b)) ADDS x -> C(a + b) ADDS x ;
  (S0 ADDS S0) ADDS x -> (C(1 + 1) MLTS S0) ADDS x ;
  ((C(a) MLTS S0) ADDS S0) ADDS x -> (C(a + 1) MLTS S0) ADDS x ;
  ((C(a) MLTS S0) ADDS (C(b) MLTS S0)) ADDS x -> (C(a + b) MLTS S0) ADDS x ;

  (C(0) MLTS a) MLTS x -> C(0) MLTS x ;
  (C(1) MLTS a) MLTS x -> a MLTS x ;
  (C(a) MLTS C(b)) MLTS x -> C(a * b) MLTS x ;
  (S1 MLTS (S2 ADDS S3)) MLTS x -> ((S1 MLTS S2) ADDS (S1 MLTS S3)) MLTS x ;

  (K0 ADDK 0K) ADDK x -> K0 ADDK x ;
  (K0 ADDK K0) ADDK x -> (C(1 + 1) SCRK K0) ADDK x ;
  ((S0 SCRK K0) ADDK K0) ADDK x -> ((S0 ADDS C(1)) SCRK K0) ADDK x ;
  ((S1 SCRK K0) ADDK (S2 SCRK K0)) ADDK x -> ((S1 ADDS S2) SCRK K0) ADDK x ;

  (B0 ADDB 0B) ADDB x -> B0 ADDB x ;
  (B0 ADDB B0) ADDB x -> (C(1 + 1) SCRB B0) ADDB x ;
  ((S0 SCRB B0) ADDB B0) ADDB x -> ((S0 ADDS C(1)) SCRB B0) ADDB x ;
  ((S1 SCRB B0) ADDB (S2 SCRB B0)) ADDB x -> ((S1 ADDS S2) SCRB B0) ADDB x ;

  (O0 ADDO 0O) ADDO x -> O0 ADDO x ;
  (O0 ADDO O0) ADDO x -> (C(1 + 1) SCRO O0) ADDO x ;
  ((S0 SCRO O0) ADDO O0) ADDO x -> ((S0 ADDS C(1)) SCRO O0) ADDO x ;
  ((S1 SCRO O0) ADDO (S2 SCRO O0)) ADDO x -> ((S1 ADDS S2) SCRO O0) ADDO x ;
  
";

(* optional : 

  delta(s, s) -> C(1) ;

*)

let u = term F X "sym(sym(((bra(fst(x0)) MLTB x1) TSRB (bra(snd(x0)) MLTB x2)) DOT x3))";
let v = term F X "(C(half) MLTS (sym(bra(x0)) DOT sym((x1 TSRO x2) MLTK x3))) ADDS 
  (C(half) MLTS (TRANB(sym((x1 TSRO x2) MLTK x3)) DOT TRANK(sym(bra(x0)))))";